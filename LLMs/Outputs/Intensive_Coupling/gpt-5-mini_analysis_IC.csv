file_path,analysis
AccessControlLogEntry.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- AccessControlLogEntry(Map<String, Object> map) — calls map.get(...) multiple times and calls getMapFromRawClientInfo(...)
- private Map<String, String> getMapFromRawClientInfo(String clientInfo) — calls clientInfo.split(...), entry.split(...), and clientInfoMap.put(...)
- public String toString() — performs multiple field accesses and string concatenations (implicit StringBuilder operations)

2. Calls Concentrated in Few Classes:
- Yes — most calls are to a few core classes:
  - java.util.Map (map.get, clientInfoMap.put)
  - java.lang.String (split, concatenation)
  - java.util.LinkedHashMap (constructor)
  - (implicitly) java.lang.StringBuilder via string concatenation in toString

3. Method Complexity:
- Methods are low complexity:
  - Constructor: straight-line initialization, no nesting.
  - getMapFromRawClientInfo: single loop with a simple conditional (ternary) per entry.
  - toString: simple concatenation.
  - No deep nesting or many conditional branches.

4. Potential Fragility:
- Changes in provider behavior could require updates or cause runtime errors:
  - If the input map changes key names or types (e.g., COUNT not a Long), the constructor’s casts will fail and need adjustment.
  - If the CLIENT_INFO string format changes (different separators, missing = semantics), getMapFromRawClientInfo will mis-parse and must be updated.
  - Changes to Map semantics or expectation of ordering could affect clientInfoMap usage.

5. Summary Judgment:
- Based on this file alone, there are calls concentrated in a few core JDK classes (Map, String, LinkedHashMap), but the methods are simple and do not call an excessive number of methods across provider classes. Therefore this file does not exhibit strong symptoms of Intensive Coupling."
Preconditions.java,
FileRefreshableDataSource.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- readSource()
- The main constructor FileRefreshableDataSource(... ) (the long one)
- firstLoad()

2. Calls Concentrated in Few Classes:
- readSource(): most calls are to java.io classes and related APIs (File, FileInputStream, FileChannel) plus RecordLog and String/Charset.
- Constructor / firstLoad(): calls concentrated to File (isDirectory, lastModified), superclass (super(...), firstLoad -> loadConfig(), getProperty().updateValue()), and RecordLog in catch blocks.
- Provider classes (local to this file): java.io.File, java.io.FileInputStream, java.nio.channels.FileChannel, RecordLog, and the superclass/provider methods from AutoRefreshDataSource (loadConfig, getProperty().updateValue).

3. Method Complexity:
- readSource(): low to moderate complexity — one conditional check, a try-finally, and an error throw; no deep nesting.
- Constructor: linear validation checks and initialization; not deeply nested.
- firstLoad(): simple try-catch around two calls; not complex.

4. Potential Fragility:
- Yes — changes in provider classes/APIs would likely require changes here. Examples:
  - If FileChannel.size() or FileInputStream.read(...) semantics change (or buffer handling requirements change), readSource() would need updating.
  - If AutoRefreshDataSource changes the getProperty()/updateValue() or loadConfig() signatures/semantics, firstLoad() and the constructor’s initialization would require changes.
  - If RecordLog logging API changes, catch blocks would need adaptation.

5. Summary Judgment:
- Based on the file, there are methods that call several methods, but those calls are mostly standard IO and superclass/provider methods and are not heavily concentrated in a single non-library provider class in a way that indicates Intensive Coupling."
SaSecureUtil.java,
ClassLoaderCommand.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- process(...)
- getAllClasses(...)
- getAllClassLoaderInfo(...)
- processClassLoaders(...)
- processClassLoaderStats(...)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated around a few provider types:
  - CommandProcess (process.appendResult, process.end, process.session(), process.isRunning(), process.interruptHandler)
  - Instrumentation (inst.getAllLoadedClasses())
  - ClassLoader / URLClassLoader (classLoader.getParent(), classLoader.getResources(), loadClass(), instanceof URLClassLoader, getURLs())
  - Utility classes in this package: ClassUtils, ClassLoaderUtils, ResultUtils
  - Minor: TreeMap/Collections APIs and model VO classes (ClassLoaderModel, ClassLoaderVO, etc.)

3. Method Complexity:
- Moderate complexity. Examples:
  - process(...) has multiple conditional branches (flag checks and a chain of if/else).
  - getAllClasses(...) and getAllClassLoaderInfo(...) contain loops, nested conditionals and inner while loops.
  - processClassLoaders(...) and processClassLoaderStats(...) are less nested but perform collection transformations and sorting.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require updates here. Examples:
  - If Instrumentation.getAllLoadedClasses() behaviour or return changed, getAllClasses(...) and getAllClassLoaderInfo(...) would be affected.
  - Changes to CommandProcess API (appendResult, end, session) would impact process(...) and many other methods that call process.
  - Changes to ClassLoader/URLClassLoader methods or semantics (getResources, getParent, getURLs, loadClass) would break resource/class lookup logic.
  - Changes in ClassUtils / ClassLoaderUtils utility APIs would break multiple call sites (createClassLoaderVOList, createClassInfo, etc.).

5. Summary Judgment:
- Yes — this file contains multiple methods that call many methods concentrated in a few provider classes (CommandProcess, Instrumentation, ClassLoader/URLClassLoader, ClassUtils/ClassLoaderUtils), showing symptoms of Intensive Coupling."
AclException.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. All methods are simple constructors, getters, or setters. The constructors only call super(...) and assign fields; getters/setters access fields.

2. Calls Concentrated in Few Classes:
- Not applicable (no heavy call activity). The only external calls are to java.lang.RuntimeException constructors (super(...)).

3. Method Complexity:
- No. Methods are simple, with no nesting or conditional branches.

4. Potential Fragility:
- Low. The only external dependency is RuntimeException constructors; if their signatures changed (very unlikely) constructors would need updating. Field changes (status/code) would be the other source of required changes.

5. Summary Judgment:
- This file does not exhibit Intensive Coupling."
GeneralAppIdDecoder.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- decodeAllCodes
- decodeGeneralPurposeField
- parseBlocks
- parseNumericBlock
- parseIsoIec646Block
- parseAlphaBlock
- isStillIsoIec646
- decodeIsoIec646
- isStillAlpha
- decodeAlphanumeric
- extractNumericValueFromBitArray (instance and static wrapper)

2. Calls Concentrated in Few Classes:
- BitArray (information.get, information.getSize, passed into extractNumericValueFromBitArray) — heavy use throughout.
- CurrentParsingState (current.getPosition, setPosition, isAlpha, isIsoIec646, isNumeric, setAlpha, setIsoIec646, setNumeric, incrementPosition) — used by most parse* methods.
- Decoded* data classes (DecodedNumeric, DecodedChar, DecodedInformation, BlockParsedResult) — construction and accessor calls concentrated in parsing methods.
- FieldParser (static parseFieldsInGeneralPurpose) — used by decodeAllCodes.

3. Method Complexity:
- Yes. parseBlocks, parseAlphaBlock, parseIsoIec646Block, parseNumericBlock and decodeIsoIec646 contain loops, multiple conditional branches and nested conditionals; decodeAllCodes has a loop with state updates; decodeIsoIec646/decodeAlphanumeric include large switch/if chains.

4. Potential Fragility:
- Yes. Changes to BitArray API or semantics (e.g., renaming get/getSize, changing indexing or bit semantics) would require edits in many methods (extractNumericValueFromBitArray, isStillAlpha/ISO/numeric checks, decode* methods).
- Changes to CurrentParsingState (method names, state transition logic, or position semantics) would require updates across parseBlocks, parseAlphaBlock, parseNumericBlock, parseIsoIec646Block and decodeGeneralPurposeField.
- Changes in Decoded* constructors/semantics or FieldParser.parseFieldsInGeneralPurpose signature/behavior would impact decodeGeneralPurposeField and decodeAllCodes.

5. Summary Judgment:
- Yes — several methods call many other methods and those calls are concentrated mainly in a few provider classes (BitArray and CurrentParsingState, plus Decoded* classes and FieldParser), so this file exhibits symptoms consistent with Intensive Coupling."
DuplicateRemovedScheduler.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- push(Request, Task) — calls several methods (logger.trace, shouldReserved, noNeedToRemoveDuplicate, duplicatedRemover.isDuplicate, logger.debug, pushWhenNoDuplicate).
- Other methods (shouldReserved, noNeedToRemoveDuplicate, getters/setters) call only 1–2 methods each.

2. Calls Concentrated in Few Classes:
- The calls in push are to a small set of provider classes:
  - Request (getUrl, getExtra, getMethod)
  - DuplicateRemover (isDuplicate)
  - Logger (trace, debug)
  - HttpConstant/HttpConstant.Method (equalsIgnoreCase)
- While there are multiple providers, the calls are not overwhelmingly concentrated in a single provider class.

3. Method Complexity:
- push is simple: a single if with boolean OR conditions; no deep nesting or many conditional branches. Other methods are trivial.

4. Potential Fragility:
- Changes in provider interfaces could require edits here. Examples:
  - If DuplicateRemover.isDuplicate signature/semantics changes, push must be updated.
  - If Request.getMethod/getExtra semantics change (or Request API is modified), the duplicate-avoidance logic would need adjustment.
  - Changes to how POST is detected (HttpConstant.Method) would affect noNeedToRemoveDuplicate.
- Logger changes are less likely to force functional changes in this class.

5. Summary Judgment:
- Based on the file, there are no methods exhibiting strong Intensive Coupling. The main method (push) calls several methods but the calls are limited in number and not heavily concentrated in a single external provider class."
SaTokenException.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. The file's methods are simple: constructors (call super) and two static helpers:
  - throwBy(boolean, String) — evaluates flag and may throw.
  - throwByNull(Object, String) — calls SaFoxUtil.isEmpty(...) and may throw.

2. Calls Concentrated in Few Classes:
- Not applicable (no method calling many methods). The only external provider referenced is:
  - cn.dev33.satoken.util.SaFoxUtil (used by throwByNull)
  - java.lang.RuntimeException / super constructors are invoked by the constructors.

3. Method Complexity:
- No. Methods are simple, no deep nesting, no complex conditional branching.

4. Potential Fragility:
- Low. The only minor coupling is to SaFoxUtil.isEmpty — if that utility changes semantics or signature, throwByNull would need updating. Constructors rely on standard RuntimeException behavior (stable).

5. Summary Judgment:
- This file does not contain methods that call many methods concentrated in one or a few classes, so it does not exhibit Intensive Coupling."
LinkedTreeMap.java,
SocketIOChannelInitializer.java,
JobGroupController.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- save(XxlJobGroup xxlJobGroup)
- update(XxlJobGroup xxlJobGroup)
- findRegistryByAppName(String appnameParam)
(also: remove(int id) and pageList(...) call multiple provider methods but fewer than the three above)

2. Calls Concentrated in Few Classes:
- xxlJobGroupDao (save, update, pageList, pageListCount, findAll, remove, load)
- xxlJobRegistryDao (findAll used by findRegistryByAppName and indirectly by update)
- xxlJobInfoDao (pageListCount used by remove)
- XxlJobGroup model (many getter/setter calls within save/update)
- I18nUtil (getString used for many messages)
So most calls are concentrated on the DAOs, the XxlJobGroup model, and I18nUtil.

3. Method Complexity:
- save and update: multiple validation branches, string checks, loops (splitting address lists), and conditional logic (addressType branches) — moderately complex with nested conditionals.
- findRegistryByAppName: loop, conditionals, map/list management — moderate complexity.
- remove: a few conditional checks — low complexity.

4. Potential Fragility:
- If xxlJobGroupDao API or behavior changes (method names, return semantics), save/update/remove/load/pageList would need updates.
- If xxlJobRegistryDao.findAll changes signature/semantics or RegistryConfig constants change, findRegistryByAppName (and update when addressType==0) would break.
- If XxlJobGroup model getters/setters or address format changes, save/update logic and validation would require changes.
- If I18nUtil keys/messages change, the controller’s error messages must be updated.

5. Summary Judgment:
- Yes — this file contains methods (notably save and update, and findRegistryByAppName) that call many methods concentrated in a few provider classes (DAOs, model XxlJobGroup, and I18nUtil), indicating symptoms of Intensive Coupling."
ApiException.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method in this file calls many other methods. The only methods/constructors present are:
  - ApiException(IErrorCode errorCode) — calls errorCode.getMessage() and super(...)
  - ApiException(String message) — calls super(...)
  - ApiException(Throwable cause) — calls super(...)
  - ApiException(String message, Throwable cause) — calls super(...)
  - getErrorCode() — returns the field (no external calls)

2. Calls Concentrated in Few Classes:
- The few external calls that exist are concentrated in:
  - IErrorCode (errorCode.getMessage())
  - java.lang.RuntimeException / java.lang.Throwable (super(...) constructors)

3. Method Complexity:
- Methods are not complex: no deep nesting, no conditional branches, and minimal statements.

4. Potential Fragility:
- If IErrorCode changes (e.g., getMessage() removed or its return type changed), ApiException(IErrorCode) would need updating.
- Changes to RuntimeException/Throwable constructors are unlikely but would affect the constructors here if they changed signatures.

5. Summary Judgment:
- This file does not contain methods that call many methods concentrated in one or a few classes; it does not exhibit Intensive Coupling."
SaOAuth2Template.java,
ReplyMessageProcessorTest.java,
NodeTraversor.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- traverse(NodeVisitor visitor, Node root)
- filter(NodeFilter filter, Node root)
(also: traverse(NodeVisitor, Elements) and filter(NodeFilter, Elements) but those are simple loops that delegate to the above)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in:
  - org.jsoup.nodes.Node (parentNode, hasParent, siblingIndex, childNodeSize, childNode, nextSibling, remove)
  - NodeVisitor / NodeFilter (head, tail)
  - small use of org.jsoup.helper.Validate and Elements/Element for validation/iteration

3. Method Complexity:
- Both traverse(NodeVisitor, Node) and filter(NodeFilter, Node) are moderately complex: they contain nested while loops, multiple conditional branches, assertions, and depth tracking. filter(...) has additional branching based on FilterResult enum values.

4. Potential Fragility:
- Yes. Changes to provider classes would likely require changes here. Examples:
  - If Node changes its parent/child/sibling API (method names, semantics, or indexing behavior) this traversal logic must be updated.
  - If Node.remove() semantics or existence change, the filter removal logic will break.
  - If NodeFilter / NodeVisitor signatures or FilterResult semantics change (e.g., new enum values), the branching in filter(...) would need revision.

5. Summary Judgment:
- Based on the above, this file contains methods that call many methods concentrated in a few classes (primarily Node and NodeVisitor/NodeFilter), so it exhibits symptoms of Intensive Coupling."
DirectoryBrowserSupport.java,
ExcelWriter.java,
MethodInfo.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. This class only contains simple getters and setters that do not call other methods.

2. Calls Concentrated in Few Classes:
- Not applicable (no method calls).

3. Method Complexity:
- Methods are not complex; they have no nesting or conditional branches.

4. Potential Fragility:
- Unlikely. There are no provider classes or external method calls here that would cause cascading changes.

5. Summary Judgment:
- This file does not contain methods exhibiting Intensive Coupling."
ApolloDataSourceFactoryBean.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. Methods in this file (getObject, getObjectType, getters/setters) do not call many other methods. getObject only constructs a new ApolloDataSource.

2. Calls Concentrated in Few Classes:
- Not applicable (no methods calling many methods). The single call in getObject is to the ApolloDataSource constructor (provider class: com.alibaba.csp.sentinel.datasource.apollo.ApolloDataSource).

3. Method Complexity:
- Methods are simple: no deep nesting, loops, or conditional branches.

4. Potential Fragility:
- Low overall, but changes to ApolloDataSource (e.g., constructor signature or required parameters) would require updating getObject. Example: if ApolloDataSource constructor signature changes or Converter type expectation changes, getObject/setter usage must be updated.

5. Summary Judgment:
- This file does not exhibit Intensive Coupling: methods do not call many methods concentrated in one or a few classes."
UmsMemberService.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. This file is an interface (UmsMemberService) containing method declarations only; there are no method bodies calling other methods.

2. Calls Concentrated in Few Classes:
- Not applicable. No method call sites are present in this file. The only referenced types are UmsMember and UserDetails (return/parameter types) and the Transactional annotation.

3. Method Complexity:
- Not applicable. Methods are declarations without bodies, so there is no nesting or conditional branching here.

4. Potential Fragility:
- Minimal in this file. Changes to referenced types (UmsMember, UserDetails) could require updates to implementations or signatures elsewhere, but this interface itself contains no dependent call logic that would break due to provider behavior changes.

5. Summary Judgment:
- This file does not exhibit Intensive Coupling based on local evidence."
BillboardParticleBatch.java,
BrokerController.java,
StringUtils.java,
PacketEncoder.java,
FastByteArrayOutputStream.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- writeTo(OutputStream out)
- toString(Charset charset) (indirectly via toByteArray() and ObjectUtil/CharsetUtil)
- toString(String charsetName) and toString() (delegating to the above)
- toByteArray() (delegates to buffer.toArray())

2. Calls Concentrated in Few Classes:
- FastByteBuffer (buffer): index(), array(i), array(index), offset(), append(...), size(), reset(), toArray() — primary provider
- java.io.OutputStream: write(...)
- cn.hutool.core.util.CharsetUtil: defaultCharset(), charset(...)
- cn.hutool.core.util.ObjectUtil: defaultIfNull(...)

3. Method Complexity:
- writeTo has modest complexity: an early return, a loop, and a try/catch (no deep nesting or many conditional branches).
- Other methods are simple delegates/wrappers and not deeply nested.

4. Potential Fragility:
- Yes. If FastByteBuffer changes its API or behavior (e.g., renaming/changing array(), index(), offset(), append(), toArray()), writeTo, write, size, reset, toByteArray and others would need updates.
- If CharsetUtil/ObjectUtil behaviors or signatures change, toString variants would be affected.
- Example: changing buffer.array(i) semantics or removing offset() would break writeTo and require code changes.

5. Summary Judgment:
- Yes — there are methods (notably writeTo and the toString/toByteArray delegates) that heavily rely on a single provider class (FastByteBuffer), showing symptoms of Intensive Coupling."
BinaryRedisPipeline.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. This interface contains only method declarations (no implementations) except four simple default wrappers:
  - expire(byte[] key, int seconds) -> calls expire(byte[], long)
  - setex(byte[] key, int seconds, byte[] value) -> calls setex(byte[], long, byte[])
  - restore(byte[] key, int ttl, byte[] serializedValue) -> calls restore(byte[], long, byte[])
  - restoreReplace(byte[] key, int ttl, byte[] serializedValue) -> calls restoreReplace(byte[], long, byte[])
  Each of these default methods calls a single other method.

2. Calls Concentrated in Few Classes:
- The few calls present are to other methods of the same interface (i.e., internal forwarding). There is no concentration of many calls to one or a few external provider classes.

3. Method Complexity:
- No. There is no deep nesting or conditional branching. The default methods are single-line forwards; all other methods are abstract declarations without bodies.

4. Potential Fragility:
- Minimal. The only fragility is that the simple default wrappers would need adjustment if their target method signatures changed (e.g., changing expire(byte[], long) would require updating the expire(byte[], int) wrapper). There is no widespread dependency on external provider classes in this file.

5. Summary Judgment:
- This file does not exhibit Intensive Coupling."
LineTransformationOutputStream.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- private void eol()
- public void write(int b)
- public void write(byte[] b, int off, int len)
- public void forceEol()
- protected String trimEOL(String line)
- public void close() (delegates to forceEol)
- Delegating.close() and Delegating.flush()

2. Calls Concentrated in Few Classes:
- Yes — most calls are concentrated on a small set of providers:
  - hudson.util.ByteArrayOutputStream2 (buf.getBuffer(), buf.size(), buf.reset(), buf.write(...), constructor)
  - java.io.OutputStream (out.flush(), out.close(), and inherited OutputStream methods)
  - java.lang.String (length(), charAt(), substring()) used by trimEOL
  - call to the abstract eol(byte[],int) (subclass provider)

3. Method Complexity:
- Overall methods are simple. No deep nesting; only small loops/conditionals:
  - write(byte[],...) uses a simple for-loop delegating to write(int).
  - trimEOL has a simple while loop to trim trailing CR/LF.
  - private eol() has a simple if/else and calls the abstract eol; not deeply nested.

4. Potential Fragility:
- Yes, changes in the small set of provider classes would require changes here:
  - If ByteArrayOutputStream2 changed its API (removed getBuffer()/size()/reset() or changed semantics), eol(), write(), forceEol() and close() would need updates.
  - If OutputStream contract/behavior changed or out were replaced with a different stream interface, Delegating.flush()/close() would be affected.
  - If the abstract eol(byte[],int) contract changed, all subclasses and the call in private eol() would need revision.

5. Summary Judgment:
- Based on this file, methods call a modest number of methods concentrated mainly in ByteArrayOutputStream2 and OutputStream, but the total call volume and complexity are low. This does not exhibit strong symptoms of Intensive Coupling."
RedissonObject.java,
DokanyVolume.java,
AnalysisContext.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. This file is an interface (AnalysisContext) with only method declarations and no method bodies, so there are no methods that call other methods.

2. Calls Concentrated in Few Classes:
- Not applicable. There are no calls in this file. (The interface references a small set of related types: ReadWorkbookHolder, ReadSheetHolder, ReadRowHolder, AnalysisEventProcessor, ReadSheet, Sheet, ExcelTypeEnum, InputStream, AnalysisEventListener, etc., but no method call usage is implemented here.)

3. Method Complexity:
- The declared methods are simple signatures only (no nesting, no conditional branches, no implementation complexity).

4. Potential Fragility:
- Low for this file itself because it contains no implementations. Changes to the referenced types (e.g., renaming ReadRowHolder or changing a method signature in a referenced interface) could force implementing classes to change, but this interface contains no call sites that would break due to internal call structure. Example: if ReadRowHolder type were removed/renamed, methods here would need signature updates.

5. Summary Judgment:
- This file does not contain methods that call many methods concentrated in one or a few classes, so it does not exhibit the Intensive Coupling smell."
ClassLoaderModel.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. The file contains simple getters, setters, a constructor, and getType(); none call many other methods.

2. Calls Concentrated in Few Classes:
- Not applicable — there are essentially no external method calls to concentrate.

3. Method Complexity:
- Methods are simple (field accessors), with no deep nesting or conditional branches.

4. Potential Fragility:
- Low. Changes in referenced types (e.g., ClassLoaderVO, ClassDetailVO, ClassLoaderStat) could cause compile issues or API updates, but these methods do not invoke many provider methods so a single provider change is unlikely to cause widespread impact within this class.

5. Summary Judgment:
- This file does not exhibit Intensive Coupling."
MethodRoadie.java,
StubConnection.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- Constructors: StubConnection() and StubConnection(long)
- refreshConnectionWaitTimeout()
- unwrap(Class<T>)
- prepareStatement(...) overloads (they call new StubPreparedStatement(this))
- isValid(int)

(These are the only methods that call multiple other methods; most other methods are trivial getters/setters or stubs.)

2. Calls Concentrated in Few Classes:
- The calls are not concentrated heavily in a single external provider class. The providers that do appear repeatedly are:
  - java.util.concurrent.ScheduledExecutorService / ScheduledFuture (connectionWaitTimeout, waitTimeoutTask)
  - com.zaxxer.hikari.util.UtilityElf (quietlySleep)
  - com.zaxxer.hikari.mocks.StubPreparedStatement (constructor calls)
  - java.lang.Class (isInstance in unwrap)
  - java.util.concurrent.atomic.AtomicInteger (count)
- Calls are spread across core JDK concurrency/util classes and a small number of local mock classes.

3. Method Complexity:
- Overall methods are simple. refreshConnectionWaitTimeout has a few shallow conditionals (isClosed check, cancel if task present, schedule if waitTimeout > 0) but no deep nesting or many branches.
- Constructors perform a few calls and a try/catch around refreshConnectionWaitTimeout; unwrap has a simple conditional. No method shows deep nesting or complex branching.

4. Potential Fragility:
- Some fragility exists if specific provider APIs change:
  - Changes to StubPreparedStatement's constructor signature would require edits to multiple prepareStatement overloads.
  - Changes in ScheduledExecutorService / ScheduledFuture behavior or API could require changes in refreshConnectionWaitTimeout.
  - Changes to UtilityElf.quietlySleep or its semantics would affect constructors that call it.
- However, these are limited, not widespread; affected code is contained to the few places that reference those providers.

5. Summary Judgment:
- Based on this file, there are no methods that call many methods concentrated in one or a few provider classes to an extent that indicates Intensive Coupling."
ExpandedProductParsedResult.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- equals(Object o) — calls Objects.equals(...) repeatedly (13 comparisons).
- hashCode() — calls Objects.hashCode(...) repeatedly (13 calls).
(Other methods call few or single methods: constructor calls super(...); getDisplayResult() calls String.valueOf(...).)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in java.util.Objects (Objects.equals and Objects.hashCode).
- Minor calls to java.lang.String (String.valueOf) and the superclass ParsedResult (super(...)).

3. Method Complexity:
- equals: simple type check (instanceof) followed by a long chain of && comparisons — no deep nesting, but long and linear.
- hashCode: linear sequence of Objects.hashCode calls combined with XORs — not deeply nested, but long.
- Overall not deeply nested, but relatively long/verbose.

4. Potential Fragility:
- Changes to java.util.Objects behavior (Objects.equals/Objects.hashCode) would affect both methods.
- Adding/removing fields (e.g., new product attributes or removing uncommonAIs) requires updates to equals and hashCode in tandem — risk of inconsistency/bugs if one is missed.
- Changing the type/semantics of fields (e.g., uncommonAIs Map) can require changes in these methods.

5. Summary Judgment:
- Yes. equals(...) and hashCode() call many methods that are concentrated in the single provider class java.util.Objects, which matches the symptom of Intensive Coupling."
SaFoxUtil.java,
Stage.java,
Finance.java,
AdminBrokerProcessor.java,
PreparedStatementHandler.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- instantiateStatement(Connection)
- update(Statement)
- query(Statement, ResultHandler)
- queryCursor(Statement)
(instantiateStatement and update are the most call-heavy.)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated on a few provider classes:
  - Connection (prepareStatement(...))
  - PreparedStatement (execute(), addBatch(), getUpdateCount())
  - MappedStatement (getKeyGenerator(), getKeyColumns(), getResultSetType())
  - KeyGenerator (processAfter(...))
  - BoundSql (getSql(), getParameterObject())
  - resultSetHandler / parameterHandler (handleResultSets, handleCursorResultSets, setParameters)

3. Method Complexity:
- instantiateStatement: moderate complexity — nested if/else branches with a nested condition (key generator vs result set type).
- update: simple linear sequence, low nesting.
- query / queryCursor / parameterize / batch: simple, low complexity.

4. Potential Fragility:
- Yes. Changes in any of the provider classes would likely require edits here or cause ripple effects. Examples:
  - If KeyGenerator.processAfter signature/contract changes, update(...) must change.
  - If Connection.prepareStatement overloads or ResultSetType API change, instantiateStatement(...) must be updated.
  - If ResultSetHandler or ParameterHandler APIs change, query/queryCursor/parameterize must be updated.
  - If BoundSql structure or methods change, multiple methods (instantiateStatement, update) break.

5. Summary Judgment:
- This file does contain methods (notably instantiateStatement and update) that call many methods concentrated in a small set of provider classes, indicating symptoms of Intensive Coupling."
SmsFlashPromotionProductRelationServiceImpl.java,
PrefixPluginLogger.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- PrefixPluginLogger(ExtendedLogger logger, String name, String prefix) — calls several other methods/constructors (super(...), markers.get(...), new MarkerManager.Log4jMarker(...), markers.put(...), new String(...)).
- Other methods call few methods: markersSize() calls markers.size(); prefix() calls marker.getName(); logMessage(...) calls super.logMessage(...).

2. Calls Concentrated in Few Classes:
- Yes — the constructor’s calls are concentrated in a small set of provider classes:
  - java.util.WeakHashMap (markers.get, markers.put, markers.size)
  - org.apache.logging.log4j.MarkerManager.Log4jMarker (constructor)
  - org.apache.logging.log4j.Marker (getName)
  - org.apache.logging.log4j.spi.ExtendedLogger/ExtendedLoggerWrapper (super, super.logMessage)
  - java.lang.String (new String(...))

3. Method Complexity:
- The constructor has modest complexity: one synchronized block and a single if/else branch (shallow nesting).
- Other methods are simple, single-call wrappers.

4. Potential Fragility:
- Changes in any of the small set of provider classes would likely require edits:
  - If MarkerManager.Log4jMarker’s constructor or API changed, the constructor must be updated.
  - If Marker.getName() signature/semantics changed, prefix() would break.
  - If ExtendedLoggerWrapper.logMessage signature changed, logMessage(...) must be updated.
  - If the static markers map usage semantics (key handling) changed, the constructor’s use of new String(actualPrefix) / markers.put/get might need adjustment.

5. Summary Judgment:
- Overall: No intensive coupling detected — only the constructor aggregates a handful of calls, and those calls are limited in number and involve a small set of logging-related classes rather than a large, concentrated dependency surface."
BitMatrix.java,
JobTriggerPoolHelper.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- start() — constructs ThreadPoolExecutor instances and related objects.
- addTrigger(...) — selects a pool, calls execute(...), invokes XxlJobTrigger.trigger(...), interacts with jobTimeoutCountMap/AtomicInteger, uses System.currentTimeMillis(), and logger.
- stop() — calls shutdownNow() on pools and logger.info(...).
(Other methods toStart(), toStop(), trigger(...) are thin delegations.)

2. Calls Concentrated in Few Classes:
- No. Calls are spread across several provider classes rather than concentrated in one: ThreadPoolExecutor/Executor (execute, shutdownNow), XxlJobAdminConfig (getAdminConfig().getTriggerPool... ), XxlJobTrigger (trigger), ConcurrentMap/ConcurrentHashMap and AtomicInteger (get, putIfAbsent, incrementAndGet, clear), LinkedBlockingQueue, Thread/ThreadFactory, System, and Logger.

3. Method Complexity:
- addTrigger(...) is moderately complex: contains conditional selection of pool, an inner Runnable with try-catch-finally, and nested ifs for timeout-count logic. start() and stop() are simple/straightforward.

4. Potential Fragility:
- Some fragility exists if key providers change:
  - If XxlJobTrigger.trigger(...) signature or behavior changes, addTrigger(...) must be updated.
  - If XxlJobAdminConfig API or configuration keys change, start() must be updated.
  - Changes to concurrency classes or expected semantics of jobTimeoutCountMap/AtomicInteger usage could require adjustments.
  These would be localized to the methods that directly call those providers (mainly start() and addTrigger()).

5. Summary Judgment:
- Based on the file, there are methods that call several other methods, but those calls are distributed across multiple utility/provider classes rather than concentrated in one or a few providers. Therefore this file does not exhibit clear Intensive Coupling."
MigrationRunController.java,
Internet.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- url()
- image()
- image(Integer width, Integer height, Boolean gray, String text)
- password(int minimumLength, int maximumLength, boolean includeUppercase, boolean includeSpecial, boolean includeDigit)
- macAddress(String prefix)
- privateIpV4Address()
- publicIpV4Address()
- ipV6Address()
- domainWord()
- emailAddress(...) overloads
(also slug(), userAgent(UserAgent) call several helpers but fewer external targets)

2. Calls Concentrated in Few Classes:
- Primarily calls concentrated on the Faker instance and its collaborators (faker.fakeValuesService(), faker.random(), faker.lorem(), faker.name(), faker.bool()) — i.e., the Faker API / service classes.
- Also concentrated use of FakerIDN and Apache StringUtils (and some JDK utilities: Arrays, String, UUID).

3. Method Complexity:
- Several methods have moderate complexity: loops and/or conditionals or switches:
  - password(...) has loops and conditional branches.
  - macAddress(String) has a loop and conditional logic.
  - privateIpV4Address() has switch logic and multiple random selections.
  - publicIpV4Address() has a while loop to avoid private ranges.
  - ipV6Address() builds with a loop.
- Complexity is moderate (not deeply nested), but multiple branches and iterative logic are present.

4. Potential Fragility:
- Yes. Many methods delegate to Faker and its subservices; if Faker's API, fakeValuesService keys, or RandomService behavior change, these methods would likely need updates. Examples:
  - emailAddress/url/domainWord/avatar depend on faker.fakeValuesService().resolve and FakerIDN — changes to value keys or IDN handling would break them.
  - password, ipV4/ipV6, macAddress rely on faker.random() and faker.lorem() behavior; changes to RandomService or lorem.characters would affect generation and may require method edits.
  - image() relies on string formats and fakeValuesService keys; change in expected keys or formats requires updates.

5. Summary Judgment:
- Yes — this file contains multiple methods that call many methods concentrated in the Faker ecosystem (and a few utility classes), which is symptomatic of Intensive Coupling."
AllMembersSupplier.java,
AwtCodec.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- write(JSONSerializer, Object, Object, Type, int)
- deserialze(DefaultJSONParser, Type, Object)
- parseFont(DefaultJSONParser)
- parseColor(DefaultJSONParser)
- parseRectangle(DefaultJSONParser)
- parsePoint(DefaultJSONParser, Object)
- parseRef(DefaultJSONParser)
- writeClassName(SerializeWriter, Class<?>, char) (smaller, but calls several out methods)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in:
  - JSONLexer (lexer.* calls: token(), nextToken(), nextTokenWithColon(), intValue(), floatValue(), stringVal(), etc.)
  - DefaultJSONParser / parser (getContext(), setContext(), acceptType(), addResolveTask(), popContext(), setResolveStatus(), accept(), getLexer())
  - SerializeWriter (out.* calls: writeFieldValue(), write(), writeNull(), isEnabled(), writeFieldName(), writeString())
  - Secondary concentration: java.awt classes for getters/constructors (Font, Color, Point, Rectangle)

3. Method Complexity:
- parseFont/parseColor/parseRectangle/parsePoint: moderate complexity — infinite loop pattern with many conditional branches, repeated token checks and nested if/else chains.
- deserialze/write: conditional chains (instanceof/type switches) but shallower nesting.
- parseRef: sequence of parser/lexer interactions (several calls, less branching).

4. Potential Fragility:
- Yes. Changes to JSONLexer or DefaultJSONParser APIs/behavior (token constants, nextToken semantics, nextTokenWithColon, intValue/floatValue/stringVal behavior, context/resolve APIs) would likely require changes in most parse* methods and deserialze.
- Changes to SerializeWriter (writeFieldValue or write behavior, feature flags) would require updates to write/writeClassName.
- Example: if JSONLexer.nextTokenWithColon changes semantics or is removed, parseFont/parseColor/parseRectangle/parsePoint and parseRef must be updated; if SerializeWriter.writeFieldValue signature/formatting changes, write() must change.

5. Summary Judgment:
- Yes — this file contains multiple methods that call many methods concentrated primarily in JSONLexer, DefaultJSONParser and SerializeWriter (plus a few awt classes). These are symptoms of Intensive Coupling."
OrderController.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- order(...) — calls many external methods (logging, RootContext.getXID, calculate, invokerAccountService, jdbcTemplate.update via PreparedStatementCreator, keyHolder.getKey, random.nextBoolean, etc.).
- invokerAccountService(...) — constructs HttpHeaders, MultiValueMap, HttpEntity and calls restTemplate.postForEntity.
- anonymous PreparedStatementCreator.createPreparedStatement(...) — calls Connection.prepareStatement and multiple PreparedStatement.setObject.

2. Calls Concentrated in Few Classes:
- order(...) — calls are concentrated around Spring JDBC and JDBC classes (JdbcTemplate, PreparedStatement, GeneratedKeyHolder/KeyHolder) and to some extent logging/RootContext and Random. The JDBC/JdbcTemplate/KeyHolder cluster is the main provider group.
- invokerAccountService(...) — calls are concentrated in Spring Web/HTTP classes (RestTemplate, HttpHeaders, MediaType, LinkedMultiValueMap, HttpEntity).
- createPreparedStatement(...) — concentrated in java.sql.Connection / java.sql.PreparedStatement.

3. Method Complexity:
- order(...) — moderate complexity: sequential steps, an anonymous inner class, and a couple of conditional branches (throwing an exception randomly and checking update result). Not deeply nested but multi-responsibility.
- invokerAccountService(...) — low complexity: linear sequence of HTTP-related calls.
- createPreparedStatement(...) — low complexity: straightforward parameter setting.

4. Potential Fragility:
- Changes to JdbcTemplate/SQL schema (e.g., column names, generated key behavior, or update semantics) would likely require changes in order(...) and the PreparedStatementCreator.
- Changes to RestTemplate or the HTTP API (endpoint, parameter names, content type) would require changes in invokerAccountService(...).
- Changes to key-holder behavior or getKey() representation would affect how order.id is set.
- If RootContext.getXID or logging conventions change, order(...) logging/XID handling would be affected.
- Overall, the methods are tightly coupled to the JDBC and Spring Web provider APIs, so provider changes would cause localized but non-trivial modifications.

5. Summary Judgment:
- Yes — this file contains methods (notably order(...) and invokerAccountService(...)) that call many methods concentrated in a few provider classes (JdbcTemplate/JDBC cluster and RestTemplate/Spring Web cluster), which are symptoms of Intensive Coupling."
XxlJobInfoDao.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. This file is a DAO interface with only method signatures (no implementations). Methods present: pageList, pageListCount, save, loadById, update, delete, getJobsByGroup, findAllCount, scheduleJobQuery, scheduleUpdate.

2. Calls Concentrated in Few Classes:
- Not applicable (no method bodies/calls). The file only references the XxlJobInfo model and MyBatis annotations (org.apache.ibatis.annotations).

3. Method Complexity:
- Methods are not complex: no bodies, no nesting, no conditional branches in this file.

4. Potential Fragility:
- Low within this file. The main fragility would be if the XxlJobInfo model or the MyBatis mappings change (e.g., field renames or mapping SQL), which could require updates to DAO implementations or mappings, but the interface signatures here are minimal and would likely remain stable.

5. Summary Judgment:
- This file does not contain methods that call many methods concentrated in one or a few classes; therefore it does not show symptoms of Intensive Coupling."
ConnectionPool.java,
LinkedHashMultimap.java,
PropertyElf.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- setProperty(...)
- setTargetFromProperties(...)
- getProperty(...)
- getPropertyNames(...)
(also copyProperties(...) calls several small methods but fewer in count)

2. Calls Concentrated in Few Classes:
- setProperty: calls are concentrated around reflection and type-conversion/provider classes: java.lang.reflect.Method (invoke, getParameterTypes, getName), java.lang.Class (forName, getDeclaredConstructor, newInstance, getMethod), primitive wrapper parsers (Integer, Long, Short, Boolean), and org.slf4j.Logger/LoggerFactory. Also uses java.util.List/Stream for method lookup.
- setTargetFromProperties: concentrated on HikariConfig (addDataSourceProperty) and reflection/Clazz APIs (target.getClass(), getMethods()).
- getProperty: concentrated on java.lang.Class and java.lang.reflect.Method (getMethod, invoke) with fallback to another reflective call.
- getPropertyNames: concentrated on reflection (Class.getMethods(), Class.getMethod(...)) and java.util.regex.Matcher.

3. Method Complexity:
- setProperty is relatively complex: multiple conditional branches (type checks for int/long/short/boolean/String/other) and nested try-catch inside the ""other"" branch. Moderate branching depth.
- getProperty has nested try-catch fallback (two reflective attempts).
- getPropertyNames contains a loop with conditionals and exception handling (try/catch per method).
- setTargetFromProperties is simpler but uses a lambda and conditional branching for HikariConfig vs general properties.

4. Potential Fragility:
- Changes to HikariConfig.addDataSourceProperty (signature/name/behavior) would directly affect setTargetFromProperties.
- Changes to bean setter signatures/names on target classes (or removal of default constructors) would break setProperty/getProperty and require updates.
- Changes in reflection behavior, Class.forName semantics, or security restrictions would impact multiple methods (setProperty, getProperty, getPropertyNames).
- Changes to parsing/format expectations for numeric/boolean types would require changes in setProperty (Integer.parseInt, Long.parseLong, etc.).

5. Summary Judgment:
Yes — this file contains methods (notably setProperty and getProperty/setTargetFromProperties) that call many methods and concentrate calls on a few provider areas (reflection/Class/Method APIs, HikariConfig, and primitive wrapper parsers), which are signs consistent with Intensive Coupling."
PendingTransactionsDialog.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- createDialogArea(Composite)
- loadContexts(boolean)
- showDialog(Shell)
(also endTransaction(boolean) calls several handlers but is small)

2. Calls Concentrated in Few Classes:
- createDialogArea: many calls to UI-related providers (UIUtils, SWT widget methods, DBeaverIcons), plus QMUtils and TransactionInfoDialog methods (logViewer, createTransactionLogPanel).
- loadContexts: many calls concentrated in data/provider classes (DataSourceRegistry, DBPDataSourceContainer, DBSInstance, DBCExecutionContext) and QMUtils; plus a UIUtils.asyncExec call.
- showDialog: concentrated in UI/IDE entry points (UIUtils, DBWorkbench) and the local PendingTransactionsDialog constructor.

3. Method Complexity:
- createDialogArea: moderate complexity — multiple UI construction steps and nested anonymous SelectionAdapter with conditional logic.
- loadContexts: moderate-to-high complexity — nested loops (data sources → instances → contexts) and several conditional branches/continues.
- showDialog: low complexity.

4. Potential Fragility:
- Yes. Changes to a provider class would likely require updates here. Examples:
  - If UIUtils APIs (packColumns, createCheckbox, asyncExec, getActiveWorkbenchWindow, etc.) change, createDialogArea and showDialog must be updated.
  - If DataSourceRegistry or DBPDataSourceContainer / DBSInstance methods or return types change (e.g., getAllDataSources, isConnected, getAvailableInstances, getAllContexts), loadContexts would break.
  - If QMUtils.isTransactionActive / getTransactionState signatures change, both loadContexts and the selection listener in createDialogArea would be affected.

5. Summary Judgment:
- Yes. createDialogArea and loadContexts exhibit symptoms of Intensive Coupling: they call many methods that are largely concentrated in a few provider classes (UIUtils/UI framework and data-source-related classes), creating potential fragility."
JedisClusterTest.java,
RandomGenerator.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. Methods here call very few methods:
  - generate(): calls RandomUtil.randomString(...)
  - verify(): calls StrUtil.isNotBlank(...) and StrUtil.equalsIgnoreCase(...)

2. Calls Concentrated in Few Classes:
- Yes, the small number of calls are concentrated in two utility/provider classes:
  - cn.hutool.core.util.RandomUtil
  - cn.hutool.core.util.StrUtil

3. Method Complexity:
- No. Methods are simple:
  - generate(): single delegation call.
  - verify(): one conditional and one equality check (shallow nesting).

4. Potential Fragility:
- Low but present: if provider APIs change (e.g., RandomUtil.randomString signature/behavior or StrUtil methods), these methods would need updates.
  - Example: RandomUtil.randomString(...) signature removed/changed → generate() must be modified.
  - Example: StrUtil.equalsIgnoreCase(...) behavior altered or removed → verify() behavior would change or require replacement.

5. Summary Judgment:
- Based on the code in this file, there are no methods that call many methods concentrated in one or a few classes; thus it does not exhibit Intensive Coupling."
RouterNanoHTTPD.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- UriResource.process(...)
- StaticPageHandler.get(...)
- UriRouter.process(...)
- GeneralHandler.get(...)

2. Calls Concentrated in Few Classes:
- UriResource.process: calls are concentrated on the handler/responder classes (handler.newInstance(), UriResponder.get/post/put/delete/other) and on IHTTPSession (session.getMethod(), session.getUri()), plus Response factory methods.
- StaticPageHandler.get: calls concentrated on java.io.File API (File constructors, isDirectory(), exists(), isFile(), getParentFile(), getName()), UriResource (getUri(), initParameter()), and Response factory methods / Error404UriHandler.
- UriRouter.process: calls concentrated on the routePrioritizer and UriResource classes (routePrioritizer.getPrioritizedRoutes(), UriResource.match(...), UriResource.process(...)).
- GeneralHandler.get: calls concentrated on IHTTPSession (session.getUri(), session.getParms()) and Response factory / StringBuilder.

3. Method Complexity:
- UriResource.process: moderate complexity (try/catch, instanceof check, switch on session.getMethod()).
- StaticPageHandler.get: moderate-to-high complexity (string normalization, loop over path parts, directory/file selection, nested conditionals, try/catch).
- UriRouter.process: low-to-moderate complexity (loop over routes, matching).
- GeneralHandler.get: low-to-moderate complexity (map iteration and conditional branch for empty vs non-empty).

4. Potential Fragility:
- UriResource.process is fragile to changes in provider classes: e.g., if handler classes no longer have no-arg constructors or UriResponder method signatures change, this method must change; changes to IHTTPSession method names/semantics would require updates here; changes to Response factory methods would also affect callers.
- StaticPageHandler.get would break or need changes if File layout/semantics or the expected initParameter index/type change, or if getMimeTypeForFile / Response behavior changes.
- UriRouter.process would be affected by changes to the routePrioritizer API or UriResource.match/process behavior.
- GeneralHandler.get would be affected if IHTTPSession.getParms() or session.getUri() signatures/behavior change.

5. Summary Judgment:
- Yes — there are methods (notably UriResource.process, StaticPageHandler.get and UriRouter.process) that call many methods and those calls are concentrated in a few provider classes (handler/UriResponder classes, IHTTPSession, routePrioritizer/UriResource, File/IO/Response), which are symptoms consistent with Intensive Coupling."
JavassistProxyFactory.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- generateProxyClass(...)
- modifyProxyFactory()
- main(String... args)
(secondary: isDefaultMethod(...), getAllInterfaces(...), toJavaClass(...) call several APIs but are smaller)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in the Javassist API and related reflection/proxy classes, e.g.:
  - javassist.ClassPool, javassist.CtClass, javassist.CtMethod, javassist.CtNewMethod, javassist.bytecode.ClassFile, javassist.LoaderClassPath
  - com.zaxxer.hikari.pool.ProxyFactory and the Proxy* classes (ProxyConnection, ProxyStatement, etc.)
  - java.lang.Class / reflection APIs (Class.forName, Array.newInstance)
  - java.sql interfaces are used but the heavy call volume is on the Javassist/Proxy/Reflection classes

3. Method Complexity:
- generateProxyClass is relatively complex: nested loops over interfaces and methods, multiple conditionals, string transformations, cloning/injection of methods, and several API calls per iteration.
- modifyProxyFactory has a switch over method names (moderate complexity).
- main orchestrates multiple generation calls (moderate).
- Helper methods (isDefaultMethod, getAllInterfaces, toJavaClass) have modest complexity and recursion.

4. Potential Fragility:
- Yes. Changes to the provider classes/APIs would likely require changes here. Examples:
  - If Javassist CtClass/CtMethod/CtNewMethod APIs (method names, signatures, exception behavior, or how to set method bodies) change, generateProxyClass and modifyProxyFactory will need updates.
  - If com.zaxxer.hikari.pool.Proxy* class names or ProxyFactory method names change, the string-based generation and switch logic would break and require edits.
  - If reflection/exception behavior changes (e.g., different handling of default methods or SQLException detection), isDefaultMethod and isThrowsSqlException logic would be affected.

5. Summary Judgment:
- Yes — this file contains methods (notably generateProxyClass and modifyProxyFactory) that call many methods and concentrate those calls in a small set of provider classes (Javassist API, proxy classes, and reflection), indicating symptoms of Intensive Coupling."
ClusterConnectionManager.java,
RequestLimiter.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method in this file calls a large number of distinct methods. The methods with the most calls (but still few) are:
  - getSum() — calls data.currentWindow(), data.values(), and LongAdder.sum() in a loop.
  - getQps() — calls getSum() and data.getIntervalInSecond().
  - tryPass() — calls canPass() and add(1).
  - increment() and add(int) — each chains data.currentWindow().value().increment()/add(x).
  - Constructor — calls AssertUtil.isTrue(...) and new UnaryLeapArray(...).

2. Calls Concentrated in Few Classes:
- Yes. Most calls target a small set of provider classes:
  - LeapArray / UnaryLeapArray (data, currentWindow(), values(), getIntervalInSecond()).
  - java.util.concurrent.atomic.LongAdder (value().increment(), value().add(), sum()).
  - AssertUtil used in constructor.

3. Method Complexity:
- Methods are simple: shallow call chains, one loop in getSum(), and only simple conditionals in canPass() and tryPass(). No deep nesting or many conditional branches.

4. Potential Fragility:
- Changes in the provider classes would likely require updates here. Examples:
  - If LeapArray API changes (method names or semantics for currentWindow(), values(), getIntervalInSecond()), RequestLimiter must change.
  - If LongAdder API changes (remove/rename add()/sum()/increment()), RequestLimiter must change.
  - If semantics of windowing/interval change in LeapArray, getQps()/getSum() behavior and thresholds would be affected.

5. Summary Judgment:
- Based on the file, there are no methods that call many methods across many providers; calls are few and concentrated mainly on LeapArray and LongAdder but the overall call count per method is low. Therefore this file does not exhibit strong symptoms of Intensive Coupling."
MockNamingService.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. All overridden methods in this MockNamingService are empty or return null and do not call other methods.

2. Calls Concentrated in Few Classes:
- Not applicable (no calls). If there were calls, they would typically target Nacos-related classes (e.g., NamingService, Instance, EventListener, ServiceInfo), but the methods here do not invoke them.

3. Method Complexity:
- Methods are not complex: no nesting, no conditionals, and minimal/no logic.

4. Potential Fragility:
- Low for this file as written: since methods contain no calls, changes in provider classes would not cause direct breakage. However, changes to the NamingService interface (method signatures) would require updates in this class.

5. Summary Judgment:
- This file does not contain methods that call many methods concentrated in one or a few classes, so it does not exhibit Intensive Coupling."
MethodVisitor.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. This file is an interface (MethodVisitor) and contains only method declarations without implementations, so there are no methods that call other methods in this file.

2. Calls Concentrated in Few Classes:
- Not applicable (no call sites). The interface does reference a few types in signatures (Label, Type, Object/String), but there are no method call concentrations to analyze.

3. Method Complexity:
- The declared methods are simple signatures (no bodies), so there is no nesting or conditional complexity in this file.

4. Potential Fragility:
- Minimal within this file: changing provider classes (e.g., Label or Type) could require updating signatures elsewhere, but would not cause changes in method implementations here (there are none). Example: renaming or removing the Label type would force updates to any code that implements this interface, but not to the interface's internal logic (since it has none).

5. Summary Judgment:
- Based on this file alone, there are no methods that call many methods concentrated in one or a few classes; therefore this file does not exhibit the Intensive Coupling smell."
FlowControllerV1.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- apiQueryMachineRules
- checkEntityInternal
- apiAddFlowRule
- apiUpdateFlowRule
- apiDeleteFlowRule
- publishRules

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in:
  - repository (InMemoryRuleRepositoryAdapter) — findById, save, saveAll, delete, findAllByMachine
  - sentinelApiClient (SentinelApiClient) — fetchFlowRuleOfMachine, setFlowRuleOfMachineAsync
  - FlowRuleEntity (getters/setters, isClusterMode, getClusterConfig)
  - utility/provider classes used repeatedly: StringUtil, Result, MachineInfo, Logger

3. Method Complexity:
- apiUpdateFlowRule: high complexity — many conditional branches and validations.
- checkEntityInternal: many sequential validation checks (numerous conditionals, but shallow nesting).
- apiAddFlowRule, apiDeleteFlowRule, apiQueryMachineRules: moderate complexity (validation + try/catch + async publish).
- publishRules: simple.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require updates here. Examples:
  - If repository methods change signature/semantics (e.g., save returns different type, findAllByMachine renamed), apiAddFlowRule, apiUpdateFlowRule, apiDeleteFlowRule, apiQueryMachineRules and publishRules must be updated.
  - If sentinelApiClient.setFlowRuleOfMachineAsync changes behavior/contract, publishRules and all callers (add/update/delete) must adapt (including error/timeout handling).
  - If FlowRuleEntity’s fields/getters/setters or validation rules change, checkEntityInternal and apiUpdateFlowRule would require changes.

5. Summary Judgment:
- Yes — this file contains methods that call many methods concentrated in a few provider classes (notably repository and sentinelApiClient), indicating symptoms of Intensive Coupling."
DiagnosedStreamCorruptionException.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- toString() — calls multiple methods (super.toString(), StringBuilder.append x several, HexDump.toHex(...), new StringWriter(), new PrintWriter(...), diagnoseFailure.printStackTrace(p), p.flush(), w.toString().trim().replace(...)).
- Constructor DiagnosedStreamCorruptionException(...) — calls initCause(cause) (single call).
- Getters — no significant calls.

2. Calls Concentrated in Few Classes:
- The toString() calls are mostly to a small set of provider classes:
  - java.lang.StringBuilder (append)
  - hudson.cli.HexDump (toHex)
  - java.io.StringWriter (toString)
  - java.io.PrintWriter (ctor, flush)
  - java.lang.Exception (diagnoseFailure.printStackTrace)
  These are a few classes (standard library classes + HexDump), not a large spread across many different application classes.

3. Method Complexity:
- toString() is not highly complex: one conditional (if diagnoseFailure != null) and no deep nesting or many branches.

4. Potential Fragility:
- Changes in the small set of provider classes could require changes here. Examples:
  - If HexDump.toHex(...) is renamed/removed or its signature/format changes, toString() must be updated.
  - If Exception.printStackTrace behavior/availability changed for diagnoseFailure, or PrintWriter usage semantics changed, this method would need adjustment.
  - However, most calls target stable JDK classes, so everyday fragility is limited.

5. Summary Judgment:
- Based on the above, this file does not exhibit strong Intensive Coupling: toString() calls several methods but they are confined to a few stable, mostly standard-library providers (plus HexDump), and the method is simple with low structural complexity."
XMLConfigBuilder.java,
Lexeme.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- equals
- hashCode
- compareTo
- append
- toString

2. Calls Concentrated in Few Classes:
- Yes. Most calls are to the same Lexeme class (other.getOffset(), other.getBegin(), other.getLength(), l.getBeginPosition(), etc.) and to java.lang.StringBuffer / java.lang.String (toString uses multiple append calls). So provider classes: Lexeme (this class) and java.lang.StringBuffer / String.

3. Method Complexity:
- No. These methods are simple and shallow: a few conditionals/if-else blocks or a switch, but no deep nesting or large numbers of branches.

4. Potential Fragility:
- Moderate. If Lexeme's internal APIs (getBegin/getLength/getBeginPosition/getEndPosition/getLexemeTypeString) changed semantics or signatures, several methods here (equals, hashCode, compareTo, append, toString) would need updates. Changes to StringBuffer/String usage would affect only toString.

5. Summary Judgment:
- The file contains several methods that call multiple methods, mostly concentrated on the Lexeme class, but the call counts are low and the methods are simple. This does not present a clear case of Intensive Coupling."
DBeaverCore.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- initialize()
- dispose()
- getTempFolder(DBRProgressMonitor monitor, String name)
- createInstance() (moderate number of calls)

2. Calls Concentrated in Few Classes:
- initialize(): many calls target DBeaverWorkspace (constructor, initializeProjects), QMUtils/QMControllerImpl/QMLogFileWriter (init, new, registerMetaListener), DBeaverActivator (getStateLocation(), getPreferences()), SecurityProviderUtils.
- dispose(): concentrated calls to DBeaverWorkspace (dispose, save), QMControllerImpl / QMController (unregisterMetaListener, dispose), QMLogFileWriter (dispose), DataSourceProviderRegistry, ContentUtils.
- getTempFolder(): calls are mostly to java.nio.file.Files and JRE/System APIs, and utility classes CommonUtils/StandardConstants; not concentrated in a single custom provider.
- createInstance(): a few calls to Platform/Bundle and then initialize() — less concentrated but delegates to initialize().

3. Method Complexity:
- initialize(): linear sequence of initialization calls with one simple conditional (preference check) — moderate complexity.
- dispose(): more complex — several conditional branches, try/catch around workspace.save, multiple cleanup steps and null checks — moderate-to-high complexity.
- getTempFolder(): contains nested try/catch and nested conditional fallbacks for different temp locations — moderate complexity.

4. Potential Fragility:
- Changes to DBeaverWorkspace API (e.g., initializeProjects(), dispose(), save(...)) would require changes in initialize(), dispose(), and getExternalFileManager().
- Changes in QMControllerImpl/QMController or QMLogFileWriter APIs (register/unregisterMetaListener, dispose) would force adaptions in initialize() and dispose().
- Changes to DBeaverActivator methods (getStateLocation(), getPreferences(), getConfigurationFile) would ripple to initialize(), getPreferenceStore(), getConfigurationFile().
- Changing SecurityProviderUtils registration behavior would affect initialize() conditional path.
- Example: if QMControllerImpl.rename unregisterMetaListener to removeMetaListener, dispose() and initialize() would need updating; if workspace.save signature changes, dispose() would require edits.

5. Summary Judgment:
- Yes — initialize() and dispose() (especially) show concentrated calls to a few provider classes (DBeaverWorkspace, QMControllerImpl/QMLogFileWriter, DBeaverActivator, DataSourceProviderRegistry), indicating symptoms of Intensive Coupling."
AztecCode.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. All methods are simple getters/setters and do not call other methods.

2. Calls Concentrated in Few Classes:
- Not applicable (no method-call sites). The class references BitMatrix only as a field type but does not invoke its methods.

3. Method Complexity:
- Methods are not complex: no deep nesting, no conditional branches, just field accessors.

4. Potential Fragility:
- Low. Only potential impact is if the BitMatrix type changes (e.g., renamed, moved, or requires wrapping), which could affect getMatrix/setMatrix signatures or usage sites, but current methods do not depend on BitMatrix behavior.

5. Summary Judgment:
- This file does not contain methods that call many methods concentrated in one or a few classes; it does not exhibit Intensive Coupling."
EntryConfig.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method calls a large number of other methods. The most-call-heavy method is the full constructor
  EntryConfig(String resourceName, int resourceType, EntryType entryType, int acquireCount, Object[] args, ContextConfig contextConfig)
  which calls a few AssertUtil validation methods. toString() calls Arrays.toString(...) plus implicit toString on contextConfig.

2. Calls Concentrated in Few Classes:
- Yes, the small set of external calls are concentrated in a few classes:
  - com.alibaba.csp.sentinel.util.AssertUtil (static validation calls)
  - java.util.Arrays (Arrays.toString)
  - com.alibaba.csp.sentinel.ResourceTypeConstants (used as a constant)
  - ContextConfig (stored and implicitly used via toString)

3. Method Complexity:
- Methods are simple: constructors mostly delegate (this(...)) and perform a few assertions; no deep nesting or many conditional branches.

4. Potential Fragility:
- Low to moderate. If AssertUtil's API or semantics change (method names, signatures, or thrown exceptions), the constructor would need updates. Changes to ContextConfig's API are unlikely to force changes here (it is only stored and its toString may be used). Changing ResourceTypeConstants value is not likely to break callers of this class.

5. Summary Judgment:
- Based on the file, there are no methods that call many methods concentrated in one or a few classes to a degree that indicates Intensive Coupling."
ScriptProcessorBuilder.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method calls a large number of other methods. The only methods that invoke external APIs are:
  - scriptFromFile(...)
  - scriptFromClassPathFile(...)
  - build()

2. Calls Concentrated in Few Classes:
- Yes, the external calls that do exist are concentrated in a few provider classes/packages:
  - java.io (FileInputStream, InputStream)
  - org.apache.commons.io.IOUtils
  - java.lang.Class / java.lang.ClassLoader (getClassLoader, getResourceAsStream)
  - ScriptProcessor (constructor)

3. Method Complexity:
- Methods are simple: single try-catch blocks, no deep nesting, no multiple conditional branches.

4. Potential Fragility:
- Some fragility exists in small spots: e.g., changes to IOUtils.toString, to the ScriptProcessor constructor signature, or to resource-loading semantics (getResourceAsStream) would require updates here. But these are limited, not widespread.

5. Summary Judgment:
- The file does not contain methods that call many methods concentrated in one or a few classes to the extent that indicates Intensive Coupling."
MapTypeAdapterFactory.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- Adapter.read(JsonReader in)
- Adapter.write(JsonWriter out, Map<K, V> map)
- create(Gson gson, TypeToken<T> typeToken) (moderate number of calls)
- Adapter constructor and getKeyAdapter(...) call several methods as well
- keyToString(JsonElement keyElement) (fewer calls, but branching)

2. Calls Concentrated in Few Classes:
- Adapter.read: most calls target JsonReader (in.peek(), in.nextNull(), in.beginArray(), in.hasNext(), in.endArray(), in.beginObject(), in.endObject()) and the TypeAdapter instances (keyTypeAdapter.read, valueTypeAdapter.read), plus Map.put and JsonReaderInternalAccess.
- Adapter.write: most calls target JsonWriter (out.nullValue, out.beginObject, out.name, out.endObject, out.beginArray, out.endArray), the TypeAdapter instances (valueTypeAdapter.write, keyTypeAdapter.toJsonTree), and JsonElement/Streams (keyElement.isJsonArray/isJsonObject, Streams.write).
- create: calls are concentrated in $Gson$Types, Gson (getAdapter), and ConstructorConstructor (get).
- Overall provider classes concentrated: JsonReader, JsonWriter, TypeAdapter (key/value wrappers), JsonElement, Streams, $Gson$Types / Gson / ConstructorConstructor, and Map/ObjectConstructor.

3. Method Complexity:
- Adapter.read: moderate complexity — branching on JsonToken (NULL / BEGIN_ARRAY / BEGIN_OBJECT), loops, repeated similar logic, and exception throwing on duplicates.
- Adapter.write: higher complexity — top-level branch on complexMapKeySerialization, loops to build lists, detection of complex keys, nested loops to write arrays or objects, and conditional branches for key formatting.
- create and keyToString: lower complexity (create has straightforward sequence of calls; keyToString has several branches for primitive types).

4. Potential Fragility:
- Yes. Changes in the provider classes would likely require changes here or cause breakage. Examples:
  - If JsonReader/JsonWriter API or behavior changes (method names, token handling, or ordering expectations), Adapter.read/write would need updates.
  - If TypeAdapter.read/write or TypeAdapterRuntimeTypeWrapper behavior changes, both read and write flows break.
  - If JsonElement or Streams APIs change (e.g., toJsonTree, isJsonObject/isJsonArray, Streams.write), Adapter.write needs changes.
  - If ConstructorConstructor/ObjectConstructor.construct or $Gson$Types utilities change, create(...) and Adapter.read’s map construction would be affected.
  - Changes to JsonReaderInternalAccess.promoteNameToValue would impact Adapter.read’s object-key handling.

5. Summary Judgment:
- Yes. The file contains methods (notably Adapter.read and Adapter.write) that call many methods concentrated in a few provider classes (JsonReader/JsonWriter, TypeAdapter, JsonElement/Streams, and Gson/$Gson$Types/ConstructorConstructor), which are symptoms consistent with Intensive Coupling."
AttributeNameHistoWalker.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method calls a large number of other methods. The largest is visit(IMetaMember) which calls a small number of methods:
  - mm.getCompiledAttribute(attributeName) or mm.getQueuedAttribute(attributeName)
  - Long.valueOf(attrValue)
  - histo.addValue(val)

2. Calls Concentrated in Few Classes:
- Yes, the calls in visit are concentrated in a few providers:
  - IMetaMember (mm.getCompiledAttribute / mm.getQueuedAttribute)
  - java.lang.Long (Long.valueOf)
  - the histo object (histo.addValue) — member from AbstractHistoVisitable / this class hierarchy

3. Method Complexity:
- Methods are simple. visit has a single if/else to choose which mm method to call and a null check; no deep nesting or many conditional branches.

4. Potential Fragility:
- Changes to IMetaMember API (renaming/removing getCompiledAttribute/getQueuedAttribute or changing return format) would require edits here.
- Changes to the histo API (rename/behavior of addValue) or expectations about attribute string format (non-numeric values) could also require adjustments.
- However, impact scope is small because only a few calls are involved.

5. Summary Judgment:
- The file does not exhibit strong Intensive Coupling: methods call only a few methods concentrated in a couple of provider classes, but the call count and method complexity are low, so it does not indicate problematic intensive coupling."
PageModelExtractor.java,
TreeTypeAdapter.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- read(JsonReader) — calls Streams.parse(in), JsonElement.isJsonNull(), deserializer.deserialize(...) or delegate().read(in).
- write(JsonWriter, T) — calls serializer.serialize(...), Streams.write(...), out.nullValue(), or delegate().write(out, value).
- delegate() — calls gson.getDelegateAdapter(skipPast, typeToken).
- SingleTypeFactory.create(...) — calls exactType.equals(...), exactType.getType(), type.getRawType(), hierarchyType.isAssignableFrom(...), and constructs new TreeTypeAdapter.
- SingleTypeFactory constructor — performs instanceof checks and $Gson$Preconditions.checkArgument(...).
- GsonContextImpl.serialize/serialize(Object, Type)/deserialize — call gson.toJsonTree(...) and gson.fromJson(...).

2. Calls Concentrated in Few Classes:
- Yes, most calls target a small set of provider classes/APIs:
  - Gson (gson.getDelegateAdapter, gson.toJsonTree, gson.fromJson)
  - JsonSerializer / JsonDeserializer (serialize, deserialize)
  - Streams (parse, write)
  - JsonReader / JsonWriter (used as parameters and methods like nullValue())
  - TypeToken / Class (equals, getType, getRawType, isAssignableFrom)
These are the primary providers involved.

3. Method Complexity:
- Methods are simple overall: shallow conditionals (null checks, presence checks) and straightforward boolean logic. No deep nesting or extensive branching.

4. Potential Fragility:
- Changes to the small set of provider APIs would affect this class:
  - If Gson.getDelegateAdapter signature/behavior changed, delegate() and thus read/write would be affected.
  - If JsonSerializer/JsonDeserializer serialize/deserialize contracts change, read/write would need updates.
  - If Streams.parse/write change, read/write would be impacted.
  - If TypeToken/Class matching semantics changed, SingleTypeFactory.create logic may need revision.

5. Summary Judgment:
- While several methods call other methods, the number of calls is modest and the calls are chiefly to a few framework providers (Gson, serializer/deserializer, Streams). The methods are not deeply complex. Overall, this file does not exhibit strong symptoms of Intensive Coupling."
Spider.java,
RandomService.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None of the methods call many distinct methods. Notes:
  - hex(int) repeatedly calls nextInt(16) in a loop (repeated internal call, not many different providers).
  - Other methods delegate to a single Random method each (nextInt, nextLong, nextDouble, nextBoolean).

2. Calls Concentrated in Few Classes:
- Yes, the small number of external calls are concentrated in java.util.Random (the Random instance) and internal calls to RandomService methods (hex -> hex(int), hex(int) -> nextInt).
- Provider classes: java.util.Random and the same RandomService class.

3. Method Complexity:
- Mostly simple/delegating methods.
- nextLong(long n) is the most complex: it has an input validation, a do-while loop and bit arithmetic.
- hex(int) has a loop and a simple conditional per iteration.
- No deep nesting or large branching structures.

4. Potential Fragility:
- Changes to java.util.Random (API signature changes or semantic changes to nextInt/nextLong/nextDouble/nextBoolean) would require updating this class.
- Examples: if Random.nextInt(int) signature/behavior changed, nextInt(min,max), hex(int) would be affected; if Random.nextLong() changed semantics, the nextLong(long n) implementation (which relies on bit operations from nextLong()) could produce incorrect results and require changes.

5. Summary Judgment:
- No, this file does not contain methods that call many methods concentrated in one or a few classes in a way that indicates Intensive Coupling."
RuleContainer.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method in this file calls an unusually large number of other methods. The closest are:
  - getSortedEntries() — iterates collections, constructs RuleEntry instances, calls orderValues.get(...), and Collections.sort(...).
  - apply(FrameworkMethod, Description, Object, Statement) — checks emptiness, calls getSortedEntries(), and invokes apply(...) on rule instances in a loop.

2. Calls Concentrated in Few Classes:
- The calls are not heavily concentrated in a single external provider class. The main providers are:
  - java.util collections classes (List, Collections, IdentityHashMap)
  - org.junit.rules.TestRule
  - org.junit.rules.MethodRule
  - the nested RuleEntry class (local)
- The use is split between core collection utilities and the two rule interfaces, not concentrated on many methods of one single provider.

3. Method Complexity:
- Methods are simple: shallow loops and a small conditional in apply(...). No deep nesting or many conditional branches.

4. Potential Fragility:
- Some local fragility exists: if TestRule or MethodRule change their apply(...) signatures/semantics, apply(...) here must change.
- If ordering behavior (RuleEntry or orderValues map) changes, getSortedEntries() and RuleEntry constructor may need updates.
- Changes in java.util collection APIs are unlikely; impact is limited to the few places they are used.

5. Summary Judgment:
- Based on the above, this file does not exhibit methods that call many methods concentrated in one or a few classes indicative of Intensive Coupling."
LocalCacheListener.java,
TransactionMQProducer.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None of the methods call a large number of other methods. The methods that make multiple calls (but still few) are:
  - start()
  - shutdown()
  - sendMessageInTransaction(Message, LocalTransactionExecuter, Object)
  - sendMessageInTransaction(Message, Object)

2. Calls Concentrated in Few Classes:
- The calls that do exist are concentrated in a small set of providers:
  - defaultMQProducerImpl (calls: initTransactionEnv, destroyTransactionEnv, sendMessageInTransaction)
  - Message (calls: getTopic, setTopic)
  - NamespaceUtil (wrapNamespace)
  - super (DefaultMQProducer.start()/shutdown(), getNamespace() inherited)
- So calls are limited and focused on these few collaborators.

3. Method Complexity:
- Methods are simple: short, shallow control flow, only basic null checks and direct calls. No deep nesting or many conditional branches.

4. Potential Fragility:
- Changes in the provider APIs could require edits here. Examples:
  - If defaultMQProducerImpl.rename/remove/change signatures of initTransactionEnv/destroyTransactionEnv/sendMessageInTransaction, these methods would need updating.
  - If NamespaceUtil.wrapNamespace or Message.setTopic/getTopic semantics change, callers here must adapt.
  - However, impact is local and limited because each method only invokes a few provider methods.

5. Summary Judgment:
- Based on the above, this file does not exhibit Intensive Coupling: calls are few and the methods are simple, even though they interact with a small set of provider classes."
PlainPermissionManager.java,
JSONTokener.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- nextValue()
- toJSONArray()
- nextString(char)
- skipTo(char)
- next() and next(int) (they call many other internal methods in loops)

2. Calls Concentrated in Few Classes:
- java.io.Reader (reader.read(), reader.mark(), reader.reset()) — used by next(), skipTo(), etc.
- JSONObject and JSONArray (constructors called from nextValue(); JSONArray used heavily in toJSONArray())
- JSONArray/JSONObject instance API (jsonArray.add(...) used in toJSONArray())
- InternalJSONUtil (stringToValue(...) called by nextValue())
- JSONNull (JSONNull.NULL referenced in toJSONArray())
(plus a few standard helpers: StrUtil, Integer.parseInt)

3. Method Complexity:
- nextString(char): moderately complex — nested switch inside a loop with multiple escape-handling branches.
- nextValue(): moderate complexity — initial switch, then a loop to accumulate unquoted text with backtracking.
- toJSONArray(): moderate complexity — loop with branching and nested switch to manage separators and array items.
- skipTo(char): some complexity due to try/catch and mark/reset logic.
- next()/next(int): loops and state updates (index/line/character) but simpler control flow.

4. Potential Fragility:
- Changes to JSONObject/JSONArray constructors or their APIs would force edits in nextValue() and toJSONArray(); e.g., if JSONObject(JSONTokener, JSONConfig) signature changes, nextValue() must be updated.
- If Reader behavior or available methods (mark/reset/read) or IOException handling changes, next(), skipTo() and methods that rely on mark/reset would be affected.
- If InternalJSONUtil.stringToValue(...) changes return types/semantics, nextValue() behavior and callers would need adaptation.
- If JSONArray.add(...) semantics change (e.g., different exceptions or overloads), toJSONArray() would be impacted.

5. Summary Judgment:
Yes — several parsing methods (notably nextValue() and toJSONArray(), plus nextString() and skipTo()) call many methods and their external calls are concentrated primarily in a few provider classes (Reader, JSONObject/JSONArray, InternalJSONUtil), indicating symptoms consistent with Intensive Coupling."
AndroidMusic.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- dispose
- play
- pause
- stop
- setPosition
- setPan
- onCompletion

2. Calls Concentrated in Few Classes:
- Mostly concentrated on android.media.MediaPlayer (player).
- Also calls concentrated in com.badlogic.gdx.Gdx (app.log, app.postRunnable) and com.badlogic.gdx.backends.android.AndroidAudio (audio.notifyMusicDisposed).
- Minor use of java.lang.Math for pan calculations.

3. Method Complexity:
- Methods are not deeply nested; complexity is moderate.
- play and setPosition contain multiple try/catch blocks and conditionals; pause/stop have simple conditionals; onCompletion posts a Runnable (a small additional nesting).

4. Potential Fragility:
- Yes. Changes to MediaPlayer API/behavior (prepare, start, stop, seekTo, isPlaying, getCurrentPosition, getDuration, setVolume, setLooping, release) would require updates across many methods (e.g., play, setPosition, stop, pause, getPosition, getDuration, setVolume/setPan).
- Changes to Gdx.app (postRunnable or logging) would affect onCompletion and dispose logging behavior.
- Changes to AndroidAudio.notifyMusicDisposed would require updating dispose handling.

5. Summary Judgment:
- This file shows symptoms of Intensive Coupling: several methods make many calls concentrated primarily in MediaPlayer (with some dependence on Gdx.app and AndroidAudio), creating a concentrated dependency surface."
WriteWorkbookHolder.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- WriteWorkbookHolder(WriteWorkbook writeWorkbook) (constructor)
- copyTemplate()

2. Calls Concentrated in Few Classes:
- Constructor: heavy use of WriteWorkbook (many getters), also uses java.io.File / FileOutputStream and ExcelTypeEnum.
- copyTemplate(): concentrated calls to WriteWorkbook (template getters), com.alibaba.excel.util.FileUtils, com.alibaba.excel.util.IoUtils, and java.io.InputStream/ByteArrayInputStream.

3. Method Complexity:
- Constructor: moderate complexity — multiple conditionals, try/catch, and decision logic for excelType and stream selection (not deeply nested but multi-branch).
- copyTemplate(): moderate complexity — conditional branches and a try/finally for stream closing.

4. Potential Fragility:
- Changes to WriteWorkbook (renamed/removed getters, changed template access or close semantics) would require updates to the constructor and copyTemplate (e.g., getTemplateInputStream/getTemplateFile or getOutputStream changes).
- Changes to FileUtils or IoUtils APIs or behavior (readFileToByteArray / toByteArray) would break copyTemplate.
- Changes to ExcelTypeEnum values or file-extension conventions would affect the excelType detection logic and could require edits here.

5. Summary Judgment:
- Yes — the constructor and copyTemplate show symptoms of Intensive Coupling: they call many methods concentrated mainly on WriteWorkbook and a few utility/IO classes, creating potential fragility."
DefaultDateTypeAdapter.java,
AckSchedulerKey.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. The file contains constructor, getIndex(), hashCode(), and equals(), none of which call many other methods.

2. Calls Concentrated in Few Classes:
- N/A for ""many"" calls. The few calls that exist are to the superclass (SchedulerKey) and to java.lang.Object methods (super.hashCode(), super.equals(obj), getClass()).

3. Method Complexity:
- No. Methods are simple: shallow control flow. equals() has a few straightforward checks (identity, super.equals, class check, field compare) but no deep nesting or many branches.

4. Potential Fragility:
- Low. The main dependency is on SchedulerKey and Object semantics; if SchedulerKey changes its equals()/hashCode() contract or internal identity fields, this class may need updates (e.g., different equality logic or additional fields to compare).

5. Summary Judgment:
- No intensive coupling detected: methods do not call many methods concentrated in one or a few provider classes."
TableView.java,
HttpClientDownloader.java,
CN_QuantifierSegmenter.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- processCount(AnalyzeContext)
- analyze(AnalyzeContext) (delegates to many context methods)
- needCountScan(AnalyzeContext) (several context/lexeme calls)
(secondary: processCNumber calls several context/utility methods; outputNumLexeme constructs Lexeme and calls context.addLexeme)

2. Calls Concentrated in Few Classes:
- AnalyzeContext (many calls: getCurrentCharType, getCursor, addLexeme, isBufferConsumed, lockBuffer/unlockBuffer, getSegmentBuff, getBufferOffset, getOrgLexemes, etc.)
- Dictionary / Hit (Dictionary.getSingleton().matchWithHit, matchInQuantifierDict; Hit.isMatch/isPrefix/isUnmatch)
- Lexeme (construction and TYPE_* constants)
- CharacterUtil (CHAR_CHINESE)
- countHits (java.util.List / Hit operations)
Most calls in processCount are concentrated in AnalyzeContext and Dictionary/Hit (plus Lexeme).

3. Method Complexity:
- processCount: moderate complexity — loop over hit array, multiple nested if/else branches, conditionals and list mutations; non-trivial control flow.
- analyze: simple delegation + lock/unlock logic.
- needCountScan: some conditional nesting (peeking last lexeme, type checks).
- processCNumber: simple conditional branching.

4. Potential Fragility:
- Changes to AnalyzeContext API (method names, semantics, buffer/offset behavior, org-lexemes structure) would require updating these methods (e.g., if addLexeme signature or getSegmentBuff changes).
- Changes to Dictionary or Hit (signature/behavior of matchWithHit, matchInQuantifierDict, or Hit.isPrefix/isMatch semantics) would force edits in processCount.
- Changes to Lexeme constructor or TYPE_* constants would require edits where Lexeme instances are created.
Example: renaming Dictionary.matchWithHit or altering Hit matching semantics would break processCount and require code changes.

5. Summary Judgment:
- Yes — processCount (and to a lesser extent analyze and needCountScan) call many methods concentrated in a small set of provider classes (AnalyzeContext, Dictionary/Hit, Lexeme), exhibiting symptoms of Intensive Coupling."
CompareObjectsSettings.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- loadFrom(DBPSettingsSection dialogSettings)
- saveTo(DBPSettingsSection dialogSettings)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated on DBPSettingsSection (dialogSettings.get, getBoolean, put).
- Also uses the local OutputType enum (OutputType.valueOf, outputType.name()).

3. Method Complexity:
- loadFrom: moderate complexity — a flat sequence of repeated if-checks (no deep nesting, no loops).
- saveTo: low complexity — a straight sequence of put calls.
- Overall not deeply nested or highly branched.

4. Potential Fragility:
- Changes to DBPSettingsSection API (method signatures, behavior of get/getBoolean/put) would require updates here.
- Changing the stored key names (e.g., ""skipSystem"", ""outputType"") or their types would break loadFrom/saveTo behavior.
- Changing OutputType enum values or names could cause valueOf/name mismatches or runtime exceptions (IllegalArgumentException) when loading.
- Example: if getBoolean is removed/renamed or starts returning different types, loadFrom must be updated; if the ""outputType"" stored string no longer matches an OutputType name, valueOf will fail.

5. Summary Judgment:
- Yes — loadFrom and saveTo exhibit concentrated calls to DBPSettingsSection (and use the OutputType enum), indicating symptoms of Intensive Coupling."
InlineSizeHistoVisitable.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- InlineSizeHistoVisitable(IReadOnlyJITDataModel, long) constructor (many ignoreTags.add(...) calls)
- visit(IMetaMember)
- processParseTag(Tag, IParseDictionary)
- visitTag(Tag, IParseDictionary) (delegates to processParseTag)

2. Calls Concentrated in Few Classes:
- Constructor: concentrated calls to the ignoreTags Set (inherited from AbstractHistoVisitable).
- processParseTag: most calls are on Tag instances (child.getName(), child.getAttributes(), child.getChildren(), klassTag.getAttributes()), plus a few concentrated calls to IParseDictionary (getKlass) and Map/Set operations.
- visit(IMetaMember): concentrated on IMetaMember (isCompiled, getCompilations) and CompilationUtil.visitParseTagsOfCompilation.
- visitTag: concentrated to processParseTag (same providers as above).

3. Method Complexity:
- processParseTag: moderately complex — loops over children, switch with multiple cases, recursion (processParseTag called for nested TAG_PARSE and TAG_PHASE), conditional checks and Map lookups.
- visit(IMetaMember): simple loop with try/catch.
- Constructor and visitTag: simple/delegating.

4. Potential Fragility:
- Changes to Tag API (method names, attribute keys, structure of children) would require edits in processParseTag (e.g., getName/getAttributes/getChildren, attribute keys ATTR_NAME/ATTR_BYTES).
- Changes to IParseDictionary (getKlass) or Tag attribute layout would cascade to processParseTag.
- Changes to the ignoreTags Set handling or tag constant values would require updating the constructor and related logic.
- Changes to IMetaMember or CompilationUtil behavior would affect visit(IMetaMember).

5. Summary Judgment:
- Yes — there are methods (notably processParseTag and the constructor) that call many methods concentrated in a few provider types (Tag, IParseDictionary, ignoreTags/Set, IMetaMember/CompilationUtil), which are symptoms consistent with Intensive Coupling."
CodahaleHealthChecker.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- registerHealthChecks(...)
- ConnectivityHealthCheck.check()
- Connection99Percent.check()

2. Calls Concentrated in Few Classes:
- registerHealthChecks: most calls target HikariConfig (getHealthCheckProperties, getMetricRegistry, getConnectionTimeout, getPoolName), MetricRegistry (getTimers, static name), HealthCheckRegistry (register), java.util.Properties (getProperty), and java.util.SortedMap/Timer (accessing timers).
- ConnectivityHealthCheck.check: concentrated on HikariPool (getConnection) and java.sql.Connection (try-with-resources) and SQLException handling.
- Connection99Percent.check: concentrated on com.codahale.metrics.Timer (getSnapshot), Snapshot (get99thPercentile), java.util.concurrent.TimeUnit, and HealthCheck.Result (healthy/unhealthy).

3. Method Complexity:
- registerHealthChecks: modest complexity — several sequential calls and two nested condition checks (if metricRegistry != null && expected99thPercentile > 0) and (if !timers.isEmpty()). Not deeply nested but multiple branches.
- ConnectivityHealthCheck.check: simple, single try/catch with resource acquisition.
- Connection99Percent.check: simple computation and a single conditional return (ternary-like).

4. Potential Fragility:
- Changes to HikariConfig API (renaming/behavior change of getHealthCheckProperties, getMetricRegistry, getConnectionTimeout, getPoolName) would require updates in registerHealthChecks.
- Changes to MetricRegistry API (signature/behavior of getTimers, MetricRegistry.name, Timer access) would force changes to registerHealthChecks and Connection99Percent.
- Changes to HikariPool.getConnection(timeout) behavior or signature would affect ConnectivityHealthCheck.check.
- Changes to Timer/Snapshot API (getSnapshot, get99thPercentile) or TimeUnit handling would impact Connection99Percent.check.
- Changes to HealthCheckRegistry.register signature would impact both health-check registrations in registerHealthChecks.

5. Summary Judgment:
- Yes — registerHealthChecks (and the two inner check methods) exhibit concentrated calls on a small set of provider classes (HikariConfig, MetricRegistry, HealthCheckRegistry, HikariPool/Timer), so the file shows symptoms consistent with Intensive Coupling."
ClassicPluginStrategy.java,
ClientHead.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- bindChannel
- send(Packet) / send(Packet, Transport)
- sendPackets
- schedulePingTimeout
- cancelPingTimeout
- onChannelDisconnect
- disconnect
- upgradeCurrentTransport
- isChannelOpen
- removeNamespaceClient

2. Calls Concentrated in Few Classes:
- TransportState (access via channels map) — getChannel, update, getPacketsQueue, setPacketsQueue
- io.netty.channel.Channel — writeAndFlush, isActive, attr(...).get, equals
- ClientsBox — add, remove, get
- NamespaceClient / namespaceClients map — put/remove/get, iteration and client.onDisconnect
- CancelableScheduler / SchedulerKey — schedule, cancel
- DisconnectableHub — onDisconnect
(These methods repeatedly call APIs on the small set above rather than many unrelated classes.)

3. Method Complexity:
- Mostly moderate complexity: several methods have loops or conditionals (onChannelDisconnect iterates and invokes client.onDisconnect; upgradeCurrentTransport loops entries and breaks; send(Packet,Transport) has conditional return; schedulePingTimeout creates a runnable). No very deep nesting, but multiple branches and iterations exist.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require edits here. Examples:
  - If TransportState API changes (method names or queue handling), send, sendPackets, upgradeCurrentTransport, bindChannel would need updates.
  - If Channel write/flush/attr behavior or signatures change, sendPackets and send(...) need changes.
  - If ClientsBox contract changes (add/remove/get semantics), bindChannel, releasePollingChannel, onChannelDisconnect, upgradeCurrentTransport would be impacted.
  - If CancelableScheduler scheduling/cancel semantics change, schedulePingTimeout / cancelPingTimeout would be affected.

5. Summary Judgment:
- Yes — several methods call many operations concentrated on a few provider classes (TransportState/Channel/ClientsBox/NamespaceClient/CancelableScheduler). This matches symptoms of Intensive Coupling."
Closer.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- close()
- rethrow(Throwable) and its overloads (they call a few helper methods)
- SuppressingSuppressor.suppress()
- addSuppressedMethodOrNull()

2. Calls Concentrated in Few Classes:
- close(): calls primarily on Deque/ArrayDeque (isEmpty, removeFirst), Closeable.close(), Suppressor.suppress(), and Throwables.propagateIfPossible().
- rethrow(...) overloads: calls mainly Throwables.propagateIfPossible(...) and checkNotNull(...).
- SuppressingSuppressor.suppress(): calls Method.invoke(...) and falls back to LoggingSuppressor.INSTANCE.suppress(...).
- addSuppressedMethodOrNull(): calls Throwable.class.getMethod(...).

3. Method Complexity:
- close(): moderate complexity — a loop with try/catch and conditional suppression logic.
- rethrow(...) overloads: low complexity — simple sequence of checks and propagation calls.
- SuppressingSuppressor.suppress(): low-to-moderate complexity — small conditional and try/catch.
- addSuppressedMethodOrNull(): simple.

4. Potential Fragility:
- Changes to Suppressor (interface or its implementations) would affect close() and SuppressingSuppressor.suppress() (e.g., different suppression API or semantics).
- Changes to Throwables.propagateIfPossible(...) signatures/behavior would require updating the rethrow(...) methods.
- Changes to Closeable.close() behavior or Deque APIs would affect close() loop.
- Changes to reflection APIs (Throwable.getMethod / Method.invoke) would affect addSuppressedMethodOrNull() / SuppressingSuppressor.suppress().

5. Summary Judgment:
- There are a few methods that call several other methods, but the calls are not overwhelmingly concentrated on a single external provider class; they are spread across a few small collaborators (Deque, Closeable, Suppressor, Throwables, reflection APIs). Therefore, this file does not exhibit strong symptoms of Intensive Coupling."
Tokeniser.java,
HazelcastPubSubStore.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- publish
- subscribe
- unsubscribe

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in Hazelcast-related classes and a few local collections:
  - HazelcastInstance (hazelcastPub, hazelcastSub)
  - ITopic (getTopic(...), publish(...), addMessageListener(...), removeMessageListener(...))
  - Message / PubSubMessage (message.getMessageObject(), msg.setNodeId(), msg.getNodeId())
  - Local concurrency utilities: ConcurrentMap / PlatformDependent, Queue / ConcurrentLinkedQueue
  - PubSubListener (listener.onMessage(...))

3. Method Complexity:
- subscribe: moderate complexity — anonymous inner MessageListener, one conditional (nodeId check), and concurrent map putIfAbsent pattern; shallow nesting only.
- unsubscribe: simple loop over registration ids; low complexity.
- publish: simple, low complexity.

4. Potential Fragility:
- Yes. Changes in provider classes would likely force changes here. Examples:
  - Hazelcast API changes (e.g., getTopic signature, addMessageListener return type/behavior, removeMessageListener contract) would break subscribe/unsubscribe/publish.
  - Changes to Message/PubSubMessage (different accessor names or payload wrapping) would require updates to message.getMessageObject(), msg.setNodeId(), msg.getNodeId().
  - Changes in PubSubListener.onMessage signature or expected types would require adapting the anonymous listener.
  - Concurrency/map behavior changes (e.g., different regId lifecycle) could require logic changes and null checks (unsubscribe assumes regIds non-null).

5. Summary Judgment:
- Yes — the file contains methods (notably subscribe and unsubscribe, and to a lesser extent publish) that call many methods concentrated in a small set of provider classes (Hazelcast types and related message classes), which are symptoms of Intensive Coupling."
ContentType.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method calls a large number of other methods. The constructor and getDetailFromContentHeader perform a few calls (pattern.matcher, matcher.find, matcher.group, equalsIgnoreCase, and calls to the helper getDetailFromContentHeader), but not an excessive number.

2. Calls Concentrated in Few Classes:
- The small set of calls that do exist are concentrated in standard classes: java.util.regex.Pattern / java.util.regex.Matcher and java.lang.String operations (equalsIgnoreCase, concatenation). No large concentration on a single custom provider class.

3. Method Complexity:
- Methods are simple: shallow control flow, no deep nesting, few conditional branches. getDetailFromContentHeader is a single matcher-based retrieval; constructor has simple null checks and conditional assignment.

4. Potential Fragility:
- Changes to the regex/Matcher API or to the expected header format could require adjustments to the regexes or matcher usage (e.g., group indices). Example: if the header format changes, the constructor and getDetailFromContentHeader would need updates. Standard String APIs are stable and unlikely to cause fragility.

5. Summary Judgment:
- Based on the file, there are no methods that call many methods concentrated in one or a few classes indicative of Intensive Coupling."
ResultLoaderMap.java,
HikariConfig.java,
Configuration.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- Configuration(Environment, Settings) constructor (calls settings.get multiple times and Dictionary.initial).
- getConfigInPluginDir() (chained calls: AnalysisIkPlugin.class.getProtectionDomain().getCodeSource().getLocation().getPath(), new File(...).getParent(), PathUtils.get(...).toAbsolutePath()).

2. Calls Concentrated in Few Classes:
- Constructor: calls concentrated in Settings and Dictionary.
- getConfigInPluginDir(): calls involve AnalysisIkPlugin (class literal), ProtectionDomain/CodeSource/URL chain, java.io.File, and org.elasticsearch.core.PathUtils — a small set but across both plugin and JDK utility classes.

3. Method Complexity:
- No deep nesting or many conditional branches. Methods are short and straightforward.

4. Potential Fragility:
- Yes, changes in provider APIs would require updates: e.g., if Settings.get keys or signatures change or Dictionary.initial changes, the constructor must be updated; if AnalysisIkPlugin location retrieval or PathUtils APIs change, getConfigInPluginDir() would break or need adaptation.

5. Summary Judgment:
- Based on the above, this file does not exhibit strong Intensive Coupling: the few multi-call methods invoke a small number of provider classes and are simple in structure, so I judge NO for Intensive Coupling."
VCardResultParser.java,
InterceptorProcessor.java,
HandleCallbackParam.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. The file only contains simple getters, setters, constructors, and toString(). None of these call many other methods.

2. Calls Concentrated in Few Classes:
- Not applicable. There are no method call clusters to specific provider classes in this file.

3. Method Complexity:
- The methods are simple and not complex: no deep nesting, no loops, and only straightforward assignments and string concatenation in toString().

4. Potential Fragility:
- Low. Changes in other classes are unlikely to require changes here (beyond very broad runtime/library changes). Example: modifying unrelated provider classes would not affect these POJO getters/setters or toString().

5. Summary Judgment:
- This file does not contain methods that call many methods concentrated in one or a few classes, so it does not exhibit Intensive Coupling."
SimpleWebServer.java,
AbstractWriteHolder.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- AbstractWriteHolder(WriteBasicParameter writeBasicParameter, AbstractWriteHolder parentAbstractWriteHolder, Boolean convertAllFiled) (constructor)
- initAnnotationConfig(List<WriteHandler> handlerList, WriteBasicParameter writeBasicParameter)
- sortAndClearUpHandler(List<WriteHandler> handlerList)
- compatibleOldCode(WriteBasicParameter writeBasicParameter) (moderate)
- compatibleOldCodeCreateRowCellStyleStrategy(...) and compatibleOldCodeCreateHeadColumnWidthStyleStrategy(...) (smaller, but call several providers)

2. Calls Concentrated in Few Classes:
- Yes. The heavy callers are concentrated around:
  - WriteBasicParameter and parent AbstractWriteHolder (many getter/setter/flag calls in the constructor)
  - WriteHandler-related types and utilities (WriteHandler instances, Order, NotRepeatExecutor, and the specific subtypes: WorkbookWriteHandler, SheetWriteHandler, RowWriteHandler, CellWriteHandler) used in sortAndClearUpHandler and handler initialization
  - Loader/utility classes: DefaultWriteHandlerLoader, DefaultConverterLoader, ConverterKeyBuild, ExcelWriteHeadProperty
  - Head and its property classes (Head, LoopMergeProperty, RowHeightProperty, OnceAbsoluteMergeProperty) used by initAnnotationConfig
  These constitute the small set of provider classes most calls target.

3. Method Complexity:
- Yes. The constructor is complex with many conditional branches and repeated conditional logic. 
- sortAndClearUpHandler has multiple loops, branching (instanceof checks), and classification logic.
- initAnnotationConfig contains loops over headMap and several conditionals invoking multiple helper methods.

4. Potential Fragility:
- Yes. Changes in those provider classes would likely require edits here. Examples:
  - If WriteBasicParameter changes its getters/flags or structure, the constructor logic must change.
  - If WriteHandler/Order/NotRepeatExecutor semantics or method names change, sortAndClearUpHandler’s ordering/deduplication/classification would break.
  - If DefaultConverterLoader or ConverterKeyBuild change keys or return types, converter map initialization in the constructor would need updates.
  - Changes to ExcelWriteHeadProperty or Head property APIs would impact initAnnotationConfig and related deal* methods.

5. Summary Judgment:
- Based on the above, this file contains methods (notably the constructor and sortAndClearUpHandler) that call many methods concentrated in a small set of provider classes — indicating symptoms of Intensive Coupling."
TestProxies.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- testProxyCreation
- testStatementProxy
- testStatementExceptions
- testOtherExceptions

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated on:
  - java.sql.Connection (the conn proxy)
  - java.sql.PreparedStatement / Statement (stmt)
  - com.zaxxer.hikari.HikariDataSource / HikariConfig (ds and config creation)
  - com.zaxxer.hikari.mocks.StubConnection and com.zaxxer.hikari.mocks.StubStatement (unwrap / test mocks)

3. Method Complexity:
- The methods are not deeply nested; complexity is largely from many repeated try-catch blocks and many sequential calls (many branches via repeated exception checks) rather than deep control-flow nesting.

4. Potential Fragility:
- Yes. Changes to the provider classes would likely require changes here or cause failures. Examples:
  - Changes to Connection/PreparedStatement method behavior, signatures, or exception semantics would break many assertions and try/catch expectations.
  - Changes to unwrap() semantics or the mock classes (StubConnection/StubStatement) would break many tests that depend on unwrap and throwException behavior.
  - Changes to HikariDataSource/HikariConfig lifecycle or how connections are proxied would affect multiple test methods.

5. Summary Judgment:
- Based on the above, this file contains methods that call many methods concentrated in a few classes (primarily Connection/statement proxies and related mocks) — i.e., symptoms of Intensive Coupling."
JITDataModel.java,
BytecodeInstruction.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- toStringNonSwitch(int maxOffset)
- toStringSwitch(int maxOffset, int line)
- toStringComplete()
- toString(int maxOffset, int line) (delegates and calls opcode.isSwitch())
- getLabelLines() (calls opcode.isSwitch(), parameter casting and getSize())
(also hashCode() and equals(Object) call several accessors/hashCode/equals, but these are typical)

2. Calls Concentrated in Few Classes:
Yes — most calls are concentrated in a few provider classes:
- Opcode (isSwitch(), getMnemonic())
- IBytecodeParam / BCParamSwitch (parameter.toString(), BCParamSwitch.getSize(), BCParamSwitch.toString(...))
- org.adoptopenjdk.jitwatch.util.StringUtil (alignRight(), alignLeft())
- java.lang.StringBuilder / java.lang.String (append, substring, indexOf) and logger (logger.error) — standard libs but still providers of many calls

3. Method Complexity:
- toStringSwitch: moderate complexity — multiple branches (line == 0, line == maxLines-1, else) and instanceof + casting logic.
- toStringNonSwitch: moderate complexity — conditional blocks, loop over parameters, string-building and trimming logic.
- getCommentWithMemberPrefixStripped: some nesting and special-case handling for invokedynamic (indexOf, substring).
Overall these methods have branching, loops and special-case handling (switch/table handling).

4. Potential Fragility:
Yes — changes in a provider class would likely require updates here or cause incorrect behavior. Examples:
- If Opcode API changes (rename/remove isSwitch() or getMnemonic()), toString*/getLabelLines()/toString would break.
- If BCParamSwitch or IBytecodeParam change their toString() or getSize() semantics/signature, switch formatting and label lines would break.
- If StringUtil.alignLeft/alignRight signatures or behavior change, formatting output will be affected and calls must be updated.
- If comment prefix constants or comment format for invokedynamic change, getCommentWithMemberPrefixStripped logic may produce wrong results.

5. Summary Judgment:
Yes — this file contains methods (notably the toString* family and getLabelLines) that call many methods and concentrate those calls in a small set of provider classes (Opcode, parameter classes, StringUtil), which are symptoms consistent with Intensive Coupling."
BatchResult.java,"NO, I did not found Intensive Coupling

1. Methods Calling Many Methods:
- None. Methods are simple accessors, constructors, and a single mutator (getMappedStatement, getSql, getParameterObject, getParameterObjects, getUpdateCounts, setUpdateCounts, addParameterObject).

2. Calls Concentrated in Few Classes:
- N/A (no methods that call many other methods). The few calls present are to java.util.List (parameterObjects.add, parameterObjects.get) and the constructors/store the org.apache.ibatis.mapping.MappedStatement reference.

3. Method Complexity:
- No. Methods are short, no deep nesting, no conditional branches.

4. Potential Fragility:
- Low. Examples:
  - If MappedStatement’s API changes it won’t affect this class unless callers rely on stored object semantics; this class only stores and returns the reference.
  - If List behavior or expected semantics change (e.g., parameterObjects must be immutable), addParameterObject would need modification.
  - getParameterObject is fragile if parameterObjects is empty (IndexOutOfBoundsException).
  - If callers expect defensive copies of updateCounts or parameterObjects, changes to those expectations could require changes here.

5. Summary Judgment:
- Based on the file contents, there are no methods that call many methods concentrated in one or a few classes, so this file does not exhibit Intensive Coupling."
AbstractSendMessageProcessor.java,
StpLogic.java,
QueueTest.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- addFirstAndLastTest
- removeLastTest
- removeFirstTest
- resizableQueueTest
- resizableDequeTest
- getTest
- removeTest
- indexOfTest
- iteratorTest
- iteratorRemoveEdgeCaseTest
- toStringTest
- hashEqualsTest
- plus helper methods: assertEqualsAndHash, assertValues

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in com.badlogic.gdx.utils.Queue (addFirst, addLast, removeFirst, removeLast, first, last, get, removeIndex, indexOf, iterator, clear, size field, toString, equals, hashCode).
- Secondary providers: org.junit.Assert / static JUnit assert/fail methods, java.util.Iterator.

3. Method Complexity:
- Several methods have moderate complexity: nested loops and loop-within-loop patterns (resizableQueueTest, resizableDequeTest, getTest), iterator manipulation with multiple remove() calls (iteratorTest), and try/catch usage (getTest). Nesting is generally shallow (mostly 1–2 levels) but some methods contain many iterative branches and assertions.

4. Potential Fragility:
- Yes. Because most tests call many Queue APIs, changes to the Queue class (method signatures, behavior of iterator/remove, renaming/removal of methods, or making the size field private) would require many edits here. Examples: changing removeFirst/removeLast semantics, making size a private field, changing iterator.remove behavior, or altering equals/hashCode would break many tests in this file.

5. Summary Judgment:
- This file contains multiple methods that call many methods concentrated in one provider class (Queue), so it exhibits symptoms of Intensive Coupling."
DetectionResultRowIndicatorColumn.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- adjustCompleteIndicatorColumnRowNumbers(...)
- getBarcodeMetadata()
- removeIncorrectCodewords(...)
- adjustIncompleteIndicatorColumnRowNumbers(...)
- getRowHeights() (calls other helpers)
- setRowNumbers()

2. Calls Concentrated in Few Classes:
- Most calls are concentrated on Codeword (setRowNumberAsRowIndicatorColumn, getRowNumber, getValue, array access).
- Several calls target BoundingBox / ResultPoint (getTopLeft/getTopRight/getBottomLeft/getBottomRight, getY).
- Several calls target BarcodeMetadata and BarcodeValue (getRowCount, getters used in checks, setValue/getValue).
- Also depends on DetectionResultColumn parent methods (getCodewords(), getBoundingBox(), imageRowToCodewordIndex()) and PDF417Common constants.

3. Method Complexity:
- adjustCompleteIndicatorColumnRowNumbers(...) is the most complex: loop over rows, multiple conditional branches, nested loop, and stateful tracking (barcodeRow, maxRowHeight, currentRowHeight).
- adjustIncompleteIndicatorColumnRowNumbers(...) is moderately complex with a loop and branching.
- getBarcodeMetadata() and removeIncorrectCodewords(...) contain loops and switch statements but are less deeply nested.

4. Potential Fragility:
- Yes. Changes in Codeword (renaming/removing getRowNumber/setRowNumberAsRowIndicatorColumn/getValue or changing their semantics) would require changes across the listed methods (e.g., row-number logic and value%30 decoding).
- Changes to BarcodeMetadata or BarcodeValue APIs or semantics (row/count/getters) would force updates in getBarcodeMetadata() and removeIncorrectCodewords().
- Changes to BoundingBox/ResultPoint (coordinate methods) or imageRowToCodewordIndex behavior would affect row indexing and loops, likely requiring method adjustments.

5. Summary Judgment:
- There are methods (notably adjustCompleteIndicatorColumnRowNumbers and getBarcodeMetadata) that call many methods concentrated on a few provider classes (primarily Codeword, BoundingBox/ResultPoint, BarcodeMetadata/BarcodeValue), so this file exhibits symptoms consistent with Intensive Coupling."
RedissonSessionRepository.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- RedissonSession() (no-arg constructor)
- RedissonSession(MapSession) (constructor)
- updateExpiration() (inner)
- changeSessionId()
- setAttribute(String, Object)
- loadSession(String)
- onMessage(CharSequence, CharSequence, String)
- findByIndexNameAndIndexValue(String, String)
- deleteById(String)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in the Redisson API and related provider types:
  - RedissonClient (redisson)
  - org.redisson.api.RMap
  - org.redisson.api.RSet
  - org.redisson.api.RTopic / RPatternTopic
  - org.redisson.api.RBatch
  - org.redisson.api.RBucket
  - (also uses MapSession and ApplicationEventPublisher, but the majority of calls target Redisson types)

3. Method Complexity:
- changeSessionId(): moderate complexity — multiple async batch calls, result extraction and branching on TTL.
- onMessage(): branching with multiple if/else cases and nested logic to load sessions and publish events.
- setAttribute(): conditional handling for null values and special index attributes with extra set/get/remove operations.
- loadSession(): loop over map entries with multiple conditional branches mapping keys to session state.
- Overall these methods are moderately complex (several branches and loops), though not deeply nested beyond a few levels.

4. Potential Fragility:
- Yes. Because many methods depend heavily on RedissonClient and its APIs, changes in those provider classes or in return semantics would likely require updates here. Examples:
  - changeSessionId() depends on the order and types of BatchResult responses — any change to batching results could break logic.
  - updateExpiration()/setMaxInactiveInterval() assume specific expire semantics on RBucket/RMap; changes would affect expiration handling.
  - onMessage() depends on topic pattern names and message formats; changes in topic naming or message payloads would require modifying parsing and handling.
  - setAttribute() and principal index handling depend on RSet presence and behavior; changes to set APIs would affect index maintenance.

5. Summary Judgment:
- Yes. This file contains multiple methods that call many methods concentrated in a few provider classes (primarily the RedissonClient and its RMap/RSet/RTopic/RBatch/RBucket types), which is indicative of Intensive Coupling."
RelationshipTest.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method calls a large number of other methods. The methods that perform multiple calls (but not many) are:
  - before() — calls super.before() and Mockito.mock(...)
  - anyTest(), directTest(), extendedTest(), inLawTest(), spouseTest(), parentTest(), siblingTest() — each calls faker.relationships().<X>()
  - anyWithIllegalArgumentExceptionThrown(), anyWithSecurityExceptionThrown(), anyWithIllegalAccessExceptionThrown(), anyWithInvocationTargetExceptionThrown() — each calls when(mockFaker.random()).thenThrow(...) and new Relationships(mockFaker).any()

2. Calls Concentrated in Few Classes:
- Yes, the calls are concentrated mainly in a few classes:
  - Faker (faker.relationships(), mockFaker.random())
  - Relationships (any(), direct(), extended(), inLaw(), spouse(), parent(), sibling())
  - Mockito (mocking/when/thenThrow) — for test setup

3. Method Complexity:
- Methods are simple: no deep nesting, no conditional branches, short single-assert tests and straightforward setup/teardown.

4. Potential Fragility:
- Changes to the provider classes would affect these tests. Examples:
  - If Relationships changes method names or return types (e.g., any() renamed or signature changed), many tests here must be updated.
  - If Faker.relationships() behavior or the type it returns changes, tests that call relationships().* would break.
  - If Faker.random() or the mocking API interaction changes, the exception tests would need modification.

5. Summary Judgment:
- Although calls are concentrated on Faker/Relationships (and Mockito), the methods do not call many methods overall and are simple, so this file does not exhibit strong symptoms of Intensive Coupling."
BaseSwaggerConfig.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- createRestApi()
- apiInfo(SwaggerProperties swaggerProperties)
- getContextByPath(String pathRegex)
(secondary: securityContexts(), defaultAuth() — but they call fewer external methods)

2. Calls Concentrated in Few Classes:
Yes — most calls are concentrated in the springfox/swagger-related APIs and the local SwaggerProperties:
- springfox.documentation.spring.web.plugins.Docket
- springfox.documentation.builders.RequestHandlerSelectors
- springfox.documentation.builders.PathSelectors
- springfox.documentation.builders.ApiInfoBuilder
- springfox.documentation.spi.service.contexts.SecurityContext
- springfox.documentation.service.* (ApiKey, SecurityReference, AuthorizationScope, Contact)
- com.macro.mall.common.domain.SwaggerProperties (local provider)

3. Method Complexity:
- createRestApi(): moderate complexity — fluent builder chains and one conditional branch (if enableSecurity).
- apiInfo(...): low complexity — fluent builder chain but no branching or deep nesting.
- getContextByPath(...): low complexity — single builder chain.
- Others (securityContexts, securitySchemes, defaultAuth): simple, no deep nesting.

4. Potential Fragility:
Yes. Changes in any of the springfox provider classes or their builder/fluent APIs (Docket, RequestHandlerSelectors, PathSelectors, SecurityContext, ApiInfoBuilder, service classes) would likely require edits here. Examples:
- If Docket method names/signatures (apiInfo, select, apis, paths, build, securitySchemes, securityContexts) change, createRestApi() must be updated.
- If RequestHandlerSelectors.basePackage or PathSelectors.any/regex change semantics or signatures, the selection logic must change.
- If SecurityContext.builder() or SecurityReference/AuthorizationScope constructors change, getContextByPath() and defaultAuth() would need updates.
- If SwaggerProperties shape (e.g., getApiBasePackage, isEnableSecurity) changes, createRestApi() and apiInfo() must be updated.

5. Summary Judgment:
Based on the above, this file contains methods (notably createRestApi) that call many methods concentrated in a small set of provider classes (springfox/swagger and the local SwaggerProperties) — consistent with symptoms of Intensive Coupling."
MapperBuilderAssistant.java,
BuildCommand.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- run() — clearly calls many other methods.
- CLICause.getShortDescription() and CLICause.print() call a few provider methods but are small compared to run().

2. Calls Concentrated in Few Classes:
- Yes. Most calls in run() are concentrated around a small set of provider classes:
  - Job / ParameterizedJobMixIn / ParametersDefinitionProperty / ParameterDefinition / ParameterValue (job and parameter-related API)
  - Queue.Item / QueueTaskFuture and Run (scheduling and build/run objects)
  - Jenkins (authentication)
  - SCMTriggerItem / SCMDecisionHandler (SCM checking)
  - Also uses stdout and exception classes, but the bulk is in the job/run/queue/parameter providers.

3. Method Complexity:
- run() is moderately to highly complex: many conditional branches, nested ifs, loops (parameter processing loop, retry loop), try-catch with multi-exception handling, and branching around sync/follow/wait flags.
- CLICause methods are simple.

4. Potential Fragility:
- Yes. If one of the provider classes changes, run() would likely require changes and could be fragile. Examples:
  - Changes to Job APIs (getProperty, isBuildable, isHoldOffBuildUntilSave, getFullDisplayName) or ParameterizedJobMixIn.scheduleBuild2 would affect the scheduling and permission logic.
  - Changes to QueueTaskFuture/Queue.Item/Run (e.g., waitForStart, getFuture, getResult, writeWholeLogTo) would require modifications to the waiting, logging, and result-handling code.
  - Changes to SCMTriggerItem or SCMDecisionHandler would affect the checkSCM behavior and early exits.
  - Changes to Jenkins.getAuthentication2() or CauseAction/CLICause usage would affect caller identity and cause handling.

5. Summary Judgment:
- Yes — the file contains a method (run()) that calls many methods concentrated in a few provider classes (job/parameter APIs, queue/run APIs, SCM/Jenkins), exhibits notable complexity, and therefore shows symptoms consistent with Intensive Coupling."
FrameworkField.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method calls a large number of other methods. Methods that call other methods (only 1–2 calls each):
  - FrameworkField(Field) constructor: isPublic(), field.setAccessible(...)
  - getName(): getField().getName()
  - isShadowedBy(FrameworkField): otherMember.getName().equals(getName())
  - getAnnotations(): field.getAnnotations()
  - getAnnotation(...): field.getAnnotation(...)
  - getModifiers(): field.getModifiers()
  - getType(): field.getType()
  - getDeclaringClass(): field.getDeclaringClass()
  - get(Object): field.get(target)
  - toString(): field.toString()

2. Calls Concentrated in Few Classes:
- Yes — the called methods are concentrated almost entirely on:
  - java.lang.reflect.Field (field.get*, field.getType, field.getModifiers, field.getAnnotations, field.setAccessible, field.toString, etc.)
  - the superclass/own API: FrameworkMember / FrameworkField (isPublic(), getField(), getName())
- Calls are not spread across many different provider classes.

3. Method Complexity:
- Methods are simple and low complexity. Only the constructor has a small conditional and a try/catch; no deep nesting or many conditional branches elsewhere.

4. Potential Fragility:
- If java.lang.reflect.Field’s behavior or signatures changed, these methods would be affected (e.g., changes to access semantics or exceptions from Field#get or setAccessible).
- If FrameworkMember methods such as isPublic() or getName() changed, methods that call them (constructor, getName, isShadowedBy) would need updates.
- Overall impact is limited because each method delegates narrowly to Field or the superclass.

5. Summary Judgment:
- Although calls are concentrated on Field and a small superclass API, no method in this file calls many methods. Therefore this file does not exhibit Intensive Coupling as defined."
CmsSubjectCategoryExample.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method in this file calls a large number of different methods. Most methods call only one or two other methods. Examples of slightly more active methods: or() (calls createCriteriaInternal and oredCriteria.add), createCriteria() (calls createCriteriaInternal and may call oredCriteria.add), clear() (calls oredCriteria.clear and assigns fields). The many andXxx() methods each call a single helper addCriterion.

2. Calls Concentrated in Few Classes:
- The small number of calls that do exist are concentrated on:
  - this class's helpers/inners (addCriterion, createCriteriaInternal, Criteria, Criterion)
  - Java collection operations on oredCriteria (List.add, List.clear, size)
So calls are primarily to local inner classes (Criterion/GeneratedCriteria/Criteria) and the List API.

3. Method Complexity:
- Methods are simple and shallow. There is no deep nesting; conditional logic is minimal (mostly null checks and a single if to add initial Criteria). Generated andXxx methods are single-line wrappers around addCriterion.

4. Potential Fragility:
- Local changes could have broad impact: e.g., changing addCriterion's signature/behavior or changing the Criterion constructors would require updating all andXxx() methods and criteria construction. Changing the type or behavior of oredCriteria (e.g., replacing List with a different API) would require small changes in several methods (or, createCriteria, clear). These are local, not cross-package, impacts.

5. Summary Judgment:
- Based on this file alone, there are no methods that call many methods concentrated in one or a few external provider classes; the dependencies are local (inner classes and List). Therefore this file does not exhibit Intensive Coupling."
GsonBuilder.java,
RedissonBloomFilter.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- add(T object)
- contains(T object)
- tryInit(long expectedInsertions, double falseProbability)
- count()
- readConfig() (the no-arg overload)
(also: renameAsync and renamenxAsync call several external methods, but less heavily than the above)

2. Calls Concentrated in Few Classes:
Yes. Most calls are concentrated in a few provider classes/components:
- CommandBatchService (constructed and used heavily in add/contains/tryInit/count)
- CommandAsyncExecutor / commandExecutor (readAsync, writeAsync, evalReadAsync, evalWriteAsync, get, etc.)
- RBitSetAsync / RedissonBitSet (createBitSet -> bs.getAsync / bs.setAsync / bs.cardinalityAsync)
- Redis command/codec classes are used repeatedly (RedisCommands, StringCodec/LongCodec/etc.) but primarily as arguments to the executor methods

3. Method Complexity:
- add/contains: moderately complex — while(true) loop with a read-config check, creation of batch executor, loop over indexes, try/catch for RedisException, and post-execution response processing. Several control structures (loop, conditional, try/catch).
- tryInit: multiple validations, computation, batch executor calls, write operations and exception handling — medium complexity.
- count: linear sequence but uses async futures and response handling — moderate complexity.
- readConfig: simple in itself, but called in looped contexts above.

4. Potential Fragility:
Yes. Changes in any of the concentrated provider classes would likely require changes here or cause runtime failures. Examples:
- If CommandBatchService.execute() changes response format or behavior, add/contains/count parsing of responses (getResponses(), getNow(), expected ordering) would break.
- If RBitSetAsync/RedissonBitSet API (setAsync/getAsync/cardinalityAsync) signatures or semantics change, add/contains/count would need updates.
- If commandExecutor's readAsync/writeAsync/eval* contracts or Redis command expectations (e.g., keys/args or return types) change, many methods here would be affected.
- If the config hash fields (""size"", ""hashIterations"") change name/format, readConfig() and addConfigCheck/tryInit assertions would fail.

5. Summary Judgment:
Yes — multiple methods (notably add and contains, also tryInit and count) call many methods and the calls are concentrated in a few provider classes (CommandBatchService/CommandAsyncExecutor and RBitSetAsync/RedissonBitSet), indicating symptoms of Intensive Coupling."
InvokeCountOperation.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method calls a large number of other methods.
- Closest candidates (but only call a small number):
  - count(String, BytecodeInstruction): calls BytecodeInstruction.getCommentWithMemberPrefixStripped(), ParseUtil.bytecodeMethodCommentToReadableString(...), and InvokeMethodCountMap.countInvocationOfMethod(...).
  - processInstructions(String, MemberBytecode): calls MemberBytecode.getInstructions(), iterates and calls BytecodeInstruction.getOpcode(), and calls the local count(...) method.
  - getReport(): calls InvokeMethodCountMap.toString(limitPerInvoke).
  - constructor: instantiates new InvokeMethodCountMap().

2. Calls Concentrated in Few Classes:
- Calls are not concentrated in a single provider class; they are spread across a few small collaborators: BytecodeInstruction, ParseUtil, InvokeMethodCountMap, and MemberBytecode.

3. Method Complexity:
- Methods are simple. processInstructions has a single loop and a switch over opcodes (no deep nesting or many conditional branches). count is straightforward.

4. Potential Fragility:
- Changes in provider APIs would require updates here. Examples:
  - If BytecodeInstruction.getCommentWithMemberPrefixStripped() or getOpcode() are renamed/removed or change semantics, count/processInstructions must change.
  - If ParseUtil.bytecodeMethodCommentToReadableString signature or behavior changes, count must be updated.
  - If InvokeMethodCountMap.countInvocationOfMethod or toString(...) change, getReport/count/constructor usage must change.

5. Summary Judgment:
- Based on this file alone, there are no methods that call many methods concentrated in one or a few classes; Intensive Coupling is not present."
AbstractSentinelAspectSupport.java,
SaTokenConfig.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None that call many different methods. The only methods that call other methods are:
  - getCookieDomain() -> calls getCookie().getDomain()
  - setCookieDomain(String) -> calls getCookie().setDomain(cookieDomain)
  - toString() -> uses many fields and will implicitly call toString() on sso and cookie objects

2. Calls Concentrated in Few Classes:
- Yes, the few cross-object calls are concentrated in:
  - SaCookieConfig (getDomain, setDomain, and cookie.toString())
  - SaSsoConfig (sso.toString() from toString())

3. Method Complexity:
- Methods are simple. Most are trivial getters/setters. toString() is longer (many concatenations) but has no deep nesting or conditional branches.

4. Potential Fragility:
- Limited but present: if SaCookieConfig changes (e.g., renames or removes getDomain/setDomain) these wrapper methods would need updates. If SaSsoConfig or SaCookieConfig change their toString() semantics, the output of SaTokenConfig.toString() will change. Examples: renaming setDomain/getDomain or changing SaCookieConfig API would require edits here.

5. Summary Judgment:
- Based on this file alone, there are no methods that call many methods concentrated in one or a few classes to a degree that indicates Intensive Coupling."
HelpCommand.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- createCommandVO(Command, boolean) — calls many getters and methods (command.cli(), cli.getSummary(), cli.getOptions(), option.* , cli.getArguments(), etc.).
- process(CommandProcess) — calls allCommands(process.session()), findCommand(...), process.appendResult(...), process.end().
- complete(Completion) — calls allCommands(completion.session()), command.cli(), cli.isHidden(), CompletionUtils.complete(...).
- allCommands(Session) — calls session.getCommandResolvers() and CommandResolver.commands() in a loop.
(Secondary: createHelpModel and createOptionVO/createArgumentVO call several provider methods but fewer overall.)

2. Calls Concentrated in Few Classes:
Yes — most calls are concentrated in a few provider classes:
- com.taobao.middleware.cli.CLI
- com.taobao.middleware.cli.Option
- com.taobao.middleware.cli.Argument
- com.taobao.arthas.core.shell.command.Command
- com.taobao.arthas.core.shell.session.Session / CommandResolver
- com.taobao.arthas.core.util.usage.StyledUsageFormatter
These methods repeatedly invoke many methods on CLI/Option/Argument and Command instances.

3. Method Complexity:
- createCommandVO: moderate complexity — conditional checks (cli != null, withDetail), two loops (options, arguments), and inner conditionals (isHidden). Nesting depth is shallow (max ~2 levels) but has multiple branches and iterations.
- process, complete, allCommands: simple control flow, low complexity.
- createHelpModel: simple loop with conditional.

4. Potential Fragility:
Yes. Changes in any of the concentrated provider classes would likely require changes here. Examples:
- If CLI API changes (method names, getOptions/getArguments signatures, summary/description access), createCommandVO must be updated.
- If Option/Argument methods (isHidden, getLongName/getShortName/acceptValue/isMultiValued) change or are removed, createOptionVO/createArgumentVO break.
- If StyledUsageFormatter.computeUsageLine signature or behavior changes, usage generation will need updates.
- If Command/Session/CommandResolver interfaces change (name(), cli(), getCommandResolvers(), commands()), process, allCommands, complete would be affected.

5. Summary Judgment:
Yes — this file contains methods (notably createCommandVO) that call many methods concentrated in a few provider classes (CLI, Option, Argument, Command, StyledUsageFormatter), which are symptoms of Intensive Coupling."
UrlConnectionClient.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- prepareRequest(HttpURLConnection connection, Request request)
- readResponse(HttpURLConnection connection)
- openConnection(Request request) (moderate number of calls)
- execute(Request request) (delegates to the three above)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated on HttpURLConnection (setRequestMethod, setDoInput, addRequestProperty, setDoOutput, setFixedLengthStreamingMode, setChunkedStreamingMode, getResponseCode, getResponseMessage, getHeaderFields, getContentType, getContentLength, getErrorStream, getInputStream, getOutputStream, getURL).
- Secondary providers: Request/TypedOutput (getUrl, getMethod, getHeaders, body.mimeType, body.length, body.writeTo), URL, and the Retrofit model types (Header, Response, TypedInputStream).

3. Method Complexity:
- prepareRequest: moderate complexity — loop over headers, if (body != null) branch with nested if (length != -1).
- readResponse: moderate complexity — retrieves status/reason, iterates header map with nested loop, conditional to choose error vs input stream, constructs objects.
- Neither method has deep nesting, but both have multiple branches and loops.

4. Potential Fragility:
- Yes. Changes in HttpURLConnection API/behavior would likely require updates here (e.g., changed streaming mode methods, different header map shape from getHeaderFields, different semantics for getErrorStream/getInputStream).
- Changes to Request/TypedOutput (for example signature/behavior of writeTo(), length() or mimeType()) would also force changes in prepareRequest.
- Changes to Response/Header/TypedInput expectations could require updates to readResponse.

5. Summary Judgment:
- Based on the above, this file contains methods (notably prepareRequest and readResponse) that call many methods concentrated in a small set of provider classes (primarily HttpURLConnection) — indicative of Intensive Coupling."
AssemblyProcessor.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- handleLine(...)
- complete()
- attachAssemblyToMembers(PackageManager)
(also getStartAddress(...) is small but called and uses string methods; clear() uses several state-reset calls)

2. Calls Concentrated in Few Classes:
- handleLine: many calls concentrated around StringUtil and Architecture (also StringBuilder and logger, and uses JITWatchConstants).
- complete: concentrated on AssemblyUtil (getParserForArchitecture) and the returned IAssemblyParser, plus AssemblyMethod.
- attachAssemblyToMembers: concentrated on MemberSignatureParts, PackageManager, MetaClass and IMetaMember (and AssemblyMethod).

3. Method Complexity:
- handleLine: high complexity — many branches, boolean state flags (assemblyStarted, methodStarted, methodInterrupted), nested conditionals and multiple early returns/side-effects.
- attachAssemblyToMembers: moderate complexity — loop over assemblyMethods, try/catch, several conditional branches and interactions with multiple provider classes.
- complete: low-to-moderate complexity — conditional behavior based on parser existence.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require changes here. Examples:
  - If AssemblyUtil.getParserForArchitecture or IAssemblyParser.parseAssembly changes, complete() must be updated.
  - If MemberSignatureParts.fromAssembly or MetaClass.getMemberForSignature signatures/behaviour change, attachAssemblyToMembers must be updated.
  - If Architecture.parseFromLogLine or StringUtil methods change, handleLine will break or need adaptation.
  - Changes to AssemblyMethod API (setNativeAddress/setEntryAddress/getAssemblyMethodSignature/addAssembly) would impact multiple methods here.

5. Summary Judgment:
- Yes — this file contains methods (notably handleLine, complete, attachAssemblyToMembers) that call many methods whose calls are concentrated in a small set of provider classes, indicating symptoms of Intensive Coupling."
JavaBeanDeserializer.java,
RetrofitError.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No methods calling a large number of other methods. The closest is:
  - getBodyAs(Type) — calls response.getBody(), converter.fromBody(...), and constructs a RuntimeException in the catch.

2. Calls Concentrated in Few Classes:
- The small set of calls in getBodyAs are concentrated in a few provider types:
  - retrofit.client.Response (response.getBody(), response.getStatus(), response.getReason() used elsewhere)
  - retrofit.converter.Converter (converter.fromBody)
  - retrofit.mime.TypedInput (used as an argument type)
  - java.lang.Throwable/RuntimeException (exception.getMessage(), new RuntimeException(...))

3. Method Complexity:
- Methods are simple. getBodyAs has two early null checks and a single try/catch — no deep nesting or many conditional branches. Other methods are simple factories or getters.

4. Potential Fragility:
- Changes in provider classes would require changes here. Examples:
  - If Response.getBody() changes its return type or semantics, getBodyAs would need updating.
  - If Converter.fromBody(...) signature or exception behavior changes, getBodyAs (and conversionError) must be updated.
  - If Response.getStatus()/getReason() change, httpError must be adjusted.

5. Summary Judgment:
- Based on the file, there are no methods that call many methods concentrated in one or a few classes to the degree that indicates Intensive Coupling."
Selectable.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. This file is an interface (Selectable) containing only method declarations; there are no method bodies to inspect for calls.

2. Calls Concentrated in Few Classes:
- Not applicable because there are no method implementations or call sites in this file. The interface references types like Selector and List, but does not call methods on them here.

3. Method Complexity:
- Not applicable. No implementations are present, so there is no nesting or conditional logic to evaluate.

4. Potential Fragility:
- As an interface, changes to provider classes (for example the Selector type or return types used by implementors) could force changes in implementing classes, but this file itself would not be fragile due to concentrated calls. Example: if Selector's API changed, implementations of select/selectList would need updates — but those implementations are not in this file.

5. Summary Judgment:
- There are no methods in this file that call many methods concentrated in one or a few classes, so the Intensive Coupling smell is not detectable here."
CellFormulaTagHandler.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method in this file calls a large number of other methods. For completeness, the methods and their calls:
  - startElement: xlsxReadContext.xlsxReadSheetHolder(), getTempCellData().setFormula(...), setTempFormula(...)
  - endElement: xlsxReadContext.xlsxReadSheetHolder(), getTempCellData().setFormulaValue(...), getTempFormula().toString()
  - characters: xlsxReadContext.xlsxReadSheetHolder().getTempFormula().append(...)

2. Calls Concentrated in Few Classes:
- Yes, the few calls that exist are concentrated in a small set of provider classes:
  - XlsxReadSheetHolder
  - The TempCellData returned by getTempCellData()
  - java.lang.StringBuilder (returned by getTempFormula())

3. Method Complexity:
- Methods are simple and not complex: no deep nesting, no conditional branches, short sequences of calls.

4. Potential Fragility:
- Changes to provider classes would require edits here. Examples:
  - If XlsxReadSheetHolder.rename/remove methods (xlsxReadSheetHolder(), getTempFormula(), setTempFormula(), getTempCellData()), these methods must be updated.
  - If TempCellData changes its API (setFormula/setFormulaValue signatures), callers must change.
  - If getTempFormula no longer returns a StringBuilder (or its append/toString semantics change), characters/endElement would break.

5. Summary Judgment:
- Although calls are concentrated in a few provider classes, the methods call only a small number of methods and are simple. Therefore this file does not exhibit strong symptoms of Intensive Coupling."
ClassWriter.java,
CompareToBuilder.java,
DataFormatter.java,
AccessTokenModel.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- toLineMap() — calls map.put multiple times and two local getters.
- toString() — performs multiple string concatenations (implicit StringBuilder/append calls).
- getExpiresIn() and getRefreshExpiresIn() — each calls System.currentTimeMillis() (single external call).

2. Calls Concentrated in Few Classes:
- Yes, calls are concentrated: main providers are java.util.Map / java.util.LinkedHashMap (map.put repeated), this class (AccessTokenModel via getExpiresIn/getRefreshExpiresIn), and java.lang.System (currentTimeMillis).

3. Method Complexity:
- No. Methods are simple and linear: no deep nesting, no loops, minimal conditional logic (only simple ternary in the two get* methods).

4. Potential Fragility:
- Low. Changes in provider classes would have limited impact. Examples:
  - If Map/LinkedHashMap behavior changed (very unlikely), toLineMap could be affected.
  - If getExpiresIn/getRefreshExpiresIn semantics change, callers and toLineMap output may need adjustments.
  - Changes to System.currentTimeMillis usage (e.g., time source) would require updating the two getters.

5. Summary Judgment:
- Based on the above, this file does not contain methods exhibiting Intensive Coupling."
NiceSecurePasswordField.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- NiceSecurePasswordField() (the constructor) — contains many calls to setters, property binds, getStyleClass/add, getChildren/addAll, etc.
- Other methods are simple passthroughs (requestFocus, getText, textProperty, setPassword, wipe, selectAll, selectRange) and each calls 1 underlying method only.

2. Calls Concentrated in Few Classes:
- Yes. Most calls in the constructor target a small set of provider classes/objects:
  - SecurePasswordField (passwordField)
  - FontAwesome5IconView (capsLockedIcon, nonPrintableCharsIcon, revealPasswordIcon)
  - ToggleButton (revealPasswordButton)
  - HBox (iconContainer)
  - Also a few calls to StackPane (static alignment), Bindings, and the current Node API (getChildren(), disabledProperty()).

3. Method Complexity:
- The constructor is relatively long (many sequential statements) but not deeply nested and contains no complex conditional branching or loops.
- Other methods are trivial passthroughs or single-line handlers.

4. Potential Fragility:
- Yes. Because many calls are concentrated on a few provider classes, changes to those provider APIs would likely require edits here. Examples:
  - If SecurePasswordField renames or removes capsLockedProperty(), containingNonPrintableCharsProperty(), revealPasswordProperty(), textProperty(), or its setPassword/wipe/select* methods, the constructor and many passthrough methods would break.
  - If FontAwesome5IconView changes glyph/glyphProperty/setGlyphSize API, multiple lines configuring icons would need updates.
  - If ToggleButton property names/semantics change (selectedProperty, visibleProperty), bindings and behavior for revealPasswordButton would need rework.

5. Summary Judgment:
- Yes — the constructor exhibits concentrated calls across a few provider classes (UI components and SecurePasswordField), which is a symptom of Intensive Coupling."
GeometryViewerRegistry.java,
RestMethodInfoTest.java,
AssertUtil.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None of the methods make a large number of distinct method calls. The methods that call several external methods (but still a small set) are:
  - assertCollectionContains
  - assertByteArrayListEquals
  - assertByteArraySetEquals
  - assertCollectionContainsAll
  - assertByteArrayCollectionContainsAll

2. Calls Concentrated in Few Classes:
- Yes, the calls are concentrated in a small set of utility/provider classes rather than spread widely:
  - java.util.Arrays (equals, toString)
  - java.util.Objects (equals, toString)
  - org.junit.Assert / org.junit.ComparisonFailure (assertEquals, assertArrayEquals, ComparisonFailure)
  - java.util Collection/List/Iterator methods (size, get, iterator, hasNext, next)
- These constitute most external call targets.

3. Method Complexity:
- The methods are simple: they use single loops with shallow conditional checks (one level of nesting). No deep nesting or many branches.

4. Potential Fragility:
- Low to moderate. If a provider utility changes (e.g., Arrays.equals semantics, Objects.equals, or JUnit assertion/exception APIs), the calling methods might need updates. Examples:
  - A change to Arrays.equals behavior for byte[] would affect the byte-array comparisons here.
  - A change in ComparisonFailure constructors or expected message formats could require adjusting thrown exceptions.
- However, such provider changes are relatively uncommon; the methods themselves are small and localized.

5. Summary Judgment:
- Overall, although the file depends on a few utility/provider classes, none of its methods exercise an unusually large number of calls concentrated in only one/few classes to the degree that indicates Intensive Coupling."
FieldAttributes.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. Most methods are simple delegations that call one (or at most two) methods (examples: getName(), getDeclaredType(), getDeclaredClass(), getAnnotation(), isSynthetic(), get(), hasModifier(), getAnnotations()).

2. Calls Concentrated in Few Classes:
- The few calls that do exist are concentrated in a small set of provider classes:
  - java.lang.reflect.Field (most delegations)
  - java.util.Arrays (Arrays.asList used in getAnnotations)
  - com.google.gson.internal.$Gson$Preconditions (constructor checkNotNull)

3. Method Complexity:
- Methods are not complex: no deep nesting, no loops, and very few conditional branches. They are simple one-line delegators.

4. Potential Fragility:
- Because many methods delegate to java.lang.reflect.Field, changes to Field's API could require updates here (e.g., if Field.getDeclaredType()/getType()/get()/getName()/isSynthetic()/getModifiers()/getAnnotations() semantics or availability changed). Changes to Arrays.asList or $Gson$Preconditions could also affect the small places they are used. However, these are thin wrappers, so impact would be localized.

5. Summary Judgment:
- Based on the above, this file does not exhibit Intensive Coupling: methods do not call many methods, and although calls are concentrated on Field, the methods are simple delegations and not complex or heavily coupled."
ExcelWriteFillExecutor.java,
Throwables.java,
BeanCopier.java,
AndroidGraphics.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- onDrawFrame(javax.microedition.khronos.opengles.GL10)
- onSurfaceCreated(javax.microedition.khronos.opengles.GL10, EGLConfig)
- onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)
- pause()
- resume()
- destroy()
- updateSafeAreaInsets()
- logConfig(EGLConfig) (moderate number of calls)

2. Calls Concentrated in Few Classes:
- app / AndroidApplicationBase and its collaborators (getApplicationListener(), getRunnables(), getExecutedRunnables(), getLifecycleListeners(), getInput(), getWindowManager(), getApplicationWindow(), etc.)
- LifecycleListener / SnapshotArray (iteration and callback invocation)
- GL/graphics resource manager classes: Mesh, Texture, Cubemap, TextureArray, ShaderProgram, FrameBuffer (static invalidate/clear/getManagedStatus)
- Gdx / Gdx.app logging and Gdx.gl usage
- EGL/EGL10 related providers (egl calls) and GLSurfaceView/view interactions (view.queueEvent, view.requestRender, view.setRenderMode)

3. Method Complexity:
- Yes. onDrawFrame has synchronization, multiple boolean flags, conditional branches (resume/pause/destroy/running), loops over listeners and runnables, try/catch around runnable execution — fairly complex.
- onSurfaceCreated and onSurfaceChanged perform multiple steps and calls; pause/destroy include waits and error handling — moderate complexity and control flow depth.

4. Potential Fragility:
- High coupling to app/ApplicationListener: changes to ApplicationListener lifecycle methods or AndroidApplicationBase APIs would require changes here (e.g., renaming lifecycle methods, changing how runnables/lifecycle listeners are provided).
- High coupling to GL/resource managers: signature or semantic changes in Mesh/Texture/ShaderProgram/FrameBuffer static APIs would break onSurfaceCreated, clearManagedCaches, logManagedCachesStatus.
- Changes to GLSurfaceView/EGL APIs or view threading/queueEvent semantics could break pause() synchronization and cause deadlocks or forced process termination.
- Example: if Mesh.invalidateAllMeshes(app) were removed or its parameters changed, onSurfaceCreated must be updated; if SnapshotArray iteration semantics change, listener callback code in onDrawFrame would need modification.

5. Summary Judgment:
- Yes — there are clear symptoms of intensive coupling: several methods (notably onDrawFrame and onSurfaceCreated) call many methods and those calls are concentrated in a small set of provider classes (app and GL/resource manager classes), making these methods potentially fragile to changes in those providers."
ExecutorRouteBusyover.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- route(TriggerParam triggerParam, List<String> addressList) — the only method in this file; it calls several other methods (listed below).

2. Calls Concentrated in Few Classes:
- The calls are spread across a few utility/provider classes rather than concentrated in one: XxlJobScheduler (getExecutorBiz), ExecutorBiz (idleBeat), I18nUtil (getString), StringBuffer (length, append), ReturnT (constructors, getCode, getMsg, setMsg, setContent), TriggerParam (getJobId), and logger (error). No single external provider dominates the majority of calls.

3. Method Complexity:
- The method is simple: a single loop over addresses, one try-catch block per iteration, and one conditional branch to return on success. No deep nesting or many conditional branches.

4. Potential Fragility:
- Changes to provider APIs would affect this method. Examples:
  - If ExecutorBiz.idleBeat signature or behavior changes, route must adapt.
  - If XxlJobScheduler.getExecutorBiz changes, lookup logic must change.
  - If ReturnT semantics or fields change, the way results are inspected/returned must change.
  - These are limited, localized impacts rather than widespread coupling to many methods in one class.

5. Summary Judgment:
- Based on the above, this file does not exhibit the Intensive Coupling smell: the single method calls several helpers but those calls are not highly concentrated in one or a few provider classes."
IncompleteElementException.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. The file contains only simple constructors (IncompleteElementException()) that call superclass constructors (super()).

2. Calls Concentrated in Few Classes:
- N/A for heavy callers. The only provider classes involved are:
  - org.apache.ibatis.builder.BuilderException (superclass)
  - java.lang.Throwable / java.lang.Object (transitively via super)

3. Method Complexity:
- No. All methods are trivial constructors with no deep nesting or conditional branches.

4. Potential Fragility:
- Minor: if BuilderException's constructors or hierarchy changed (removed/renamed constructors), these constructors would need adjustment. Example: removing the (String, Throwable) constructor in BuilderException would break the corresponding constructor here.
- Otherwise changes in other classes are unlikely to cause widespread impact given the simplicity.

5. Summary Judgment:
- Based on the above, this file does not contain methods that call many methods concentrated in one or a few classes; it does not exhibit Intensive Coupling."
NioClientTest.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- main(...) — the only method in this file that invokes many other methods (including the channel handler lambda it passes).

2. Calls Concentrated in Few Classes:
- The calls are not narrowly concentrated in a single provider class; they are spread across a small set of classes. Main provider classes involved:
  - NioClient (setChannelHandler, listen, write)
  - java.nio.ByteBuffer (allocate, flip, remaining, get)
  - the channel object (sc — likely java.nio.channels.SocketChannel: read, close, getRemoteAddress)
  - cn.hutool.core.io.BufferUtil
  - cn.hutool.core.lang.Console
  - cn.hutool.core.util.StrUtil
  - java.util.Scanner / java.lang.String

3. Method Complexity:
- main contains modest complexity: a short lambda with a single if/else branch (readBytes > 0 / < 0) and a top-level while loop reading console input. No deep nesting or many conditional branches.

4. Potential Fragility:
- Changes to provider APIs could require updates here. Examples:
  - If NioClient’s write/listen/setChannelHandler signatures change, main must be updated.
  - If the channel (sc) read/close/getRemoteAddress behavior or types change, the handler must be adjusted.
  - If BufferUtil or StrUtil APIs change, the encoding/creation calls would need updates.

5. Summary Judgment:
- Based on the above, this file does not show strong symptoms of Intensive Coupling: the single method calls multiple helpers, but those calls are relatively few and spread across several small provider classes rather than being heavily concentrated on one/few provider classes."
ClientHandler.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- run() — calls multiple methods (getOutputStream, httpd.getTempFileManagerFactory().create, new HTTPSession(...), acceptSocket.isClosed, session.execute, NanoHTTPD.LOG.log, NanoHTTPD.safeClose, httpd.asyncRunner.closed, etc.).
- close() — calls NanoHTTPD.safeClose twice.

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in:
  - java.net.Socket (acceptSocket.getOutputStream(), acceptSocket.isClosed(), acceptSocket.getInetAddress())
  - org.nanohttpd.protocols.http.NanoHTTPD / the httpd instance (httpd.getTempFileManagerFactory(), NanoHTTPD.safeClose, NanoHTTPD.LOG, httpd.asyncRunner.closed)
  - org.nanohttpd.protocols.http.HTTPSession (constructor and session.execute())
  - org.nanohttpd.protocols.http.tempfiles.ITempFileManager (create() via factory)

3. Method Complexity:
- run() has moderate complexity: a try-catch-finally with a while loop and a compound conditional in the catch. It is not deeply nested but contains control flow (loop + exception handling) and several external interactions.
- close() is simple.

4. Potential Fragility:
- Yes. Changes in provider classes would likely force changes here. Examples:
  - If Socket behavior or methods change (e.g., output stream handling or isClosed semantics), run() would need updates.
  - If NanoHTTPD.safeClose or logging API changes, or httpd.asyncRunner.closed signature/behavior changes, run() and close() must be adapted.
  - If HTTPSession constructor or execute() contract changes, run() must be updated.
  - If the temp file manager factory/create API changes, run() must be modified.

5. Summary Judgment:
- Yes — the run() method calls many methods that are concentrated mainly in the Socket and NanoHTTPD/httpd provider classes (plus closely related session/tempfile classes), which is a symptom of Intensive Coupling."
DefaultJedisSocketFactory.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- createSocket()

2. Calls Concentrated in Few Classes:
- Yes. Most calls in createSocket are concentrated in:
  - java.net.Socket (setReuseAddress, setKeepAlive, setTcpNoDelay, setSoLinger, connect, setSoTimeout, etc.)
  - javax.net.ssl.* (SSLSocketFactory.createSocket, SSLSocket.setSSLParameters, SSLSocket.getSession, HostnameVerifier.verify, SSLParameters)
  - supporting/provider classes used multiple times: redis.clients.jedis.HostAndPort and HostAndPortMapper
  - utility: redis.clients.jedis.util.IOUtils
  - also java.net.InetSocketAddress (connect)

3. Method Complexity:
- Moderate complexity: createSocket has a try/catch, conditionals (if (ssl) { ... } ), and nested conditionals inside the SSL block (null checks for sslSocketFactory, sslParameters, hostnameVerifier and a verification branch). Not deeply nested but multiple branches and exception handling.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require changes here or cause runtime issues. Examples:
  - If java.net.Socket gain/lose/alter behaviour or signature for the socket options used (setSoLinger, setTcpNoDelay, etc.) this method must be updated.
  - If SSLSocketFactory or SSLSocket APIs or semantics change (createSocket behavior, setSSLParameters, getSession), createSocket will need adjustments.
  - If HostAndPortMapper.getHostAndPort changes contract (e.g., different null behavior or mapping semantics), getSocketHostAndPort/createSocket behavior could break.
  - If HostnameVerifier.verify semantics change or is removed, hostname verification step would be impacted.
  - If IOUtils.closeQuietly is removed/changed, error-path cleanup would need edits.

5. Summary Judgment:
- Yes — the file contains a method (createSocket) that calls many methods concentrated mainly in a few provider classes (Socket and SSL-related classes), which shows symptoms of Intensive Coupling."
CronExpression.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- getTimeAfter(Date)
- buildExpression(String)
- storeExpressionVals(int, String, int)
- checkNext(int, String, int, int)
- addToSet(int, int, int, int)
(also helpers with many calls: getExpressionSetSummary(Set), isSatisfiedBy(Date), getNextInvalidTimeAfter(Date))

2. Calls Concentrated in Few Classes:
- getTimeAfter: heavily concentrated on java.util.Calendar (including GregorianCalendar), java.util.Date and java.util.SortedSet/TreeSet.
- buildExpression / storeExpressionVals / checkNext / addToSet: concentrated on java.util.StringTokenizer / java.lang.String parsing utilities and java.util.TreeSet (and internal maps monthMap/dayMap).
- Other helpers: repeated use of java.util.Calendar, java.util.Date, java.util.TreeSet.

3. Method Complexity:
- Yes. These methods are long and complex with deep nesting and many conditional branches (notably getTimeAfter, storeExpressionVals, checkNext and addToSet).

4. Potential Fragility:
- Yes. Changes in provider classes would likely require changes here. Examples:
  - Any change in Calendar/GregorianCalendar behavior or API (get/set/add/fields/roll) would require edits to getTimeAfter and setCalendarHour.
  - Changing TreeSet/SortedSet semantics or replacing the internal representation of scheduling sets would impact many methods that rely on tailSet(), first(), contains(), iterator().
  - Altering Date/TimeZone behavior or replacing Date with java.time types would require modifying many call sites (isSatisfiedBy, getTimeAfter, getNextInvalidTimeAfter).
  - Changing month/day name mappings would break parsing in buildExpression/storeExpressionVals/getMonthNumber/getDayOfWeekNumber.

5. Summary Judgment:
- Yes — this file contains methods that call many methods and those calls are concentrated in a few provider classes (notably java.util.Calendar and java.util.TreeSet/StringTokenizer), which are symptoms consistent with Intensive Coupling."
PooledDataSource.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- popConnection(...)
- pushConnection(PooledConnection)
- forceCloseAll()
- pingConnection(PooledConnection)
- (secondary) unwrapConnection(Connection) — fewer calls but interacts with Proxy/PooledConnection

2. Calls Concentrated in Few Classes:
- PooledConnection (many calls: getRealConnection, isValid, invalidate, getCheckoutTime, getRealHashCode, set*, etc.)
- PoolState (fields and methods: idleConnections, activeConnections, wait/notify, counters)
- UnpooledDataSource / dataSource (getConnection, getUrl, getUsername, getPassword)
- java.sql.Connection / Statement (rollback, close, getAutoCommit, createStatement, executeQuery)
- Log (log.debug, log.warn) — secondary

3. Method Complexity:
- popConnection: high complexity (large loop, deep nesting, multiple branches, synchronized block, try/catch, state mutations).
- pushConnection: moderate complexity (nested conditionals, synchronized block, resource handling).
- forceCloseAll: moderate (synchronized loops, resource cleanup).
- pingConnection: low-moderate (conditional checks, try-with-resources, nested try/catch).

4. Potential Fragility:
- Changes to PooledConnection API (rename/remove methods or change semantics of getRealConnection/isValid/invalidate) would require edits across popConnection, pushConnection, pingConnection, forceCloseAll.
- Changes to PoolState structure or field accessibility (idleConnections/activeConnections naming/behavior, wait/notify semantics, counters) would break synchronization and state updates in popConnection/pushConnection/forceCloseAll.
- Changes to UnpooledDataSource.getConnection or credential handling would affect popConnection creation and connection typing logic.
- Changes in java.sql.Connection behavior (rollback/close semantics, statement behavior) would affect resource handling in multiple methods (pushConnection, forceCloseAll, pingConnection).

5. Summary Judgment:
Yes — this file contains several methods (notably popConnection and pushConnection) that call many methods concentrated on a small set of provider classes (PooledConnection, PoolState, UnpooledDataSource, java.sql.Connection), which are symptoms of Intensive Coupling."
EmbedServer.java,
SentinelDubboConsumerFilter.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- syncInvoke(Invoker<?, Invocation>) 
- asyncInvoke(Invoker<?, Invocation>)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in a few provider classes/modules:
  - SphU (entry, asyncEntry)
  - Tracer (traceEntry)
  - DubboAdapterGlobalConfig (getDubboConsumerResNamePrefixKey, getConsumerFallback)
  - Entry / EntryHolder (exit)
  - Invoker / Result (invoke, whenCompleteWithContext, hasException, getException)
  - (secondary: RpcUtils, DubboUtils, Optional, LinkedList)

3. Method Complexity:
- syncInvoke: moderate complexity — try / catch / finally, multiple calls and conditional tracing when result.hasException().
- asyncInvoke: higher complexity — creates a queue, pushes entries, invokes with async completion lambda, processes queue in a loop, and has an exception path that unwinds the queue. Contains asynchronous callback and loop, so more complex than syncInvoke.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require changes here. Examples:
  - If SphU.entry/asyncEntry signatures or semantics change, syncInvoke/asyncInvoke must be updated.
  - If Tracer.traceEntry API or tracing behavior changes, tracing calls in both methods must be adapted.
  - If Entry.exit overloads/signatures change, exitEntry and finally blocks must be updated.
  - If DubboAdapterGlobalConfig.getConsumerFallback() or its handle(...) signature changes, the BlockException handling paths must change.
  - Changes to Result.whenCompleteWithContext behavior or Result.getException would affect asyncInvoke’s completion handling.

5. Summary Judgment:
- Yes — the file contains methods (syncInvoke and asyncInvoke) that call many methods and those calls are concentrated in a few provider classes (notably SphU, Tracer, DubboAdapterGlobalConfig and Entry-related APIs), indicating symptoms of Intensive Coupling."
QueryParser.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- parse()
- combinator(char)
- consumeSubQuery()
- findElements()
- byAttribute()
- cssNthChild(boolean, boolean)
(also: byTag(), has(), contains(...), matches(...), not() call multiple provider methods but fewer than the ones listed)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in:
  - TokenQueue (tq.* and local TokenQueue cq)
  - Evaluator family (Evaluator and nested classes like CombiningEvaluator, StructuralEvaluator and their nested evaluator types)
  - supporting utilities used frequently: Validate, StringUtil/Normalizer, and java.util.regex (Pattern/Matcher)

3. Method Complexity:
- Yes. parse() has loops and several branches; combinator() has a multi-case switch and instanceof logic with replacement handling; findElements() is a long if/else chain dispatching many selector types; cssNthChild() has multiple regex-based branches. These show non-trivial branching and control flow.

4. Potential Fragility:
- Yes. Changes to provider classes would likely require changes here or cause breakage. Examples:
  - If TokenQueue method names/semantics change (e.g., matchChomp, chompBalanced, matchesAny), parse(), findElements(), consumeSubQuery(), byAttribute(), etc. would all break.
  - If Evaluator/CombiningEvaluator/StructuralEvaluator constructors, add/replaceRightMostEvaluator/rightMostEvaluator semantics change, combinator(), parse(), and code that builds evals would need updates.
  - Changes to Validate/StringUtil/Normalizer or regex behavior could also require localized fixes in multiple methods.

5. Summary Judgment:
- Yes — the file contains multiple methods that call many methods concentrated primarily in TokenQueue and the Evaluator family, showing symptoms consistent with Intensive Coupling."
HikariDataSource.java,
Excluder.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- excludeField(Field, boolean)
- excludeClassChecks(Class<?>)
- create(final Gson, final TypeToken<T>) (includes anonymous TypeAdapter with delegate(), read(), write())

2. Calls Concentrated in Few Classes:
- java.lang.reflect.Field (getModifiers(), getAnnotation(...), isSynthetic(), getType(), etc.)
- java.lang.Class (isMemberClass(), isAnonymousClass(), isLocalClass(), isAssignableFrom(), getModifiers())
- com.google.gson.ExclusionStrategy (shouldSkipField, shouldSkipClass) and the lists of ExclusionStrategy
- com.google.gson.FieldAttributes (constructor)
- com.google.gson.Gson (getDelegateAdapter) — used by create()

3. Method Complexity:
- excludeField: multiple sequential conditionals and one loop over strategies; shallow nesting (one nested if for @Expose check and a loop), moderate complexity.
- excludeClassChecks: simple sequence of conditionals, low complexity.
- create / anonymous TypeAdapter: moderate complexity due to lazy delegate initialization and conditional read/write branches.

4. Potential Fragility:
- Changes to Field API or annotation handling (Since/Until/Expose) would require updates to excludeField and isValid* methods.
- Modifications to ExclusionStrategy interface or behavior would impact excludeField and excludeClassInStrategy (e.g., renaming shouldSkipField/shouldSkipClass).
- Changes to Gson.getDelegateAdapter signature or TypeAdapter lifecycle would affect create() and the anonymous TypeAdapter delegate() logic.
- Changes to Class/Modifier behavior (e.g., how inner/static classes are detected) would affect isInnerClass/isStatic and callers.

5. Summary Judgment:
- Yes — there are methods (notably excludeField and related exclusion checks) that call many methods and concentrate their calls on a small set of provider classes (Field/Class/ExclusionStrategy/Gson), which are symptoms consistent with Intensive Coupling."
JedisClusterCommand.java,
TestConnections.java,
OmsReceiverInfoParam.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. The file contains only simple getter methods (manually stubbed to return null) and no methods that invoke other methods.

2. Calls Concentrated in Few Classes:
- Not applicable — there are no method calls to concentrate in any provider classes.

3. Method Complexity:
- The methods are not complex: they have no nesting, no conditional branches, and contain only stubbed return statements.

4. Potential Fragility:
- Low/none in this file: since the methods do not call external/provider classes, changes in other classes would not require changes here (no examples of impacted provider usage).

5. Summary Judgment:
- This file does not exhibit Intensive Coupling."
ResizeController.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- initialize()
- savePositionalSettings()
- getMonitorSizes()
- resizeTop(), resizeLeft(), resizeBottom(), resizeRight()
- startResize()
- didDisplayConfigurationChange()

2. Calls Concentrated in Few Classes:
- Most calls are concentrated in:
  - Stage (window) — many getX/getY/getWidth/getHeight/getMin*/getMax*/setX/setY/setWidth/setHeight/isFullScreen()
  - Settings (settings) — window*Property(), displayConfigurationProperty().get()/setValue()
  - Screen (javafx.stage.Screen) / Rectangle2D — getScreens(), getPrimary(), getBounds(), getWidth(), getHeight()
- Secondary: MouseEvent (evt.getScreenY/getSceneX/getSceneY/getScreenX) and logger (LOG.trace).

3. Method Complexity:
- initialize(): moderate complexity with nested if/else and conditional branch handling display configuration and positioning.
- getMonitorSizes(): simple loop over screens (iteration complexity).
- resize* methods: low to moderate complexity — mostly simple arithmetic and boundary checks.
- Overall: no extremely deep nesting, but initialize contains multiple branches and paths.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require edits here. Examples:
  - If Stage API changes (renamed getters/setters or different coordinate semantics), many methods (initialize, savePositionalSettings, all resize* and startResize) would need updates.
  - If Settings property names or semantics change, initialize(), didDisplayConfigurationChange(), savePositionalSettings() would break.
  - If Screen/Rectangle2D API or the way screens are enumerated changes, getMonitorSizes() and didDisplayConfigurationChange() would need modification.

5. Summary Judgment:
- Yes — this file contains several methods that call many methods concentrated in a few provider classes (primarily Stage, Settings, and Screen), exhibiting symptoms consistent with Intensive Coupling."
Lifecycle.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- get()
- rewriteHudsonWar(File)
- (to a lesser extent) canRewriteHudsonWar()

2. Calls Concentrated in Few Classes:
- get(): calls are concentrated around Jenkins-related providers and environment/property helpers: jenkins.util.SystemProperties, jenkins.model.Jenkins (and its PluginManager/uberClassLoader), hudson.Functions, java.lang.System (env).  
- rewriteHudsonWar(File): calls are concentrated in java.io.File and org.apache.commons.io.FileUtils (plus a local getHudsonWar()).
- canRewriteHudsonWar(): concentrated on java.io.File methods (getHudsonWar(), File.canWrite(), File.getParentFile()).

3. Method Complexity:
- get(): relatively complex — multiple conditional branches (system property branch, OS checks, environment checks), nested try/catch blocks, and multiple alternative instantiations; moderate nesting/branching.  
- rewriteHudsonWar(File): moderate complexity — a few conditionals and file operations but linear flow.  
- canRewriteHudsonWar(): simple, shallow condition checks.

4. Potential Fragility:
- get(): changes to Jenkins.get(), PluginManager/uberClassLoader, or the expected system property handling would likely require changes here (e.g., plugin classloading API change, different property key, or different env detection). Example: if PluginManager no longer exposes uberClassLoader, the class-loading path would break and get() must be updated.  
- rewriteHudsonWar(File): changes to File semantics or FileUtils API (copyFile/delete behavior) or to the location/format of the war file (getHudsonWar) would require updating this method. Example: if backup naming or atomic replace semantics change, this method must be adapted.

5. Summary Judgment:
- Yes — this file contains methods (notably get() and rewriteHudsonWar) that call many methods and whose calls are concentrated in a few provider classes (Jenkins/SystemProperties/Functions and File/FileUtils respectively), indicating symptoms of Intensive Coupling."
MarkdownWebServerPlugin.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- readSource(File) — calls FileReader, BufferedReader, reader.readLine, StringBuilder.append, reader.close, LOG.log, fileReader.close, etc.
- serveFile(String, Map, IHTTPSession, File, String) — calls readSource, PegDownProcessor.markdownToHtml, String.getBytes, LOG.log, Response.newFixedLengthResponse, new ByteArrayInputStream, uses NanoHTTPD.MIME_HTML.

2. Calls Concentrated in Few Classes:
- readSource: concentrated in java.io classes (FileReader, BufferedReader) and java.lang.StringBuilder; plus Logger.
- serveFile: concentrated in PegDownProcessor (org.pegdown), Response/NanoHTTPD API (org.nanohttpd.protocols.http.response and org.nanohttpd.protocols.http), and java.lang.String / java.io.ByteArrayInputStream; plus Logger.

3. Method Complexity:
- readSource: moderate complexity — try/catch/finally, do-while loop and multiple resource-close calls, but shallow nesting.
- serveFile: low complexity — single try/catch around encoding conversion and a ternary return, shallow control flow.

4. Potential Fragility:
- Yes. Examples:
  - If PegDownProcessor.markdownToHtml changes return type, throws different exceptions, or changes behavior, serveFile must change.
  - If Response.newFixedLengthResponse signature or expected parameters change, serveFile must be updated.
  - If encoding expectations change (getBytes(""UTF-8"") removed/altered), serveFile behavior changes.
  - If FileReader/BufferedReader usage or exception behavior changed (unlikely in core Java, but conceptually), readSource would need updates.

5. Summary Judgment:
- Yes — readSource and serveFile exhibit calls concentrated in a small set of provider classes (java.io and PegDownProcessor/Response/NanoHTTPD respectively), which are symptoms consistent with Intensive Coupling."
EsProductServiceImpl.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- search(String keyword, Long brandId, Long productCategoryId, Integer pageNum, Integer pageSize, Integer sort)
- recommend(Long id, Integer pageNum, Integer pageSize)
- searchRelatedInfo(String keyword)
- convertProductRelatedInfo(SearchHits<EsProduct> response)
(also importAll(), create(...), delete(List<Long>) call several repository/dao methods but are simpler)

2. Calls Concentrated in Few Classes:
- The heavy-call methods are mainly concentrated around Elasticsearch-related providers and the local DAO/repository:
  - org.elasticsearch.index.query.QueryBuilders / functionscore classes (QueryBuilders, FunctionScoreQueryBuilder, ScoreFunctionBuilders)
  - org.springframework.data.elasticsearch.core.query.NativeSearchQueryBuilder / NativeSearchQuery
  - org.elasticsearch.search.sort.SortBuilders
  - org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate, SearchHits, SearchHit
  - org.elasticsearch.search.aggregations.* classes (Aggregation, ParsedNested, ParsedFilter, ParsedLongTerms, ParsedStringTerms, Terms) — mostly used in convertProductRelatedInfo
  - Local providers: EsProductDao (productDao) and EsProductRepository (productRepository)

3. Method Complexity:
- search(..., sort): moderate complexity — several conditional branches (filter building, keyword present/absent, multiple sort branches) and array/list conversions.
- recommend(...): moderate complexity — conditional on DAO result, builds multiple query functions, filter, pageable; similar structure to search.
- searchRelatedInfo(...): low-to-moderate complexity — builds aggregations and executes search.
- convertProductRelatedInfo(...): moderate complexity — nested aggregation traversal, multiple loops and casts to various aggregation types.

4. Potential Fragility:
- Yes. Because calls are concentrated in Elasticsearch APIs and in DAO/repository, changes in those providers would likely require changes here. Examples:
  - If QueryBuilders or FunctionScoreQueryBuilder APIs change (signatures, builders, or score handling), both search() and recommend() must be updated.
  - If Elasticsearch aggregation classes or the structure of returned aggregations change (e.g., different aggregation names/types or different method names for getting buckets/keys), convertProductRelatedInfo() will break and need updates.
  - If ElasticsearchRestTemplate.search() or SearchHits APIs (e.g., getTotalHits(), stream()/getContent()) change, several methods will break.
  - If EsProductDao.getAllEsProductList(...) changes return shape, recommend/create would be affected.

5. Summary Judgment:
- Yes — the file contains multiple methods that call many methods concentrated in a few provider classes (primarily Elasticsearch-related classes and the local DAO/repository), which are symptoms of Intensive Coupling."
ProjectExportWizard.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- exportProjects(...)
- exportResourceTree(...)
- exportProject(...)
- (also getChildCount(...) and performFinish(...) call multiple methods but to a lesser extent)

2. Calls Concentrated in Few Classes:
- Yes. Many calls are concentrated on:
  - ProjectExportData (especially its fields: meta and archiveStream)
  - XMLBuilder (exportData.meta.startElement/addAttribute/endElement/flush)
  - ZipOutputStream / ZipEntry (exportData.archiveStream.putNextEntry/closeEntry/finish)
  - IResource / IContainer / IFile (members(), isLinked(), getContents(), etc.)
  - Also repeated use of IOUtils and DBRProgressMonitor (monitor.beginTask/subTask/worked)

3. Method Complexity:
- exportProjects: long method with multiple loops, try/finally blocks and nested blocks (moderate complexity).
- exportResourceTree: recursive with branching (container vs file vs other) and loops over members (moderate to high complexity due to recursion).
- exportProject: moderate complexity (refresh, loop over members, calls into exportResourceTree).
- getChildCount: recursive but simple in structure.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require updates here. Examples:
  - If ProjectExportData changes (different meta/stream fields or API), many calls (startElement/addAttribute, putNextEntry/closeEntry) would need modification.
  - If XMLBuilder method names/signatures change (startElement/addAttribute/endElement/flush), exportProjects/exportResourceTree/exportProject would break.
  - If ZipOutputStream/ZipEntry usage or IOUtils.copyStream signature/behavior changes, file-writing logic would require updates.
  - If IResource/IContainer APIs (members(), isLinked(), getContents()) change, recursive traversal and file export would be affected.

5. Summary Judgment:
- Yes — this file contains methods (notably exportProjects and exportResourceTree) that call many methods concentrated in a few provider classes (ProjectExportData/XMLBuilder/ZipOutputStream and the IResource hierarchy), indicating symptoms of Intensive Coupling."
SentinelApacheHttpClientConfig.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. The file's methods (getPrefix, setPrefix, getExtractor, setExtractor, getFallback, setFallback) do not call many other methods.

2. Calls Concentrated in Few Classes:
- Not applicable (no methods with many calls). The few calls present are to:
  - AssertUtil.notNull(...)
  - default constructors / assignments of DefaultApacheHttpClientResourceExtractor and DefaultApacheHttpClientFallback
  These are concentrated in AssertUtil and the extractor/fallback classes, but the overall call count is very small.

3. Method Complexity:
- Methods are simple (single-statement getters or setters with a single null-check). No deep nesting or many conditional branches.

4. Potential Fragility:
- Low. If provider interfaces (ApacheHttpClientResourceExtractor, ApacheHttpClientFallback) change their API or are removed, this class would need updates (e.g., signature changes). Changes to AssertUtil.notNull could affect null checks here. Example: renaming the notNull method or changing its contract would require changes; adding methods to provider classes would not impact this class.

5. Summary Judgment:
- No intensive coupling detected: the methods do not call many methods concentrated in one or a few provider classes."
CachingExecutor.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
- query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) (delegates to the above)
- close(boolean forceRollback)
- commit(boolean required)
- rollback(boolean required)
- flushCacheIfRequired(MappedStatement ms)
- ensureNoOutParams(MappedStatement ms, BoundSql boundSql)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in:
  - delegate (Executor) — many calls to delegate.query, delegate.update, delegate.commit/rollback, delegate.close, etc.
  - tcm (TransactionalCacheManager) — getObject, putObject, clear, commit, rollback
  - MappedStatement / Cache / BoundSql related classes — ms.getCache(), ms.isUseCache(), ms.isFlushCacheRequired(), boundSql.getParameterMappings(), Cache operations

3. Method Complexity:
- Moderate complexity: query(...) has nested conditionals (if cache != null then if ms.isUseCache() && resultHandler == null) and exception/flow control for cache misses; ensureNoOutParams has a loop and conditional checks. No very deep nesting, but several branches and checks.

4. Potential Fragility:
- Yes. Examples:
  - If TransactionalCacheManager API changes (method names, signatures, semantics of getObject/putObject/clear/commit/rollback), the caching logic in query/close/commit/rollback/flushCacheIfRequired would need updates.
  - If Executor (delegate) interface changes (method signatures or behavior of query/update/flushStatements/etc.), multiple methods in this class must change.
  - If MappedStatement or Cache APIs change (e.g., isUseCache(), getCache(), isFlushCacheRequired(), Cache contract), query and flushCacheIfRequired would be impacted.

5. Summary Judgment:
- Based on the above, this file contains methods (notably the caching-aware query method) that call many methods concentrated in a few provider classes (delegate, TransactionalCacheManager, MappedStatement/Cache), which are symptoms of Intensive Coupling."
RedisPriorityScheduler.java,
EnablePluginCommand.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- run()
- enablePlugin(PluginManager, String)
- enableDependencies(PluginManager, PluginWrapper)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in:
  - PluginWrapper (isEnabled, getShortName, getVersion, getDependencies, enable, dependency fields)
  - PluginManager (getPlugin)
  - Jenkins (get, checkPermission, getPluginManager, safeRestart)
  - Also uses Messages (static message helpers) and stdout (printing), but the bulk of behavior depends on PluginWrapper and PluginManager.

3. Method Complexity:
- run(): low complexity (loop over pluginNames, conditional restart).
- enablePlugin(): moderate linear flow with null check, enabled check, dependency handling and side effects (printing, enabling).
- enableDependencies(): higher complexity due to recursion, loop over dependencies and conditional branching for missing/disabled dependencies.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require edits here. Examples:
  - If PluginWrapper API changes (e.g., renaming getDependencies, isEnabled, enable, or changing dependency representation), enablePlugin/enableDependencies must be updated.
  - If PluginManager.getPlugin behavior or signature changes, both enablePlugin and enableDependencies break.
  - If Jenkins methods change (getPluginManager, safeRestart, checkPermission), run would need adjustment.

5. Summary Judgment:
- Based on the above, this file contains methods that call many methods concentrated in a few provider classes (primarily PluginWrapper and PluginManager) and shows symptoms consistent with Intensive Coupling."
PoolStats.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- shouldLoad() — calls currentTime(), reloadAt.get(), reloadAt.compareAndSet(...), plusMillis(...)
- The getter methods (getTotalConnections, getIdleConnections, getActiveConnections, getPendingThreads, getMaxConnections, getMinConnections) call shouldLoad() and update().
- Constructor calls new AtomicLong().

2. Calls Concentrated in Few Classes:
- yes — calls in shouldLoad() are concentrated in:
  - com.zaxxer.hikari.util.ClockSource (currentTime, plusMillis)
  - java.util.concurrent.atomic.AtomicLong (get, compareAndSet)
- getters call the local shouldLoad() and abstract update() (provider for update() is not in this file).

3. Method Complexity:
- shouldLoad() contains a tight loop with two conditional branches (if / else if) but no deep nesting; complexity is low-to-moderate.
- getters are simple (one conditional then return).

4. Potential Fragility:
- Changes to ClockSource API or semantics (currentTime/plusMillis) would require changes in shouldLoad().
- Changes to AtomicLong behavior or signature (unlikely) or to how reloadAt is used would affect shouldLoad().
- The abstract update() means subclasses may be highly coupled to their provider classes — those subclasses (not shown) could be fragile if their providers change.

5. Summary Judgment:
- Based on this file alone, there are no methods that call many methods concentrated across one or a few provider classes in a way that indicates strong Intensive Coupling. The observable calls are few and limited to ClockSource and AtomicLong; update() implementations (outside this file) are the main unknown."
MinMaxPriorityQueue.java,
MapDeserializer.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- deserialze(DefaultJSONParser parser, Type type, Object fieldName, String format, int features)
- deserialze(DefaultJSONParser parser, Type type, Object fieldName, Map map, int features)
- parseMap(DefaultJSONParser parser, Map<String, Object> map, Type valueType, Object fieldName, int features)
- parseMap(DefaultJSONParser parser, Map<Object, Object> map, Type keyType, Type valueType, Object fieldName)

2. Calls Concentrated in Few Classes:
- Yes. Most calls in these methods are concentrated on a few provider classes:
  - JSONLexer (lexer.* calls: token(), nextToken(), getCurrent(), scanSymbol(), skipWhitespace(), next(), resetStringPosition(), stringVal(), isEnabled(), isRef(), nextTokenWithColon(), info(), etc.)
  - DefaultJSONParser (parser.* calls: parseObject(), getContext(), setContext(), popContext(), parseArray(), parseObject(valueType,...), getConfig(), checkMapResolve(), addResolveTask(), setResolveStatus(), getDateFomartPattern(), etc.)
  - ParserConfig / ObjectDeserializer (config.* and deserializer.deserialze(...) and config.getDeserializer(), config.checkAutoType(...))
  - Also repeated use of JSONToken / Feature constants and some java.util Collections utilities.

3. Method Complexity:
- Yes. The parseMap methods are complex: long loops, deep nesting, many conditional branches and special-case handling (type key detection, ref handling, different token flows). deserialze overloads also contain branching and multiple code paths.

4. Potential Fragility:
- Yes. Changes to any of the provider classes would likely require changes here or cause breakage. Examples:
  - JSONLexer API/behavior changes (token naming/semantics, scanSymbol signatures, nextToken behavior) would impact many call sites in parseMap.
  - DefaultJSONParser changes (context handling, parseObject signatures, resolve/status APIs) would affect context/pop/set calls and resolve logic.
  - ParserConfig or ObjectDeserializer contract changes (getDeserializer, deserialze signature/behavior, checkAutoType) would force updates in the deserialization flows.
  - Any change in how JSONToken/Feature flags work could alter many conditional branches.

5. Summary Judgment:
- Yes — this file contains multiple methods that call many methods and the calls are concentrated in a small set of provider classes (JSONLexer, DefaultJSONParser, ParserConfig/ObjectDeserializer), which are symptoms of Intensive Coupling."
ConversionException.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. The file only contains three simple constructors; none call many other methods.

2. Calls Concentrated in Few Classes:
- Not applicable. The constructors only delegate to superclass constructors (java.lang.Exception / java.lang.Throwable).

3. Method Complexity:
- No. The constructors are trivial, with no nesting or conditional branches.

4. Potential Fragility:
- Unlikely. Dependence is only on standard Throwable/Exception constructors; changes there are rare and would be widely impactful but would not create concentrated fragility in this class.

5. Summary Judgment:
- This file does not exhibit Intensive Coupling."
Profiler.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. This file only declares interface methods (beforeCall, afterCall) and a simple RequestInformation constructor and getters; there are no methods that invoke many other methods.

2. Calls Concentrated in Few Classes:
- Not applicable — there are essentially no method calls to analyze or provider classes being heavily used.

3. Method Complexity:
- Methods are not complex. Interface methods have no bodies; RequestInformation's constructor and getters are simple, single-statement methods with no deep nesting or conditional branches.

4. Potential Fragility:
- Low in this file. Changes to the nested RequestInformation data shape (e.g., renaming fields or removing getters) would require updating its callers/consumers. Changes to the Profiler<T> API (e.g., changing method signatures) would require updates to implementors. No concentrated dependency on a separate provider class that would cause wide impact.

5. Summary Judgment:
- This file does not contain methods that call many methods concentrated in one or a few classes, so it does not exhibit the Intensive Coupling smell."
ParentRunnerTest.java,
NumberTest.java,
TextEditorUtils.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- enableHostEditorKeyBindings(IWorkbenchPartSite, boolean)
- enableHostEditorKeyBindingsSupport(IWorkbenchPartSite, Control)
- isDarkThemeEnabled()
- getTextEditorActionMap() / FakeTextEditor.fillActionMap() (moderate number of calls)
- createFindReplaceAction(Shell, IFindReplaceTarget) (few calls but to external provider)

2. Calls Concentrated in Few Classes:
- enableHostEditorKeyBindings: concentrated on AbstractTextEditor (getAdapter, reflection on AbstractTextEditor.setActionActivation) and java.lang.reflect.Method. Also uses Control.
- enableHostEditorKeyBindingsSupport: concentrated on Control (addFocusListener, addDisposeListener) and delegates heavily to enableHostEditorKeyBindings (thus AbstractTextEditor/Method). Also depends on DBWorkbench.getPlatform().
- isDarkThemeEnabled: concentrated on PlatformUI and IThemeEngine / ITheme.
- getTextEditorActionMap / FakeTextEditor.fillActionMap: concentrated on AbstractTextEditor (ACTION_MAP and AbstractTextEditor.IdMapEntry).
- createFindReplaceAction: concentrated on ResourceBundle and FindReplaceAction.

3. Method Complexity:
- enableHostEditorKeyBindings: moderate complexity — multiple conditionals and a try/catch with reflection handling.
- enableHostEditorKeyBindingsSupport: moderate complexity — nested anonymous FocusListener methods and a dispose listener lambda, state tracking via activated[].
- isDarkThemeEnabled: simple but has nested null checks.
- getTextEditorActionMap and createFindReplaceAction: low complexity.

4. Potential Fragility:
- Changes to AbstractTextEditor (e.g., rename/remove setActionActivation, change ACTION_MAP structure or IdMapEntry API) would break enableHostEditorKeyBindings and FakeTextEditor.fillActionMap and require updates.
- Changes to Control listener APIs or disposal semantics could require changes in enableHostEditorKeyBindingsSupport.
- Changes to PlatformUI/IThemeEngine/ITheme (service lookup or theme id naming) would impact isDarkThemeEnabled.
- Changes in DBWorkbench.getPlatform() or isShuttingDown behavior could affect cleanup logic in enableHostEditorKeyBindingsSupport.
Examples: removing or renaming AbstractTextEditor.setActionActivation would cause reflection invoke to fail; changing AbstractTextEditor.ACTION_MAP layout or entry methods would break fillActionMap.

5. Summary Judgment:
Yes — this file contains methods (notably enableHostEditorKeyBindings and enableHostEditorKeyBindingsSupport, plus FakeTextEditor.fillActionMap) that call many methods concentrated in a small set of provider classes (AbstractTextEditor, Control, PlatformUI/IThemeEngine, DBWorkbench), exhibiting symptoms of Intensive Coupling."
PageResult.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method in this file calls many other methods. The only methods that call any external methods are:
  - PageResult(int page, int pageSize) — calls ArrayList(super) and Math.max(...)
  - PageResult(int page, int pageSize, int total) — delegates to this(...) and calls PageUtil.totalPage(...)
  - isFirst() — calls PageUtil.getFirstPageNo()
  - (Implicitly constructors call the superclass ArrayList constructor)

2. Calls Concentrated in Few Classes:
- The small number of external calls are concentrated in a few classes:
  - cn.hutool.core.util.PageUtil (totalPage, getFirstPageNo)
  - java.lang.Math (max)
  - cn.hutool.db.Page (DEFAULT_PAGE_SIZE constant)
  - java.util.ArrayList (super constructor)
- Primary provider of logic here is PageUtil.

3. Method Complexity:
- Methods are simple: no deep nesting, only simple conditionals/ternary and straightforward assignments. Overall low complexity.

4. Potential Fragility:
- Changes to the few provider classes used could require limited updates:
  - If PageUtil.totalPage(...) or PageUtil.getFirstPageNo() change signature or semantics, constructors/isFirst would need updating.
  - If Page.DEFAULT_PAGE_SIZE constant is removed/renamed, constructors would need change.
- Impact is localized to a few small methods rather than widespread.

5. Summary Judgment:
- Based on the above, this file does not exhibit Intensive Coupling (methods do not call many methods concentrated in a few provider classes)."
HikariPool.java,
SMSParsedResult.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- getSMSURI() — performs many StringBuilder.append(...) calls and uses array access and conditionals.
- getDisplayResult() — calls maybeAppend(...) multiple times and constructs a StringBuilder.
- (Constructors and getters call a few methods like super(...) or return fields, but not many.)

2. Calls Concentrated in Few Classes:
- Yes, the calls in these methods are concentrated mainly in:
  - java.lang.StringBuilder (append, constructor, toString)
  - com.google.zxing.client.result.ParsedResult (maybeAppend — superclass)
  - core language features (array accesses, String returns)
- There are not many different provider classes involved.

3. Method Complexity:
- getSMSURI(): moderate complexity — one loop and several conditionals (if/else, nested if for vias/subject/body), but not deep nesting.
- getDisplayResult(): low complexity — three calls to maybeAppend, simple flow.

4. Potential Fragility:
- Changes to ParsedResult.maybeAppend (signature/behavior) would require changes to getDisplayResult.
- Changes to the expected layout of numbers/vias arrays (lengths or indexing assumptions) would impact getSMSURI.
- Changes to how body/subject should be encoded or delimited would require modifications to getSMSURI.
- Changes to standard StringBuilder APIs are unlikely but would affect both methods.

5. Summary Judgment:
- Overall, while some methods make many calls, those calls are mainly to a very small set of stable classes (StringBuilder and the superclass). This file does not exhibit strong symptoms of Intensive Coupling that would indicate a problematic dependency on multiple provider classes."
AnnotationScanner.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- None. This file is an interface with three method declarations (getScanAnnotation, addListener, validate) and contains no method bodies or calls.

2. Calls Concentrated in Few Classes:
- Not applicable — there are no call sites in this file. (The signatures reference Namespace, Method, Annotation, Class, but no calls are made here.)

3. Method Complexity:
- Methods are simple declarations with no nesting or conditional branches.

4. Potential Fragility:
- Low within this file itself because it has no implementations or calls. (Implementations of these methods elsewhere could be fragile if they depend heavily on specific provider classes like Namespace, but that is outside this file.)

5. Summary Judgment:
- This file does not contain methods that call many methods concentrated in one or a few classes, so it does not exhibit Intensive Coupling."
easyexcel-2.2.11_ExcelDataConvertException.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. The file contains two constructors and simple getters/setters; none call many other methods.

2. Calls Concentrated in Few Classes:
- Not applicable (no heavy calling). The only external calls are to the superclass constructors (java.lang.RuntimeException) via super(...). The class references CellData and ExcelContentProperty only as field types / parameters.

3. Method Complexity:
- Methods are simple, no deep nesting or multiple conditional branches.

4. Potential Fragility:
- Low. Changes in provider classes (CellData, ExcelContentProperty) could require recompilation or signature updates if their types or package names change, but they are only stored/referenced here — this class does not depend on their internal APIs. Example: renaming ExcelContentProperty would require updating imports; changing its internals would not force changes in this exception class.

5. Summary Judgment:
- This file does not contain methods that call many methods concentrated in one or a few classes; therefore it does not exhibit Intensive Coupling."
Connection.java,
CameraInputController.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- update()
- process(float deltaX, float deltaY, int button)
- zoom(float amount)
- touchDragged(int screenX, int screenY, int pointer)
- CameraGestureListener.zoom(float initialDistance, float distance)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in:
  - com.badlogic.gdx.graphics.Camera (rotate, translate, rotateAround, update, fields direction/up)
  - com.badlogic.gdx.math.Vector3 (set, crs, nor, scl, add — tmpV1, tmpV2, target)
  - com.badlogic.gdx.Gdx.graphics (getDeltaTime, getWidth, getHeight)
  - (secondary) GestureDetector / GestureAdapter super calls

3. Method Complexity:
- update(): moderate complexity — several conditional branches (if rotateRightPressed / rotateLeftPressed / forwardPressed / backwardPressed) and vector operations.
- process(...): moderate complexity — if/else chain handling three interaction modes, multiple vector math chains and updates.
- touchDragged(): simple control flow but computes normalized deltas and delegates to process.
- zoom(): simple but performs conditional guard and multiple provider calls.
- CameraGestureListener.zoom(): simple arithmetic and a Gdx.graphics size lookup then delegation.
- Overall no extremely deep nesting, but multiple conditional branches and chained vector operations produce moderate complexity.

4. Potential Fragility:
- Yes. If Camera API changes (method names, signatures, or public fields direction/up), methods like update(), process(), zoom() and touchDragged() would need updates. Example: rename or change signature of Camera.rotateAround or Camera.translate would break update() and process().
- If Vector3 method chaining semantics or method names (set, crs, nor, scl, add) change, many vector expressions in process() and update() must be updated.
- If Gdx.graphics API for getWidth/getHeight/getDeltaTime changes, CameraGestureListener.zoom(), touchDragged(), update() would be affected.
- Changes in how input pointers/bitmasking works would require touchDown/touchUp adjustments.

5. Summary Judgment:
- Yes — this file contains methods (notably update() and process()) that call many methods concentrated primarily on Camera and Vector3 (plus Gdx.graphics), which are symptoms consistent with Intensive Coupling."
WebLogAspect.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- doAround(ProceedingJoinPoint)
- getParameter(Method, Object[])

2. Calls Concentrated in Few Classes:
- Yes. The calls are largely concentrated in:
  - com.macro.mall.common.domain.WebLog (many setX(...) calls)
  - javax.servlet.http.HttpServletRequest (getRequestURL, getRemoteUser, getRemoteAddr, getMethod, getRequestURI, ...)
  - org.aspectj.lang.ProceedingJoinPoint / JoinPoint / MethodSignature / java.lang.reflect.Method (proceed, getSignature, getMethod, isAnnotationPresent, getAnnotation)
  - Secondary providers: cn.hutool.core.util.StrUtil and URLUtil, cn.hutool.json.JSONUtil, net.logstash.logback.marker.Markers, org.slf4j.Logger

3. Method Complexity:
- doAround: moderate linear flow with a small conditional (annotation check) and map-building; no deep nesting.
- getParameter: simple loop with conditional branches per parameter; no deep nesting.

4. Potential Fragility:
- Changes to WebLog (renamed/removed setters or changed structure) would require edits to doAround where many setters are called.
- Changes to HttpServletRequest API or expectations (e.g., request URL/URI methods or nullability of RequestContextHolder.getRequestAttributes()) could cause failures or require changes.
- Changes in aspect/reflect APIs (joinPoint.proceed, signature/method/annotation behavior) would impact doAround.
- Changes in utility/logging APIs (JSONUtil, Markers, LOGGER) could alter logging behavior and require updates.

5. Summary Judgment:
- Yes — doAround (and to a lesser extent getParameter) call many methods concentrated in a few provider classes (notably WebLog and HttpServletRequest), so the file exhibits symptoms consistent with Intensive Coupling."
ComparisonCriteria.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- private void arrayEquals(String message, Object expecteds, Object actuals, boolean outer)
- public void arrayEquals(String message, Object expecteds, Object actuals) (wrapper)
- private Object getToStringableArrayElement(Object array, int length, int index)
- private String componentTypeName(Class<?> arrayClass)
(among these, the private arrayEquals is the main method calling many other methods)

2. Calls Concentrated in Few Classes:
- java.lang.reflect.Array (Array.getLength, Array.get, Array.getLength again)
- org.junit.Assert (Assert.fail, Assert.assertEquals)
- java.util.Arrays (Arrays.deepEquals)
- java.lang.Class (getComponentType, isArray via getClass().isArray)
- plus internal types in the same package (ArrayComparisonFailure construction/handling)
Most calls in the complex method are to Array.*, Assert.*, and Arrays.* (and some Class methods).

3. Method Complexity:
- The private arrayEquals is fairly complex: loop over array elements, nested ifs, recursion (calls itself), try/catch blocks, and special-case handling for differing lengths. componentTypeName is recursive; getToStringableArrayElement has branching. Overall there is deep nesting and multiple conditional branches.

4. Potential Fragility:
- Yes. Changes in provider classes or their APIs/semantics would likely require changes here. Examples:
  - If java.lang.reflect.Array behavior or signature changed (Array.get/Array.getLength), array traversal logic would be affected.
  - If org.junit.Assert.assertEquals / Assert.fail signatures or exception behavior changed, the failure-reporting code would need updates.
  - If Arrays.deepEquals semantics changed, the shortcut check and consequent control flow could be impacted.
  - Changes to ArrayComparisonFailure constructors or expected exception behavior would force changes to how errors are wrapped/thrown.

5. Summary Judgment:
- Yes — this file contains methods (notably the private arrayEquals) that call many methods and concentrate those calls in a few provider classes, which matches symptoms of Intensive Coupling."
CodeCacheEventWalker.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- visit(IMetaMember metaMember)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated on:
  - org.adoptopenjdk.jitwatch.model.Compilation (isFailed, getNativeAddress, getStampTaskCompilationStart, getNativeSize, etc.)
  - IMetaMember (isCompiled, getCompilations)
  - CodeCacheEvent and CodeCacheWalkerResult (construction, setNativeAddress, setCompilation, addEvent)
  - (secondary: java.lang.String and java.lang.Long utility methods, and Logger)

3. Method Complexity:
- Moderate complexity: null check + isCompiled check, loop over compilations, conditional continue, try/catch for parsing, nested ifs for address handling — some branching but not deeply nested.

4. Potential Fragility:
- Yes. Changes to the Compilation API or how native addresses/sizes/stamps are represented would likely require changes here (e.g., renaming/removing getNativeAddress/getNativeSize/getStampTaskCompilationStart, changing address format). Changes to CodeCacheEvent or result.addEvent signatures would also impact this method.

5. Summary Judgment:
- This file contains a method (visit) that calls many methods concentrated in a few provider classes (primarily Compilation and related model classes), so it exhibits symptoms of Intensive Coupling."
Dictionary.java,
SmartContentSelector.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- select(String html) — this method contains many method calls (replaceAll, split, Arrays.asList, List.get/set, String.length, ArrayList.add, StringBuilder methods, Integer.intValue, String.contains, etc.).
- selectList(String text) — only throws UnsupportedOperationException (no significant calls).

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in a few core provider classes:
  - java.lang.String (replaceAll, split, replaceAll again, length, contains, toString)
  - java.lang.StringBuilder (setLength, append, toString)
  - java.util.Arrays / java.util.List / java.util.ArrayList (asList, split result handling, get, set, add)
  - java.lang.Integer (intValue on boxed integers from the list)

3. Method Complexity:
- Moderate complexity: nested loops (outer loop over lines, inner loop over blocksWidth, another loop for assembling ranges), multiple conditional branches and boolean flag state (boolstart, boolend), some continue logic. No extreme nesting depth but nontrivial control flow.

4. Potential Fragility:
- Yes. Changes in any of the concentrated provider behaviors would likely require changes here. Examples:
  - Changes to how String.replaceAll / regex are interpreted (or switching to a different HTML cleaning approach) would require modifying many regex calls in this method.
  - Changing how split/Arrays.asList returns/handles line endings or blank lines would affect indexDistribution logic and require updates.
  - Replacing the List implementation or changing assumptions about boxing/unboxing of Integer values (intValue usage) could require adjustments.
  - Any change in expected behavior of StringBuilder or String methods used for trimming/concatenation would impact the output assembly.

5. Summary Judgment:
- Yes — the select(String) method calls many methods and those calls are concentrated in a small set of provider classes (String, StringBuilder, List/ArrayList, Arrays, Integer), which matches symptoms of Intensive Coupling."
Faker.java,
ConstructorConstructor.java,
StatisticSlot.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- entry(...)
- exit(...)
- recordCompleteFor(...)

2. Calls Concentrated in Few Classes:
- Yes. Most calls target a few provider classes/components:
  - Node / DefaultNode / ClusterNode (node.increaseThreadNum, addPassRequest, increaseBlockQps, addRtAndSuccess, decreaseThreadNum, increaseExceptionQps, etc.)
  - Context / Entry (context.getCurEntry(), getOriginNode(), setBlockError, setError, setCompleteTimestamp, getCreateTimestamp, getCurNode())
  - StatisticSlotCallbackRegistry and callback interfaces (getEntryCallbacks/getExitCallbacks, handler.onPass/onBlocked/onExit)
  - ResourceWrapper / EntryType checks and Constants.ENTRY_NODE (global entry node)
  - plus a few utility/base calls (TimeUtil.currentTimeMillis(), fireEntry/fireExit)

3. Method Complexity:
- entry(...) is moderately complex: try-catch with multiple catch blocks, repeated conditional checks (origin node and entry type), and loops over callbacks.
- exit(...) has conditional branches and a loop over exit callbacks.
- recordCompleteFor(...) is simple and short.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require changes here. Examples:
  - If Node/DefaultNode API changes (method names, signatures, or semantics like addPassRequest/increaseBlockQps/addRtAndSuccess), entry/exit/recordCompleteFor must be updated.
  - If the callback registry or callback interfaces change (different callback methods or signatures), the loops invoking handler.onPass/onBlocked/onExit must change.
  - If ResourceWrapper/EntryType behavior or Constants.ENTRY_NODE is modified, the conditional logic and global-stat tracking would be affected.

5. Summary Judgment:
- Based on the concentration of calls to Node/Context/StatisticSlotCallbackRegistry (and repeated direct invocations on those providers) plus the number of calls in entry/exit, this file exhibits symptoms of Intensive Coupling."
HttpConnection.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- Response.execute(HttpConnection.Request, Response)
- Response.createConnection(HttpConnection.Request)
- Response.writePost(Connection.Request, OutputStream, String)
- Response.serialiseRequestUrl(Connection.Request)
- Response.createHeaderMap(HttpURLConnection)
- Response.processResponseHeaders(Map<String, List<String>>)
- Response.parse() / prepareByteData() (moderate number of calls)

2. Calls Concentrated in Few Classes:
- Heavy focus on HttpURLConnection (conn.*) and its interaction in execute/createHeaderMap/createConnection.
- Heavy use of the local Request/Response objects (req.* and this.*).
- Repeated calls to a few utility/provider classes: DataUtil, CookieUtil (and CookieManager), StringUtil, Validate, Parser.
- Secondary providers: ConstrainableInputStream, GZIPInputStream / InflaterInputStream, URLEncoder, TokenQueue.

3. Method Complexity:
- Yes. Response.execute is large and complex: deep nesting, multiple conditional branches (redirect handling, status checks, content-type checks), try/catch/finally, recursion for redirects.
- createConnection, writePost and serialiseRequestUrl have multiple branches and loops (multipart vs url-encoding, stream handling).

4. Potential Fragility:
- Yes. Changes to any of the main provider classes would likely require changes here or cause breakage. Examples:
  - If HttpURLConnection behavior or method names/signatures change (request/response methods, header accessors), createConnection/createHeaderMap/execute would need updates.
  - If DataUtil changes buffering, charset detection, or stream helpers, execute/prepareByteData/parse/writePost would be affected.
  - If CookieUtil or CookieManager APIs change, cookie application/storage calls in createConnection/processResponseHeaders would break.
  - If Parser API or Parser.newInstance behavior changes, Request.parser handling and Response.parse would be impacted.

5. Summary Judgment:
- Yes — the file contains methods (notably Response.execute) that call many methods and concentrate those calls primarily on a small set of provider classes (HttpURLConnection, the local Request/Response, DataUtil/CookieUtil/etc.), which are symptoms consistent with Intensive Coupling."
FireBirdMetaModel.java,
PendingEntry.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. This file contains a simple constructor and four getters (getId, getConsumerName, getIdleTime, getLastTimeDelivered). They do not call other methods (aside from the implicit super() in the constructor).

2. Calls Concentrated in Few Classes:
- Not applicable. There are essentially no method calls to concentrate. The class references the StreamMessageId type but does not invoke its methods.

3. Method Complexity:
- The methods are not complex: no nesting, no conditional branches, and trivial logic (field assignments and returns).

4. Potential Fragility:
- Low. The class is a simple data holder; the only potential fragility is if the referenced type StreamMessageId changes its API or is removed, which could cause compilation/usage issues, but the methods here would require minimal changes.

5. Summary Judgment:
- This file does not exhibit Intensive Coupling."
Location.java,
Evaluator.java,
JsonAdapterAnnotationTypeAdapterFactory.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- create(Gson, TypeToken<T>)
- getTypeAdapter(ConstructorConstructor, Gson, TypeToken<?>, JsonAdapter)
- (constructor is trivial; other methods are small)

2. Calls Concentrated in Few Classes:
- Yes, the calls are concentrated mainly around a few provider types:
  - ConstructorConstructor (get(...).construct())
  - TypeAdapter / TypeAdapterFactory (instanceof checks, factory.create(...), typeAdapter.nullSafe())
  - TreeTypeAdapter (constructor)
  - JsonSerializer / JsonDeserializer (instance checks/casts)
  - Also uses TypeToken and Class reflection (getRawType(), getAnnotation())

3. Method Complexity:
- getTypeAdapter has moderate complexity: a single if/else-if chain with several instanceof branches and some casts but no deep nesting or many conditional layers.
- create is simple and delegates to getTypeAdapter.

4. Potential Fragility:
- Yes, changes in the small set of provider classes would likely require changes here. Examples:
  - If ConstructorConstructor.get(...) or construct() signatures/behavior change, getTypeAdapter must be updated.
  - If TypeAdapterFactory.create(...) contract changes, the branch using the factory must change.
  - If TreeTypeAdapter construction or TypeAdapter.nullSafe() semantics change, adjustments here would be needed.
  - Changes to the @JsonAdapter handling (annotation.value() type) would also affect this method.

5. Summary Judgment:
- While the file depends on a few provider classes, the methods do not call a large number of disparate methods; calls are limited and the logic is straightforward. Therefore this file does not exhibit clear Intensive Coupling."
DriverDataSource.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- DriverDataSource(...) (the constructor) — calls many methods.
- getConnection(String, String) — calls several methods (clone, put, containsKey, driver.connect).
(Other methods call few methods only: getConnection(), getParentLogger(), set/getLoginTimeout() delegate to Driver/DriverManager.)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in:
  - java.sql.Driver / DriverManager (driver.connect, DriverManager.getDriver, getDrivers, setLoginTimeout, getLoginTimeout)
  - java.lang.ClassLoader / java.lang.Thread (loadClass, getContextClassLoader)
  - java.util.Properties (setProperty, put, getProperty, clone, containsKey)
  - org.slf4j.Logger (debug, warn)
  - java.lang.Class / reflection APIs (getDeclaredConstructor, newInstance)
These are the primary provider classes the constructor and getConnection(String,String) depend on.

3. Method Complexity:
- The constructor is fairly complex: loops, nested ifs, multiple try/catch blocks and fallbacks, string sanitization, and several conditional branches.
- getConnection(String,String) has moderate complexity with cloning and conditional property manipulation.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require changes here or cause impact. Examples:
  - Changes to Driver/DriverManager API/behavior (acceptsURL, connect, DriverManager.getDriver/getDrivers) would affect constructor and getConnection.
  - Changes in class-loading semantics or inability to instantiate driver via reflection would break driver resolution logic.
  - Changes to expected Properties keys (user/password/username) would affect credential passing.
  - If driver constructors/initialization throw different exceptions, the fallback/handling here may need updating.

5. Summary Judgment:
- There are clear symptoms of Intensive Coupling: the constructor (and to a lesser extent getConnection(String,String)) call many methods concentrated in a few provider classes (Driver/DriverManager, ClassLoader, Properties, Logger), and are moderately complex and potentially fragile."
AbstractMetaMember.java,
ParentRunner.java,
OmsPortalOrderServiceImpl.java,
JUnitCommandLineParseResult.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- parseOptions
- createRequest
- applyFilterSpecs
- parseParameters (moderately)

2. Calls Concentrated in Few Classes:
- createRequest / applyFilterSpecs: most external calls are to Request (Request.classes, request.filterWith, Request.errorReport) and to the filter factory (FilterFactories.createFilterFromFilterSpec / Filter).  
- parseParameters: concentrated on Classes (Classes.getClass).  
- parseOptions: mostly String APIs and local collections (less concentrated on an external provider class).

3. Method Complexity:
- parseOptions: moderate complexity — loop with nested if/else branches and an inner conditional for the ""--filter"" option.  
- applyFilterSpecs: moderate — loop + try/catch.  
- createRequest: simple conditional flow.  
- parseParameters / copyArray: straightforward.

4. Potential Fragility:
- If Request API changes (e.g., Request.classes signature or request.filterWith behavior), createRequest and applyFilterSpecs would need updates and tests — likely breaking or requiring adaptation.  
- If FilterFactories.createFilterFromFilterSpec changes signature or exception behavior, applyFilterSpecs must change.  
- If Classes.getClass changes or is removed, parseParameters will break.  
- These examples show a single provider change could force edits in these methods.

5. Summary Judgment:
- Yes. There are methods (notably createRequest and applyFilterSpecs, and to a lesser extent parseParameters) that concentrate calls on a small set of provider classes (Request, FilterFactories, Classes), which are symptoms consistent with Intensive Coupling."
ClassReader.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- ClassReader(InputStream, boolean) constructor
- accept(TypeCollector)
- readMethod(TypeCollector, char[], int)
- readUTF8(int, char[])
- readUTF(int, int, char[])

2. Calls Concentrated in Few Classes:
- Not concentrated in a single external provider. Calls are mostly to:
  - private helpers in the same class (readUnsignedShort, readInt, readUTF8, readMethod, readUTF)
  - TypeCollector (visitAnnotation, visitMethod)
  - MethodCollector (visitLocalVariable)
  - standard library IO classes used in the constructor (InputStream.read/close, ByteArrayOutputStream.write/toByteArray)
So external provider calls are limited to a few small interfaces/classes (TypeCollector, MethodCollector, and standard IO).

3. Method Complexity:
- Yes. accept and readMethod contain multiple nested loops and conditional branches. readUTF implements a small state machine (switch/states). The constructor and getAttributes also have loops over binary structures.

4. Potential Fragility:
- Changes to TypeCollector or MethodCollector (e.g., changing visitAnnotation/visitMethod/visitLocalVariable signatures or semantics) would require updating accept/readMethod.
- Changes to binary layout assumptions (constant pool structure, attribute formats) would require changing many read* helpers and the parsing loops (constructor, getAttributes, accept, readMethod).
- Changes to how strings are encoded/read would impact readUTF/readUTF8 and cascade to callers.

5. Summary Judgment:
- Although several methods call many other methods, those calls are primarily to internal helpers and a small number of external interfaces (TypeCollector, MethodCollector, Java IO). Therefore this file does not exhibit a clear Intensive Coupling smell (many calls concentrated in one external provider class)."
XxlJobExecutor.java,
InPacketHandler.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- channelRead0(...) — yes, it calls many other methods.
- exceptionCaught(...) — a couple of calls (exceptionListener.exceptionCaught, super.exceptionCaught).

2. Calls Concentrated in Few Classes:
- The calls in channelRead0 are spread across several provider classes rather than concentrated in one:
  - PacketDecoder (decoder.decodePackets)
  - NamespacesHub (namespacesHub.get)
  - ClientHead / client (getSessionId, send, addNamespaceClient, getChildClient)
  - Packet / Packet API (hasAttachments, isAttachmentsLoaded, getNsp, getSubType, setters)
  - PacketListener (packetListener.onPacket)
  - ByteBuf / Netty (isReadable, toString)
  - Logger (log.trace/debug/error)
  - Namespace / NamespaceClient usage
- Conclusion: not concentrated in a single/few provider classes.

3. Method Complexity:
- channelRead0 has moderate complexity: a while loop, try-catch, and a sequence of conditional branches (several if checks). Nesting depth is shallow to moderate (no deep recursion or many nested levels).

4. Potential Fragility:
- Yes — changes in provider classes would require changes here. Examples:
  - If PacketDecoder.decodePackets signature/behavior changes, channelRead0 must adapt.
  - If NamespacesHub.get or Namespace lifecycle changes, error handling and connect flow here would need updates.
  - If ClientHead (client) API changes (send, addNamespaceClient, getChildClient, getSessionId), this method must change.
  - If Packet or PacketListener APIs change (new methods, renamed methods, different attachment handling), this code will break or need modification.

5. Summary Judgment:
- This file contains a method (channelRead0) that calls many methods, but those calls are distributed across multiple provider classes rather than being heavily concentrated in one or very few classes. Therefore it does not present a clear case of Intensive Coupling."
ConstrainableInputStream.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- read(byte[] b, int off, int len) — calls several helpers/APIs (Thread.interrupted(), expired(), super.read(...), and catches SocketTimeoutException).
- readToByteBuffer(int max) — calls read(byte[]), ByteArrayOutputStream.write(...), ByteBuffer.wrap(...), Validate.isTrue(...).
- reset(), timeout(...), expired() call only one or two methods each.

2. Calls Concentrated in Few Classes:
- No single method’s calls are heavily concentrated in a single provider class. The calls are spread across:
  - java.io.BufferedInputStream / java.io.InputStream (super.read, super.reset, constructor)
  - java.lang.Thread, java.lang.System (interrupted(), nanoTime())
  - java.io.ByteArrayOutputStream, java.nio.ByteBuffer
  - org.jsoup.helper.Validate
  - java.net.SocketTimeoutException (exception handling)
  - the ConstrainableInputStream itself (read(byte[]) -> loop)
So calls are distributed among several standard/JDK classes and one internal helper, not concentrated in one/few provider classes.

3. Method Complexity:
- read(...) — moderate complexity: a sequence of guard conditionals, a try/catch; not deeply nested.
- readToByteBuffer(...) — moderate complexity: a loop with conditionals to enforce a local cap; not deeply nested.
- Overall methods are straightforward, no deep nesting or excessive branching.

4. Potential Fragility:
- Changes in provider classes could require edits: e.g.,
  - If BufferedInputStream / InputStream read/reset semantics change (including how markpos is exposed/used), read(...) or reset() may need updates.
  - If SocketTimeoutException handling semantics change, read(...) behavior could be affected.
  - If ByteArrayOutputStream or ByteBuffer APIs/behavior change, readToByteBuffer(...) would need modification.
  - If org.jsoup.helper.Validate contract changes, constructors and readToByteBuffer validation could be impacted.
- However, these are standard/JDK or internal small helpers — the code is dependent on a few APIs but not tightly coupled to a single custom provider class.

5. Summary Judgment:
- Based on this file alone, there are no clear instances of Intensive Coupling: methods call multiple APIs, but the calls are not concentrated in one or a very small set of provider classes."
AndroidGL20.java,
SaJwtUtil.java,
Code.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- isbnRegistrant()
- isbn10(boolean)
- isbn13(boolean)
- isbn10CheckDigit(CharSequence)
- isbn13CheckDigit(CharSequence)
- imei()
- gtin8()
- gtin13()

2. Calls Concentrated in Few Classes:
- Yes — most calls are concentrated on the faker instance and its provider methods (Faker and its sub-providers: faker.number(), faker.random(), faker.options(), faker.expression()/regexify()/resolve()). A smaller set of utility/provider classes used repeatedly: java.lang.Character, org.apache.commons.lang3.ArrayUtils, and org.apache.commons.lang3.math.NumberUtils.

3. Method Complexity:
- isbnRegistrant(): moderate branching (switch with 6 cases).
- imei(): moderate complexity (loops with conditional logic for Luhn checksum).
- isbn10CheckDigit / isbn13CheckDigit / gtin8 / gtin13: loops with arithmetic but no deep nesting.
- isbn10(boolean) / isbn13(boolean): simple construction plus calls to helper methods.
Overall: moderate complexity (loops and a multi-case switch), but not deeply nested.

4. Potential Fragility:
- Yes. Many methods delegate heavily to Faker and its providers. If Faker API or provider behaviors change (e.g., number().digits(), numberBetween(), expression()/regexify()/resolve(), options().option()), these methods would likely need updates.
  - Example: changing the return type or semantics of faker.number().digits() or faker.expression() would require adjusting isbnRegistrant(), isbn10(), isbn13().
  - Example: changes to options().option(...) or to the set of REPORTING_BODY_IDENTIFIERS would affect imei().
  - Changes in utility behavior (ArrayUtils.add or NumberUtils.toInt) could affect gtin8/gtin13 and checksum methods.

5. Summary Judgment:
- Yes — this file contains multiple methods that call many methods concentrated in one primary provider (the Faker instance and its sub-providers), indicating symptoms of Intensive Coupling."
HomeController.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- rest()
- feign() (calls fewer methods but still performs multiple external calls)

2. Calls Concentrated in Few Classes:
- rest(): calls are concentrated around RestTemplate and several HTTP-related framework classes (RestTemplate, HttpHeaders, MediaType, LinkedMultiValueMap, HttpEntity, ResponseEntity).
- feign(): calls are concentrated in two provider classes: StorageService and OrderService.

3. Method Complexity:
- rest(): moderate complexity — contains conditional checks, a try-catch block, and multiple steps for constructing request objects (some nesting and branching).
- feign(): low complexity — simple sequential calls with conditional checks.

4. Potential Fragility:
- Changes to RestTemplate API, or to how HTTP request/response objects (HttpHeaders, HttpEntity, MediaType, ResponseEntity, LinkedMultiValueMap) work would require updating rest().
- Changes to StorageService.storage(...) or OrderService.order(...) signatures or behavior would require changes to feign() (and likely callers), causing ripple effects.
- Example: renaming or changing parameters of order(...) would force edits in feign(); changing RestTemplate.postForEntity/getForObject behavior or endpoint formats would force edits in rest().

5. Summary Judgment:
- Yes — the file contains methods (notably feign() and rest()) that call multiple methods concentrated in a few provider classes, so it exhibits symptoms of Intensive Coupling."
NacosWatch.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- start()
- stop() (non-Runnable) and stop(Runnable) call several external methods (stop(Runnable) delegates to stop()) — but start() is the primary method calling many methods.

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in:
  - NacosDiscoveryProperties (properties.getNacosProperties(), getService(), getGroup(), getClusterName(), getIp(), getPort(), getMetadata(), setMetadata())
  - NamingService (subscribe(...), unsubscribe(...))
  - NacosServiceManager (getNamingService(...))
  - ApplicationEventPublisher (publishEvent(...))
  - (secondary: listenerMap/Map, AtomicBoolean/AtomicLong, Arrays)

3. Method Complexity:
- start() is moderately complex: uses computeIfAbsent with an anonymous EventListener, contains instanceof check, stream/select logic with Optional.ifPresent (nested lambda), and a try-catch around subscribe. Nesting depth is modest but multiple conditional branches and callbacks exist.
- stop() is simple to moderate (retrieve namingService and unsubscribe with try-catch).
- Other methods are simple (buildKey, resetIfNeeded, selectCurrentInstance).

4. Potential Fragility:
- Yes. Changes in provider classes would likely require changes here. Examples:
  - If NacosDiscoveryProperties changes getters/setters or metadata representation, resetIfNeeded/selectCurrentInstance and many property calls in start() must change.
  - If NamingService.subscribe/unsubscribe signatures or behavior change, start()/stop() must be updated.
  - If NacosServiceManager.getNamingService changes how the service is obtained, start()/stop() must adapt.
  - Changes to ApplicationEventPublisher.publishEvent semantics would affect the heartbeat publishing in start().

5. Summary Judgment:
- The file contains a method (start()) that calls many methods concentrated in a few provider classes (primarily NacosDiscoveryProperties, NamingService, NacosServiceManager, ApplicationEventPublisher), exhibiting symptoms of Intensive Coupling."
DictSegment.java,
RocketMQMessageHandler.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- handleMessageInternal(org.springframework.messaging.Message<?>)
- start()

2. Calls Concentrated in Few Classes:
- Yes. Most calls concentrate on:
  - rocketMQTemplate (and rocketMQTemplate.getProducer() / its Producer)
  - instrumentationManager (in start)
  - producerProperties / partitioningInterceptor (in start)
  - also repeated use of headerMapper and errorMessageStrategy (fewer calls but repeated)

3. Method Complexity:
- Yes. handleMessageInternal has multiple nested try/catch blocks and conditional branches (transactional vs non-transactional, sync vs async, partitioned queue selection, delay parsing), and start() has conditional and nested try/catch logic for partition handling—both are moderately complex.

4. Potential Fragility:
- High. Examples:
  - If RocketMQTemplate API changes (method names or signatures for syncSend, asyncSend, syncSendOrderly, asyncSendOrderly, sendMessageInTransaction), handleMessageInternal must be updated.
  - If Producer API changes (getSendMsgTimeout, fetchPublishMessageQueues), start() and send logic break.
  - If headerMapper or errorMessageStrategy behavior/signature changes, header mapping or error handling must be updated.
  - If partitioningInterceptor or producerProperties semantics change, start() partition handling must change.

5. Summary Judgment:
- Yes — this file contains methods (notably handleMessageInternal and start) that call many methods concentrated mainly in RocketMQTemplate (and its Producer) and a few related provider classes, indicating symptoms of Intensive Coupling."
NacosDiscoveryProperties.java,
HtmlTreeBuilderStateTest.java,
QuotedStringTokenizer.java,
CodeCacheStage.java,
HTTPSession.java,
ParserConfig.java,
btActivatingCollisionAlgorithm.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- Constructors:
  - protected btActivatingCollisionAlgorithm(String, long, boolean) — calls super(...) and sets swigCPtr.
  - public btActivatingCollisionAlgorithm(long, boolean) — calls this(...) and construct().
- reset(long, boolean) — calls destroy(), super.reset(...), assigns swigCPtr.
- finalize() — calls destroy() and super.finalize().
- delete() — calls CollisionJNI.delete_btActivatingCollisionAlgorithm(...), assigns fields, and super.delete().
(These are the methods that invoke other methods; none call a large number of different methods.)

2. Calls Concentrated in Few Classes:
- Yes, the calls are concentrated primarily in:
  - the superclass (btCollisionAlgorithm / super.*)
  - the CollisionJNI class (native wrapper calls)
- A few calls are to local methods/fields (destroy(), construct()) which are likely in this class or super.

3. Method Complexity:
- Methods are simple and short. They contain minimal conditional logic (a few if checks like if (!destroyed) and if (swigCPtr != 0) / if (swigCMemOwn)). No deep nesting or many conditional branches.

4. Potential Fragility:
- Changes in the provider classes could require edits:
  - If CollisionJNI native method names or signatures change (e.g., delete_btActivatingCollisionAlgorithm or btActivatingCollisionAlgorithm_SWIGUpcast), delete() and constructors/reset() would break and need updates.
  - If the superclass btCollisionAlgorithm changes reset/finalize/delete contracts, the overrides here may need changes.
  - Example: removing or renaming btActivatingCollisionAlgorithm_SWIGUpcast would break the constructors/reset binding; changing ownership semantics in the superclass may require updated delete()/destroy() logic.

5. Summary Judgment:
- Based on the file, methods call a small number of methods and calls are limited to a couple of provider classes (superclass and CollisionJNI), but the overall number of calls per method is low and methods are simple. Therefore this file does not exhibit the Intensive Coupling smell."
RedissonTransactionalBucket.java,
HttpClientRequestContext.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. The file only contains simple getters and setters (getHttpUriRequest, setHttpUriRequest, getHttpClientContext, setHttpClientContext) that do not call many other methods.

2. Calls Concentrated in Few Classes:
- Not applicable. The class only holds references to two external types: org.apache.http.client.methods.HttpUriRequest and org.apache.http.client.protocol.HttpClientContext.

3. Method Complexity:
- The methods are not complex: no deep nesting, no conditional branches, just simple field accessors.

4. Potential Fragility:
- Low. If one of the provider classes changed type or package, the class would need updating (e.g., if HttpClientContext were removed or renamed), but because it does not invoke provider methods, changes inside those provider classes’ APIs are unlikely to cause widespread impact here.

5. Summary Judgment:
- This file does not contain methods that call many methods concentrated in one or a few classes; it does not exhibit Intensive Coupling."
DefaultMQAdminExtImpl.java,
Settings.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- Settings(Environment env) (constructor) — makes many calls (property constructors, env.showTrayIcon(), FXCollections.observableArrayList(...), and many addListener(...) calls).
- (Minor) save() — calls saveCmd.accept(this) when saveCmd != null (fewer calls).
- Other methods are simple getters and single-statement setters/listeners (not calling many methods).

2. Calls Concentrated in Few Classes:
- Yes. Most calls in the constructor are concentrated on JavaFX property/collection classes and related providers:
  - javafx.beans.property.* (SimpleBooleanProperty, SimpleIntegerProperty, SimpleObjectProperty, SimpleStringProperty and their addListener methods)
  - javafx.collections.ObservableList / FXCollections
  - VaultSettings (method reference VaultSettings::observables)
  - Environment (single call env.showTrayIcon())
  - Also occasional use of Consumer (saveCmd.accept)

3. Method Complexity:
- The constructor is long (many sequential statements) but not deeply nested and has no complex conditional branching — low cyclomatic complexity but high line count.
- somethingChanged and save are simple, not complex.

4. Potential Fragility:
- Yes. Changes in any of the concentrated provider classes would likely require updates here. Examples:
  - If the JavaFX property API (addListener signature or property classes) changes, the many addListener calls in the constructor must be updated.
  - If VaultSettings::observables signature or behavior changes, the FXCollections.observableArrayList(...) setup would need revision.
  - If Environment.showTrayIcon() changes or is removed, the showTrayIcon initialization would break.
  - If the saveCmd contract changes (type or accept semantics), save() must be adjusted.

5. Summary Judgment:
- This file contains a method (the constructor) that calls many methods concentrated in a few provider classes (JavaFX property/collection classes and VaultSettings/Environment), so it exhibits symptoms of Intensive Coupling."
ConnectionPageShellCommands.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- createControl(Composite)
- updateEvent(boolean)
- selectEventType(DBPConnectionEventType)
(also: createWaitFinishTimeout(Composite) and saveSettings(DBPDataSourceContainer) call several methods but are less heavy)

2. Calls Concentrated in Few Classes:
- UI-related: UIUtils, org.eclipse.swt widgets/classes (Composite, Table, TableItem, Text, Spinner, Button, GridData/GridLayout), DBeaverIcons/UIIcon
- Model/command: DBRShellCommand, DBPConnectionEventType, DataSourceDescriptor / DBPDataSourceContainer
- Helper controls: TextWithOpenFolder, VariablesHintLabel, DataSourceVariableResolver
Most calls in createControl/selectEventType/updateEvent are concentrated in UIUtils/SWT and DBRShellCommand-related APIs.

3. Method Complexity:
- createControl: long and procedural with multiple UI construction blocks and several nested anonymous listeners (moderate complexity, but not deep algorithmic nesting).
- updateEvent: moderate branching (if command != null, conditional handling of commandChange, checks on previous state) — some conditional complexity.
- selectEventType: repetitive enable/selection logic but shallow control flow.

4. Potential Fragility:
- Changes to DBRShellCommand API (method names or semantics like setCommand, isEnabled, setShowProcessPanel, setWaitProcessTimeoutMs, etc.) would require edits in updateEvent, selectEventType, getActiveCommand.
- Changes to UIUtils or SWT widget APIs, or to Table/TableItem event behavior, would require updates in createControl and listeners.
- Changes to connection configuration API (DataSourceDescriptor.getConnectionConfiguration().setEvent) would require changing saveSettings.
Example: if DBRShellCommand replaced isWaitProcessFinish()/setWaitProcessFinish(...) with a different API, updateEvent and selectEventType must be changed.

5. Summary Judgment:
- Yes — this file contains methods (especially createControl, updateEvent, selectEventType) that call many methods concentrated in a few provider classes (UIUtils/SWT and DBRShellCommand-related model), which are symptoms of Intensive Coupling."
MailUtil.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- private static String send(MailAccount mailAccount, boolean useGlobalSession, Collection<String> tos, Collection<String> ccs, Collection<String> bccs, String subject, String content, Map<String, InputStream> imageMap, boolean isHtml, File... files)
- (secondary) public static Session getSession(MailAccount mailAccount, boolean isSingleton) — calls several factory/utility methods but fewer than the private send.

2. Calls Concentrated in Few Classes:
- The private send method’s calls are concentrated mostly on:
  - Mail (Mail.create(...), mail.setUseGlobalSession(...), mail.setCcs(...), mail.setBccs(...), mail.setTos(...), mail.setTitle(...), mail.setContent(...), mail.setHtml(...), mail.setFiles(...), mail.addImage(...), mail.send())
  - Utility/provider classes used repeatedly: CollUtil, MapUtil, IoUtil
  - Also touches GlobalMailAccount via other overloads and uses MailAccount types
- getSession is concentrated on javax.mail.Session and UserPassAuthenticator.

3. Method Complexity:
- The private send method is not deeply nested; it has shallow conditionals (if ccs not empty, if bccs not empty, if imageMap not empty) and a loop over imageMap entries. Overall moderate complexity but low nesting depth.
- splitAddress and other overloads are simple and low complexity.

4. Potential Fragility:
- Yes — because many operations delegate to Mail, changes in Mail’s API or behavior would likely require updates here. Examples:
  - If Mail.rename/setters/signatures change (e.g., setCcs now expects a Collection rather than String[]), the calls and conversions would need modification.
  - If Mail.create(...) signature or Mail.send() semantics change, this method must be updated.
  - Changes in IoUtil.close behavior or MapUtil/CollUtil utility semantics (e.g., removal of isNotEmpty) would require code changes.
  - Changes to Session/authenticator creation (UserPassAuthenticator or Session.getDefaultInstance/getInstance) would affect getSession.

5. Summary Judgment:
- Yes — the file contains a method (the private send(...) implementation) that calls many methods concentrated primarily in the Mail class and a few utility/provider classes, which matches symptoms of Intensive Coupling."
HttpRequestMethodsMatcherTest.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. The class contains three small test methods: testEqualsAndHashCode, testGetContent, testGetToStringInfix. Each invokes only a few methods (Assert.assertEquals, matcher.getMethods / getContent / getToStringInfix, Arrays.asList, and the HashSet constructor).

2. Calls Concentrated in Few Classes:
- The small number of calls are to a few classes: org.junit.Assert, java.util.Arrays / java.util.HashSet, the HttpMethod enum, and the local provider HttpRequestMethodsMatcher. Calls are not heavily concentrated in a single external provider beyond these.

3. Method Complexity:
- The methods are simple unit tests with no nesting, no conditionals, and low cyclomatic complexity.

4. Potential Fragility:
- Limited. Changes to HttpRequestMethodsMatcher (e.g., renaming or changing the return types/semantics of getMethods/getContent/getToStringInfix) would require updating these tests. Changes to Assert or java.util APIs would also break them, but such changes are unlikely.

5. Summary Judgment:
- Based on the above, this file does not exhibit Intensive Coupling."
SymbolInfo.java,
TextureAtlas.java,
ImmutableEnumMap.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method calls a large number of other methods. The methods that call multiple other methods (but only a few) are:
  - asImmutable(...)
  - keyIterator()
  - entryIterator()
  - entrySpliterator()
  - equals(Object)
  - (minor callers: forEach(), keySpliterator(), size(), containsKey(), get() — each delegates one method)

2. Calls Concentrated in Few Classes:
- Yes, the calls that do occur are concentrated primarily in:
  - java.util.EnumMap (delegate) — most instance calls (size, get, containsKey, keySet, entrySet, forEach)
  - Guava utility classes: Iterables, Iterators, Maps, CollectSpliterators, ImmutableMap (static helpers/constructors)
- So provider classes are essentially EnumMap and a small set of utility classes.

3. Method Complexity:
- Methods are simple. No deep nesting; only small branching:
  - asImmutable uses a switch on size (simple cases).
  - equals has a couple of shallow conditionals.
- Overall low complexity.

4. Potential Fragility:
- Changes to the EnumMap API or semantics (e.g., keySet()/entrySet() views, iteration behavior) would require updates here because many methods delegate to it.
- Changes to the utility helper APIs (Iterators, Maps, CollectSpliterators, ImmutableMap static behavior) could also force edits.
- Example: if Maps.unmodifiableEntryIterator signature/behavior changed or delegate.entrySet() semantics changed, entryIterator/entrySpliterator would need adjustment.

5. Summary Judgment:
- Although calls are concentrated on EnumMap and a few utility classes, no method in this file calls a large number of methods. The file shows focused delegation rather than a single method invoking many methods across one provider in a way that constitutes clear Intensive Coupling."
CharacterReader.java,
ArgumentTokenizer.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- tokenize(String, boolean) — long method that performs parsing and calls many methods on local objects.
- _escapeQuotesAndBackslashes(String) — iterates and invokes several String/Builder operations.
- tokenize(String) — trivial delegate to tokenize(String, boolean).

2. Calls Concentrated in Few Classes:
- Yes — most calls are concentrated on a small set of standard library provider classes:
  - java.lang.String (length(), charAt(), etc.)
  - java.lang.StringBuilder (append(), insert(), deleteCharAt(), toString())
  - java.util.LinkedList / java.util.List (add(), set(), size())
  - java.lang.Character (isWhitespace())
  - java.lang.IllegalStateException (constructor)

3. Method Complexity:
- tokenize(String, boolean): moderately high complexity — single large loop, nested switch statements, look-ahead increments, multiple boolean flags and state transitions (several conditional branches).
- _escapeQuotesAndBackslashes(String): lower complexity but contains a backward loop with multiple conditional branches.

4. Potential Fragility:
- If one of the provider classes changed behavior or contract, these methods could need updates. Examples:
  - Changes to String.charAt/length or Character.isWhitespace semantics would affect parsing logic in tokenize.
  - Changes to StringBuilder API or behavior (append/insert/deleteCharAt) would require code changes in both methods.
  - Replacing LinkedList with a different collection requiring different add/set behavior would require adapting token collection code.
  - Altering expected escape/quote handling conventions would require changes in both tokenize and _escapeQuotesAndBackslashes.

5. Summary Judgment:
- Although methods call many methods, those calls are primarily to a small set of core JDK classes (String, StringBuilder, LinkedList, Character). Because these are standard library providers and the coupling is not to multiple distinct application/provider classes, I do not classify this as Intensive Coupling in the sense of dependency on a small set of external/provider classes causing fragile domain coupling."
JobLogController.java,
Monitor.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- runUnprivileged() — calls many methods.
- (lesser extent) run() — calls SpecialPermission.check(), AccessController.doPrivileged(...), and runUnprivileged().

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in HTTP-client related classes and a local Dictionary/Logger:
  - org.apache.http.impl.client.CloseableHttpClient (httpclient.execute(...))
  - org.apache.http.client.methods.CloseableHttpResponse and related types (response.getStatusLine(), response.getLastHeader(...), response.close(), getValue(), etc.)
  - org.apache.http.client.config.RequestConfig (builder chain)
  - org.apache.http.client.methods.HttpHead (setConfig, setHeader)
  - org.wltea.analyzer.dic.Dictionary (Dictionary.getSingleton().reLoadMainDict())
  - org.apache.logging.log4j.Logger (logger.info/error)

3. Method Complexity:
- runUnprivileged() is moderately complex: try-catch-finally, an outer status-code conditional (200 / 304 / else) and a nested compound condition checking two headers with OR. Nesting depth is shallow (about 2 levels) but there are several branches and error/cleanup paths.

4. Potential Fragility:
- Yes. Changes in the provider classes would likely require changes here or cause runtime issues. Examples:
  - If CloseableHttpResponse/StatusLine/Header API changes (method names, null semantics), the header/status checks and close logic would break.
  - If CloseableHttpClient.execute behavior or exceptions change, error handling and control flow may need adjustment.
  - If RequestConfig builder API changes, timeout configuration code must change.
  - If Dictionary.getSingleton() or reLoadMainDict() signature/behavior changes, the reload call will break.
  - If logger API changes, logging calls would need update.

5. Summary Judgment:
- Yes — runUnprivileged() exhibits symptoms of Intensive Coupling: it invokes many methods concentrated primarily in a small set of HTTP client classes (plus Dictionary and Logger), creating a focused dependency surface that could be fragile if those provider classes change."
HistoryPageFilter.java,
HandshakeData.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No methods that call a large number of other methods. The only method with multiple calls is:
  - getSingleUrlParam(String name) — calls urlParams.get(name), values.size(), values.iterator().next().

2. Calls Concentrated in Few Classes:
- The few calls in getSingleUrlParam are concentrated on standard collection/provider classes:
  - java.util.Map (urlParams)
  - java.util.List (values)
  - java.util.Iterator (returned by values.iterator())
- Other methods are simple getters/constructors and do not call external provider methods.

3. Method Complexity:
- Methods are simple. getSingleUrlParam has a single conditional and no deep nesting. All other methods are trivial getters or constructors.

4. Potential Fragility:
- Low fragility: changes to standard JDK collection APIs are unlikely to affect this code. Potential issues:
  - If the structure/type of urlParams changed (e.g., not a Map<String,List<String>>) the method would need updates.
  - If urlParams could be null, getSingleUrlParam may throw a NullPointerException (no null check).
- Overall, dependency surface is small and limited to standard collection types.

5. Summary Judgment:
- Based on the above, this file does not exhibit Intensive Coupling: no methods call many methods concentrated in one or a few provider classes."
Vault.java,
CommandDecoder.java,
FxApplication.java,
HttpHeadRequestTest.java,
BatchExecutor.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- doUpdate(...)
- doFlushStatements(...)
- doQuery(...)
- doQueryCursor(...)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in a few provider classes/types:
  - StatementHandler (prepare, parameterize, batch, query, queryCursor, getBoundSql)
  - java.sql.Statement / Connection (prepare/executeBatch/close, closeOnCompletion)
  - BatchResult (addParameterObject, setUpdateCounts, getMappedStatement, getParameterObjects)
  - KeyGenerator / Jdbc3KeyGenerator / NoKeyGenerator (processBatch, processAfter)
  - MappedStatement / BoundSql / Configuration (newStatementHandler, getConfiguration, getSql)
  - Transaction (getTimeout)

3. Method Complexity:
- doFlushStatements is the most complex: loops, try/catch, nested conditionals (key generator class checks) and an inner loop over parameter objects.
- doUpdate has a single if/else with repeated interactions with StatementHandler and lists (moderate complexity).
- doQuery and doQueryCursor are simpler (straight-line with try/finally or small sequence of calls).

4. Potential Fragility:
- Yes. Changes to the provider classes would likely require changes here or cause impact. Examples:
  - Changing StatementHandler API (method names/signatures or behavior of parameterize/prepare/batch/query) would break doUpdate/doQuery/doQueryCursor.
  - Modifying KeyGenerator API or how generated keys are handled (processBatch/processAfter) would require changes in doFlushStatements.
  - Changes to Statement.executeBatch() semantics or return values would affect batchResult.setUpdateCounts usage and error handling.
  - Altering BatchResult structure (methods used here) would require updates wherever BatchResult is accessed.

5. Summary Judgment:
- Yes — this file contains methods (notably doFlushStatements and doUpdate) that call many methods concentrated in a small set of provider classes, showing symptoms of Intensive Coupling."
TokenQueue.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- chompBalanced(char open, char close)
- consumeToIgnoreCase(String seq)
- unescape(String in)
- consumeToAny(String... seq) and consumeTo(String seq) (moderate number of calls via helpers)
- Several smaller methods call a number of helper or library methods (matches*, consume*, consumeWord, consumeWhitespace, toString), but are simpler.

2. Calls Concentrated in Few Classes:
- Yes — most external calls are concentrated in:
  - java.lang.String (substring, indexOf, regionMatches, startsWith, charAt, length, toCharArray, etc.)
  - java.lang.Character (isLetterOrDigit, isLetter, etc.)
  - org.jsoup.internal.StringUtil (isWhitespace, borrowBuilder, releaseBuilder)
  - org.jsoup.helper.Validate (notNull, fail)
  - java.lang.StringBuilder (append) — used via StringUtil helpers
  - lots of calls are also to methods within this class (isEmpty, matches, matchChomp, consume)

3. Method Complexity:
- chompBalanced: yes — complex state machine with loop, multiple flags, nested conditionals and state updates.
- consumeToIgnoreCase: moderate complexity — loop with conditional fast-scan logic and multiple String operations.
- unescape: low to moderate complexity — simple loop with condition.
- Most other methods are simple loops/guards with low nesting.

4. Potential Fragility:
- Yes — changes in provider classes could require changes or cause impact. Examples:
  - Changes to StringUtil (e.g., borrowBuilder/releaseBuilder semantics or isWhitespace behavior) would affect unescape(), matchesWhitespace(), and any code relying on those helpers.
  - Changes to Validate.fail/notNull (exception types or behavior) would affect constructor and chompBalanced error handling.
  - Changes to String APIs or assumptions about substring/indexOf/regionMatches behavior (or switching to a different backing type) would affect many methods (consumeTo, consumeToIgnoreCase, substring usage throughout).
  - Because many methods call String/Character APIs and a few Jsoup helpers repeatedly, modifications in those providers could ripple to multiple methods here.

5. Summary Judgment:
- While many methods call several other methods, those calls are largely to core Java String/Character APIs and a small set of Jsoup utility classes. This file shows concentrated use of String and a couple of helper classes, but this is expected for a TokenQueue operating on a String buffer; it does not clearly exhibit problematic Intensive Coupling beyond normal tight coupling to String and small utility providers."
DubboServiceMetadataRepository.java,
FakeValuesService.java,
PassphraseEntryController.java,
LexemePath.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- compareTo
- addCrossLexeme
- addNotCrossLexeme
- getXWeight
- getPWeight
- copy
- toString
- removeTail

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in:
  - Lexeme (getBegin(), getLength(), toString())
  - QuickSortSet / its Cell structure (getHead(), getNext(), peekFirst(), peekLast(), addLexeme(), pollLast(), size(), Cell.getLexeme())
  - StringBuffer (append) is used in toString

3. Method Complexity:
- compareTo: complex — many nested conditional branches and comparisons.
- addCrossLexeme / addNotCrossLexeme: moderate branching (if/else) with state updates.
- getXWeight / getPWeight / copy / toString: simple loops over Cells.
- removeTail: simple conditional and state updates.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require changes here. Examples:
  - If Lexeme changes names/behavior of getBegin()/getLength(), many methods (addCrossLexeme, addNotCrossLexeme, getXWeight, getPWeight, copy, removeTail, compareTo) must be updated.
  - If QuickSortSet API or Cell structure changes (e.g., getHead()/getNext()/peekFirst()/peekLast()/addLexeme()/pollLast()/size()), compareTo, copy, toString, getXWeight, getPWeight, add/remove methods would be impacted.
  - If Cell.getLexeme() semantics change, iteration-based methods (getXWeight, getPWeight, copy, toString) break.

5. Summary Judgment:
- Yes — this file contains methods (notably compareTo and several path-manipulating methods) that call many methods concentrated in a few provider classes (Lexeme and QuickSortSet/Cell), indicating symptoms of Intensive Coupling."
PullAPIWrapper.java,
ParamFlowChecker.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- passDefaultLocalCheck
- passThrottleLocalCheck
- passClusterCheck
- passLocalCheck (moderate)
- passCheck / passSingleValueCheck (moderate)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated around:
  - ParameterMetric / ParameterMetricStorage
  - CacheMap (returned by metric) and its entries
  - java.util.concurrent.atomic.AtomicLong (many get/compareAndSet/set)
  - ParamFlowRule (rule getters like getCount/getDurationInSec/getParsedHotItems/etc.)
  - TimeUtil / TimeUnit and Thread utilities
  - For cluster path: TokenService (requestParamToken) and cluster providers (ClusterStateManager, TokenClientProvider, EmbeddedClusterTokenServerProvider)

3. Method Complexity:
- Yes. passDefaultLocalCheck and passThrottleLocalCheck are complex: they contain while(true) loops, CAS loops, multiple nested conditionals, and blocking/sleep logic. passClusterCheck has branching based on cluster availability and token result status.

4. Potential Fragility:
- Yes. Changes to provider classes would likely require updates here. Examples:
  - If ParameterMetric or its getRuleTokenCounter/getRuleTimeCounter APIs change, passDefaultLocalCheck/passThrottleLocalCheck must change.
  - If CacheMap behavior or AtomicLong methods/signatures change, the CAS loops and putIfAbsent logic must be updated.
  - If TokenService.requestParamToken or TokenResult status enums change, passClusterCheck and pickClusterService would need modification.
  - Changes to rule getters (ParamFlowRule) or cluster config semantics would impact multiple branches.

5. Summary Judgment:
- Yes — this file contains methods (notably passDefaultLocalCheck, passThrottleLocalCheck, and passClusterCheck) that call many methods concentrated in a small set of provider classes, showing symptoms of Intensive Coupling."
SaTokenContextForThreadLocalStorage.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method in this file calls many other methods. Most methods call at most 1–2 other methods. Methods present: setBox, clearBox, getBox, getBoxNotNull, getRequest, getResponse, getStorage.

2. Calls Concentrated in Few Classes:
- The few calls that exist are concentrated on a small set of local/provider classes:
  - java.lang.ThreadLocal (boxThreadLocal.set/remove/get)
  - SaTokenContextForThreadLocalStorage.Box (constructor, getRequest/getResponse/getStorage)
  - SaTokenException (constructor when null)
  - The SaRequest / SaResponse / SaStorage objects are returned but not heavily interacted with here.

3. Method Complexity:
- Methods are simple. No deep nesting or many conditional branches. Only getBoxNotNull has a single null check and a throw; others are single-line accessors or mutators.

4. Potential Fragility:
- Low fragility overall. Examples where changes would require edits:
  - If Box’s getters or fields are renamed/removed, getRequest/getResponse/getStorage would need updating.
  - If the ThreadLocal handling semantics or API changed, setBox/clearBox/getBox/getBoxNotNull would be affected.
  - If SaTokenException construction changes, the throw site might need adjustment.
- These are isolated and limited; not widespread across many classes.

5. Summary Judgment:
- Based on the above, this file does not contain methods that call many methods concentrated in one or a few classes; it does not exhibit Intensive Coupling."
AbortedTransactionException.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No. The file only contains three constructors; they only invoke superclass constructors and do not call many other methods.

2. Calls Concentrated in Few Classes:
- N/A for many calls. The only provider referenced is the superclass JedisDataException (via super(...)); types String and Throwable are used but no method calls on them.

3. Method Complexity:
- No. All constructors are trivial (single super(...) call), with no nesting or conditional branches.

4. Potential Fragility:
- Low. If JedisDataException’s constructor signatures changed, these constructors would need updating, but otherwise changes in other classes are unlikely to cause widespread impact.

5. Summary Judgment:
- This file does not exhibit Intensive Coupling."
HttpRequest.java,
ProxyDatabaseMetaData.java,
MethodCallInliner.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- visitMethodInsn(...)
- (to a lesser extent) visitMaxs(...)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in a few ASM-related provider classes:
  - MethodNode (toBeInlined: instructions.resetLabels(), accept(...))
  - MethodVisitor / GeneratorAdapter (mv.visitMethodInsn(...), super.visitLabel(...), super.visitTryCatchBlock(...), super.visitMaxs(...))
  - InliningAdapter (constructor / use)
  - org.objectweb.asm.Label (Label construction/usage)

3. Method Complexity:
- visitMethodInsn: moderate complexity — a conditional early-return plus a sequence of inlining steps (flag manipulation, label creation, resetting labels, invoking accept on MethodNode). No deep nesting but multiple steps.
- visitMaxs: low complexity — simple loop over blocks and a final super call.
- visitTryCatchBlock: low complexity — single if/else.

4. Potential Fragility:
- Yes. Changes to the provider classes would likely require updates here. Examples:
  - If MethodNode changes (different instructions API, rename/remove resetLabels(), or accept signature), visitMethodInsn must change.
  - If InliningAdapter constructor/signature changes, code creating it must be updated.
  - If MethodVisitor/GeneratorAdapter behavior or method signatures change (visitLabel, visitMethodInsn, visitTryCatchBlock, visitMaxs), this class would be affected.

5. Summary Judgment:
- Based on the above, this file contains a method (visitMethodInsn) that calls multiple methods concentrated in a few ASM/provider classes, indicating symptoms of Intensive Coupling."
IKArbitrator.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- process(AnalyzeContext context, boolean useSmart)
- judge(QuickSortSet.Cell lexemeCell, int fullTextLength)
- forwardPath(QuickSortSet.Cell lexemeCell, LexemePath option)
- backPath(Lexeme l, LexemePath option)

2. Calls Concentrated in Few Classes:
- Most calls are concentrated in:
  - LexemePath (addCrossLexeme, addNotCrossLexeme, size, getHead, getPathLength, copy, checkCross, removeTail, addLexemePath-like interactions)
  - QuickSortSet / QuickSortSet.Cell (pollFirst, getLexeme, getNext)
  - AnalyzeContext (getOrgLexemes, addLexemePath)
  - Also uses java.util.Stack and java.util.TreeSet but primary logic depends on LexemePath and QuickSortSet/Cell.

3. Method Complexity:
- process: moderate complexity — iterative loop over lexemes with nested if/else branches (while + conditional branches, duplicated ending logic).
- judge: moderate complexity — uses a loop, a Stack for conflicts, repeated forward/backtracking calls; some iterative recursion-like control flow.
- forwardPath: simple loop but central to conflict detection.
- backPath: simple loop removing tails until condition clears.
- No extreme deep nesting, but control flow is non-trivial due to loops and backtracking.

4. Potential Fragility:
- Yes. Changes in provider classes would likely require changes here. Examples:
  - If LexemePath method names, signatures or semantics (addNotCrossLexeme, addCrossLexeme, checkCross, removeTail, copy, getPathLength) change, process/judge/forwardPath/backPath must be updated.
  - If QuickSortSet.Cell API changes (getLexeme, getNext) or QuickSortSet.pollFirst behavior changes, process and forwardPath/judge logic break.
  - If AnalyzeContext methods (getOrgLexemes, addLexemePath) change, process must be adapted.
  - Because several methods repeatedly call the same provider APIs, a change in those providers produces widespread edits here.

5. Summary Judgment:
- Yes — this file contains methods (notably process and judge, plus forwardPath/backPath) that call many methods concentrated chiefly in LexemePath and QuickSortSet/Cell (and AnalyzeContext), which are symptoms of Intensive Coupling."
SingleRoomBroadcastOperations.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- No method calls a large number of distinct methods. Methods that call several provider methods (but not a large variety) include:
  - send(Packet)
  - send(Packet, BroadcastAckCallback<T>)
  - sendEvent(String, SocketIOClient, Object...)
  - sendEvent(String, Object...)
  - sendEvent(String, Object, BroadcastAckCallback<T>)
  - sendEvent(String, Object, SocketIOClient, BroadcastAckCallback<T>)
  - dispatch(Packet) (delegates to storeFactory.pubSubStore().publish)

2. Calls Concentrated in Few Classes:
- Yes — most calls are concentrated in a small set of provider classes:
  - SocketIOClient (send, sendEvent, disconnect, getSessionId)
  - StoreFactory / pubSubStore (publish) via dispatch
  - BroadcastAckCallback (createClientCallback, loopFinished)
  - Packet / PacketType and Arrays (construction and setters) — used for building packets

3. Method Complexity:
- Methods are simple: mostly single-level loops over clients and small conditionals (an if to skip an excluded client). No deep nesting or complex branching structures.

4. Potential Fragility:
- Changes in provider classes would likely require changes here. Examples:
  - If SocketIOClient changes send/sendEvent/disconnect/getSessionId signatures or semantics, multiple methods in this class must be updated.
  - If StoreFactory.pubSubStore().publish changes, dispatch — and therefore send/sendEvent that call dispatch — would be affected.
  - If BroadcastAckCallback API changes (createClientCallback or loopFinished), all ack-using methods must be updated.

5. Summary Judgment:
- Based on this file alone, I do not detect intensive coupling: methods rely on a small number of provider classes, but they do not call a large variety of methods or exhibit high internal complexity; the coupling is present but limited and localized."
Lorem.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- characters(int fixedNumberOfCharacters, boolean includeUppercase, boolean includeDigit)
- characters(int minimumLength, int maximumLength, ...) and other overloads that call faker.random().nextInt (several overloads)
- sentence(int wordCount, int randomWordsToAdd)
- paragraph(int sentenceCount) and paragraph()
- fixedString(int numberOfLetters)
- word()
- sentences(int) and paragraphs(int) (they call sentence()/paragraph() repeatedly)

2. Calls Concentrated in Few Classes:
- Yes. Most external calls are concentrated in:
  - Faker and its collaborators: faker.random().nextInt(...), faker.bool().bool(), faker.fakeValuesService().resolve(...)
  - The Lorem class itself (internal calls between words(), sentence(), sentences(), paragraph(), etc.)
  - A small set of utility providers: org.apache.commons.lang3.StringUtils (substring), StringUtils.capitalize / join (static imports), and java.lang.Character (toUpperCase)
So the bulk of external dependencies are on Faker (and sub-services) plus a few utility classes.

3. Method Complexity:
- Moderate complexity: characters(fixedNumberOfCharacters,...) has loops and conditional branches (includeDigit, includeUppercase) but shallow nesting.
- fixedString has a loop and repeated calls to sentence().
- sentence/paragraph methods are simple but combine several calls and small conditional logic (randomWordsToAdd calculation).
- No deeply nested control flow, but several methods have loops and branching.

4. Potential Fragility:
- Yes. Changes in Faker or its sub-services would likely require edits here or cause breakage. Examples:
  - If faker.random().nextInt signature/semantics change, many characters/sentence/paragraph methods would be affected.
  - If faker.bool().bool() is removed/renamed, characters(...) uppercase behavior breaks.
  - If fakeValuesService().resolve(...) behavior or the ""lorem.words"" data changes, word()/sentence()/paragraph() outputs and callers would be impacted.
  - Changes to utility methods used (StringUtils.join/capitalize or Character.toUpperCase) could also affect formatting in multiple places.

5. Summary Judgment:
- Yes — there are methods that call many methods and those calls are largely concentrated in Faker (and its subcomponents) and a few utility classes, indicating symptoms of Intensive Coupling."
HostAndPort.java,
DefaultJSONParser.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- parseObject(Map object, Object fieldName)
- parseArray(Collection array, Object fieldName)
- parseObject(Type type, Object fieldName)
- parse()
- parseObject(Object object)  (JavaBean parsing)
- parseArray(Type type, Collection array, Object fieldName)
- handleResovleTask
- parse(PropertyProcessable object, Object fieldName)
(These methods contain many calls to other methods/APIs.)

2. Calls Concentrated in Few Classes:
- Heavy concentration of calls to the lexer (JSONLexer / JSONScanner): token(), nextToken(), getCurrent(), scanSymbol(), scanNumber(), stringVal(), integerValue(), decimalValue(), bytesValue(), isEnabled(), skipWhitespace(), pos(), resetStringPosition(), close(), etc.
- ParserConfig / deserializers: config.getDeserializer(...), deserializer.deserialze(...), JavaBeanDeserializer/MapDeserializer/IntegerCodec/StringCodec/LongCodec.
- TypeUtils and JSONPath/JSONScanner (iso8601 parsing) also appear repeatedly.
- Secondary providers: JSONObject/JSONArray methods, FieldDeserializer / ResolveFieldDeserializer, ParseContext / ResolveTask utilities.

3. Method Complexity:
- Yes. Several methods (notably parseObject(Map, ...), parseArray(...), parse(), parse(PropertyProcessable,...)) are large with deep nesting, many conditional branches, long loops and many case branches (switches and nested if/else chains).

4. Potential Fragility:
- Changes to JSONLexer API or token semantics (e.g., renaming token methods, changing token values, changing nextToken behavior) would require edits in many of these methods (they call lexer.* everywhere).
- Changes to ObjectDeserializer interface or ParserConfig.getDeserializer (signature/behavior) would impact many call sites (deserialze(...) is invoked repeatedly).
- Changes to JSONPath.compile / eval or JSONScanner ISO8601 behavior would require updates in handleResovleTask and string date handling.
- Example: if lexer.nextToken(int) semantics changed or stringVal() returned a different object, parseObject(Map,...) and parseArray(...) would need changes across many branches.
- Example: if deserialze(...) added required context parameters, dozens of call sites would need updates.

5. Summary Judgment:
- Yes — this file contains multiple large methods that call many methods concentrated primarily on JSONLexer and ParserConfig/deserializer classes, which are strong indicators of Intensive Coupling."
AutoLocker.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- autolock(Vault)
- exceedsIdleTime(Vault)
- (tick() calls several stream operations and delegates to the above methods)

2. Calls Concentrated in Few Classes:
- Most calls are concentrated on Vault and objects returned from it:
  - Vault (isUnlocked, lock, getDisplayName, getVaultSettings, getStats)
  - VaultSettings (autoLockWhenIdle, autoLockIdleSeconds) — accessed via Vault.getVaultSettings()
  - Vault stats (getLastActivity) — accessed via Vault.getStats()
  - Also uses ScheduledExecutorService (init) and Logger (LOG) but primary concentration is Vault and its returned types.

3. Method Complexity:
- Methods are simple: shallow control flow.
  - autolock: try-catch only.
  - exceedsIdleTime: single if/else and a few chained calls.
  - tick: stream pipeline (filter/filter/forEach).
  - No deep nesting or many conditional branches.

4. Potential Fragility:
- Yes. Changes to Vault API would likely require changes here. Examples:
  - If Vault.lock signature changes or throws different exceptions, autolock must be updated.
  - If Vault.getVaultSettings() or the settings API (autoLockWhenIdle()/autoLockIdleSeconds()) changes, exceedsIdleTime breaks.
  - If Vault.getStats() or getLastActivity() semantics change, idle detection breaks.
  - Any consolidation or relocation of these providers would force edits to multiple call sites in this class.
  - The TODO about FX Application Thread hints at threading/usage changes that could also require modifications.

5. Summary Judgment:
- Yes — this file contains methods (notably autolock and exceedsIdleTime, plus tick delegating to them) that call many methods concentrated in Vault and its related provider objects, which matches symptoms of Intensive Coupling."
ReedSolomonDecoder.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- decode(...)
- runEuclideanAlgorithm(...)
- findErrorMagnitudes(...)
- findErrorLocations(...) (moderate number of calls)

2. Calls Concentrated in Few Classes:
- Yes. Most calls are concentrated in:
  - GenericGF (field.* methods: exp, getGeneratorBase, buildMonomial, inverse, multiply, log, getZero, getOne, getSize, getGeneratorBase, etc.)
  - GenericGFPoly (constructors and methods: evaluateAt, getDegree, getCoefficient, isZero, addOrSubtract, multiply, multiplyByMonomial)
  - GenericGF static helpers (GenericGF.addOrSubtract)

3. Method Complexity:
- decode: loop over syndrome coefficients, conditional early return, then several steps calling helpers — moderate complexity.
- runEuclideanAlgorithm: high complexity — multiple nested loops, several local temporaries, degree checks, and multiple exception conditions.
- findErrorMagnitudes: moderate-high complexity — nested loop over error locations with conditional branch and arithmetic/workaround logic.
- findErrorLocations: low-moderate complexity — single loop with conditional and an exception check.

4. Potential Fragility:
- Yes. Changes in GenericGF or GenericGFPoly (method signatures, semantics, behavior of multiply/inverse/exp/log, representation of polynomials, buildMonomial, evaluateAt, etc.) would likely require changes here. Examples:
  - If field.inverse or field.multiply behavior changes, findErrorMagnitudes and runEuclideanAlgorithm computations break.
  - If GenericGFPoly.multiply/addOrSubtract/evaluateAt semantics change, runEuclideanAlgorithm, findErrorLocations and decode would need updates.
  - If field.getGeneratorBase/log mapping changes, the position calculation in decode (position = received.length - 1 - field.log(...)) would be affected.

5. Summary Judgment:
- Yes — this file contains methods (notably decode, runEuclideanAlgorithm and findErrorMagnitudes) that call many methods concentrated in a small set of provider classes (GenericGF and GenericGFPoly), indicating symptoms of Intensive Coupling."
ExecutionSequencer.java,
DirectedGraphConnections.java,
HttpServerTest.java,
ServiceLoader.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- load(Class<T> clazz, ClassLoader classLoader)
- load(URL url, Set<String> set)

2. Calls Concentrated in Few Classes:
- Not strongly concentrated in a single provider. Calls are distributed across several JDK/provider classes:
  - ClassLoader (getResources, loadClass)
  - Enumeration (hasMoreElements, nextElement)
  - URL (openStream, toString)
  - Class/Reflection (getName, newInstance)
  - Collections/Set implementations (emptySet, new HashSet, contains, add)
  - IO/Strings (BufferedReader.readLine, InputStreamReader, String.indexOf/substring/trim/length)
  - IOUtils (close)
  These are multiple different providers rather than one/few concentrated providers.

3. Method Complexity:
- Both methods are relatively simple. load(URL, Set) has a single loop with a few small conditionals and string operations. load(Class, ClassLoader) has straightforward resource enumeration and a simple loop — no deep nesting or large branching complexity.

4. Potential Fragility:
- Some fragility exists if key providers change:
  - If IOUtils.close behavior or signatures change, load(URL, Set) will need updates.
  - If ClassLoader behavior (getResources / loadClass) or reflection changes, load(Class, ClassLoader) would be affected.
  - Changes to expected service file format (string parsing) would require modifications in load(URL, Set).
  - However, these are changes to standard/provider APIs rather than many calls concentrated to a single custom provider.

5. Summary Judgment:
- Based on the above, this file does not exhibit the Intensive Coupling smell: methods call several methods but those calls are spread across multiple standard/provider classes rather than being heavily concentrated in one or a very small set of provider classes."
JedisSentinelPool.java,
SimpleEchoSocket.java,"YES, I found Intensive Coupling

1. Methods Calling Many Methods:
- onConnect(Session session) — calls multiple methods (System.out.printf, session.getRemote(), sendStringByFuture, Future.get, session.close, etc.).
(secondary: onClose and onMessage call a couple of methods each but far fewer.)

2. Calls Concentrated in Few Classes:
- Yes. Most calls in onConnect are concentrated in the websocket Session and its remote endpoint (session.getRemote() and the returned remote's sendStringByFuture), plus interaction with java.util.concurrent.Future. (Also uses System.out and StatusCode but the bulk is Session/remote/Future.)

3. Method Complexity:
- Moderate complexity: onConnect has a try/catch and a for-loop over toSendMessages; no deep nesting or many conditional branches.

4. Potential Fragility:
- Yes. Changes to the Session API or the remote endpoint (e.g., sendStringByFuture signature/semantics), Future behavior, or close/status semantics would likely require changes in onConnect and could cause ripple effects. Example: renaming or changing the sendStringByFuture method, or altering how close/status codes are handled.

5. Summary Judgment:
- Yes — this file contains a method (onConnect) that calls many methods concentrated in a small set of provider classes (Session/remote/Future), showing symptoms of Intensive Coupling."
RestAdapter.java,"NO, I did not find Intensive Coupling

1. Methods Calling Many Methods:
- RestHandler.invokeRequest(...) (inner class RestHandler)
- RestHandler.invoke(...) (InvocationHandler.invoke)
- logAndReplaceRequest(...)
- logAndReplaceResponse(...)
- Builder.ensureSaneDefaults()

2. Calls Concentrated in Few Classes:
- The calls in those methods are spread across many collaborator/provider classes rather than concentrated in one or a few. Provider classes and collaborators invoked include: Endpoint (server), RequestBuilder, RequestInterceptor, Client.Provider / Client, Profiler, Converter, Utils, RetrofitError, Response/Request/TypedInput/TypedOutput/TypedByteArray, MimeUtil, Log, Platform, ErrorHandler, RxSupport (conditionally). No single provider dominates the majority of calls.

3. Method Complexity:
- Yes. RestHandler.invokeRequest(...) is complex: many branches (HTTP status handling, synchronous vs asynchronous, streaming vs non-streaming), try/catch with multiple catch blocks, nested conditionals, and resource replacement logic. invoke(...) also has branching for sync/async/observable flows. logAndReplaceRequest/Response have nested conditionals based on logLevel and body type.

4. Potential Fragility:
- Changes in key collaborators would likely require adjustments:
  - Client.Provider / Client.execute(...) signature/behavior changes would affect invokeRequest's use of clientProvider.get().execute(...).
  - Converter.fromBody(...) or ConversionException semantics would impact conversion and error handling paths in invokeRequest.
  - RequestBuilder API changes would affect request construction in invokeRequest.
  - Utils.readBodyToBytesIfNecessary(...) behavior changes would affect logging and response handling.
  - Profiler.beforeCall/afterCall or RequestInterceptor.intercept changes would require updates where they are used.
  Examples: if Converter.fromBody starts throwing a different exception type, invokeRequest's conversion catch/handling would need modification; if Client.Provider.get() no longer returns a Client or execute() changes signature, invokeRequest must be updated.

5. Summary Judgment:
- Although there are methods that call many other methods and are complex, the called methods are distributed across many different classes/providers rather than concentrated in one or a few. Therefore this file does not exhibit the specific symptom of Intensive Coupling (many calls concentrated in a small set of provider classes)."
