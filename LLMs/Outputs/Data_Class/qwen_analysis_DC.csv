file_path,analysis
AccessControlLogEntry.java,"### Analysis:

#### 1. Fields:
- The class defines a number of fields, such as `count`, `reason`, `context`, `object`, `username`, `ageSeconds`, `clientInfo`, and `logEntry`.
- Fields are defined with private visibility, which is good for encapsulation, except for the constants `COUNT`, `REASON`, `CONTEXT`, `OBJECT`, `USERNAME`, `AGE_SECONDS`, and `CLIENT_INFO` which are public and static.

#### 2. Accessors:
- The class contains several simple getter methods like `getCount`, `getReason`, `getContext`, `getObject`, `getUsername`, `getAgeSeconds`, `getClientInfo`, and `getlogEntry`.
- There are no setter methods, which suggests immutability.

#### 3. Methods and Behavior:
- There are only a few methods, and they are primarily for accessing the fields or converting a string into a map (`getMapFromRawClientInfo`).
- The `toString()` method provides a string representation of the object.

#### 4. Encapsulation:
- Field encapsulation is mostly good (`private` access for fields).
- However, the class exposes some constants publicly, which might suggest it is being used for data transfer more than encapsulating behavior.

#### 5. Local Symptom Summary:
- The class is primarily a holder for data, with most of its methods being simple accessors for the fields.
- There is minimal behavior or business logic; most methods pertain to data retrieval or conversion.

### Conclusion:
**YES, I found Data Class**
  
**Clearest Evidence:**  
""Almost all methods are getters, and most fields are private, but the class seems to be primarily a holder for data with minimal behavior."""
Preconditions.java,"**NO, I did not find Data Class.**

**Explanation:**

1. **Fields:**  
   The class `Preconditions` does not define any fields. It is a utility class providing static methods for precondition checks.

2. **Accessors:**  
   Since there are no fields, there are no getter or setter methods. The class design does not involve property exposure or encapsulation regarding any fields.

3. **Methods and Behavior:**  
   The class contains numerous methods that perform meaningful checks (e.g., `checkArgument`, `checkState`, `checkNotNull`, `checkElementIndex`, `checkPositionIndex`). These methods are central to the class's functionality and are not mere accessors but perform significant preconditions checks.

4. **Encapsulation:**  
   The class encapsulates logic for checking method preconditions and invariants, and it does not expose any data in the form of public fields or trivial accessors.

5. **Local Symptom Summary:**  
   The class does not display characteristics of a Data Class. It lacks data fields and consists primarily of methods that enforce preconditions, indicating operational behavior rather than data storage or encapsulation.

Therefore, based on the provided code, the `Preconditions` class does not exhibit the symptoms of a Data Class."
FileRefreshableDataSource.java,"Let's analyze the Java file according to the given criteria for detecting the ""Data Class"" code smell:

1. **Fields**:
   - The class defines several fields such as `buf`, `charset`, `file`, `lastModified`, and constants `MAX_SIZE`, `DEFAULT_REFRESH_MS`, `DEFAULT_BUF_SIZE`, and `DEFAULT_CHAR_SET`.
   - These fields are private, which is a good encapsulation practice.

2. **Accessors**:
   - The class does not have many simple getter and setter methods. Instead, it has multiple constructors, which initialize the fields directly.
   - There are no getter or setter methods for the class fields.

3. **Methods and Behavior**:
   - Most methods perform substantive work such as `firstLoad()`, `readSource()`, `isModified()`, and `close()`.
   - The constructors perform initialization logic and checks.

4. **Encapsulation**:
   - Encapsulation is good as the fields are kept private, and there are no public fields or public getter/setter methods that expose the internal state directly.

5. **Local Symptom Summary**:
   - The class does not exhibit characteristics of a Data Class. It has several methods that perform meaningful operations and does not primarily serve as a data holder with minimal behavior.

**Conclusion:**  
NO, I did not find Data Class. The class contains meaningful methods that perform substantial operations related to file reading, modification checking, and resource management, rather than just serving as a container for data."
SaSecureUtil.java,"Let's analyze the file based on the criteria for identifying a Data Class:

1. **Fields:**
   - The class `SaSecureUtil` has some static fields, such as `encoder`, `decoder`, `DEFAULT_CIPHER_ALGORITHM`, and others related to encryption algorithms and key sizes. However, these fields are not used as data storage for instances of the class but rather as utility components for performing encryption and decryption.

2. **Accessors:**
   - There are no getter and setter methods for the fields. The methods provided are static utility methods that perform encryption and decryption.

3. **Methods and Behavior:**
   - The methods in the class are not primarily getters or setters. They perform specific functionalities like MD5, SHA1, SHA256 hashing, AES and RSA encryption, and decryption. These are meaningful operations rather than just simple data access.

4. **Encapsulation:**
   - The class encapsulates the functionality of various cryptographic operations and provides static methods as services, rather than exposing its data.

5. **Local Symptom Summary:**
   - There are no symptoms of a Data Class in this file. The class is designed to provide cryptographic services through static methods, with no data fields that are exposed through accessors or stored as instance variables.

**Conclusion:**
NO, I did not find Data Class. The main sign against it is that the class consists of static methods providing cryptographic services rather than primarily holding data through fields and accessors."
ClassLoaderCommand.java,"Let's analyze the given Java file based on the criteria you've outlined for detecting the ""Data Class"" code smell:

### 1. **Fields:**
- The class defines several fields for storing options from the command line and other data (e.g., `isTree`, `hashCode`, `classLoaderClass`, `resource`, `includeReflectionClassLoader`, `listClassLoader`, `loadClass`, `logger`, `isInterrupted`).
- These fields are primarily used to store configuration and intermediate data for the command's execution.

### 2. **Accessors:**
- The class includes a series of setter methods for `isTree`, `classLoaderClass`, `hashCode`, `all`, `resource`, `includeReflectionClassLoader`, `listClassLoader`, and `loadClass`.
- There are no getter methods shown explicitly, but the fields are `private` with corresponding setters, suggesting encapsulation.

### 3. **Methods and Behavior:**
- The class includes several methods (`process`, `processClassLoaderStats`, `processClassLoaders`, `processClassLoader`, `processResources`, `processLoadClass`, `processAllClasses`, `getAllClasses`, `processClassSet`, `getLoaderUrls`, `processClassLoaderTree`, `buildTree`, `getAllClassLoaders`, `getAllClassLoaderInfo`, `shouldInclude`) that perform substantive work, such as processing commands, gathering data, and calculating statistics.
- This behavior goes beyond simple field manipulation and shows that the class has meaningful behavior.

### 4. **Encapsulation:**
- The class uses private fields and provides setters for those fields.
- The fields are not directly exposed to the outside world, maintaining encapsulation and not falling into the pitfall of having all fields public.

### 5. **Local Symptom Summary:**
- While the class does define several fields and has setters for them, it also includes a significant number of methods that perform substantial logic handling and processing.
- The presence of numerous methods that do not simply involve data access indicates that the class is not primarily a data holder but rather a command processor.

**Conclusion:**
Upon reviewing the file, there are strong signs that this class is not primarily a data holder but performs significant logical operations and processing. Therefore:

**NO, I did not find Data Class.**  
The evidence for this is the presence of numerous methods that perform calculations and business logic, not just getters and setters."
AclException.java,"**NO, I did not find Data Class**

While the `AclException` class does have fields (`status` and `code`) with corresponding getter and setter methods, the class is primarily designed as an exception class, inheriting from `RuntimeException`. It includes multiple constructors and no additional substantive methods beyond typical exception handling, which suggests it is not purely a data holder without meaningful behavior. The purpose here is to encapsulate exception-specific information and behavior, not just to store data."
GeneralAppIdDecoder.java,"Let's analyze the provided Java file step by step to determine if it exhibits the ""Data Class"" code smell:

1. **Fields**:  
   - The class `GeneralAppIdDecoder` defines several fields:
     ```java
     private final BitArray information;
     private final CurrentParsingState current = new CurrentParsingState();
     private final StringBuilder buffer = new StringBuilder();
     ```
   - The fields are private, not public or package-private, so it's not directly exposing its fields.

2. **Accessors**:  
   - The class does not contain any simple getter or setter methods. All fields are private and are not exposed through accessors.

3. **Methods and Behavior**:  
   - The class contains several methods like `decodeAllCodes`, `isStillNumeric`, `decodeNumeric`, `extractNumericValueFromBitArray`, `decodeGeneralPurposeField`, and many other similar methods that perform substantive work, involving parsing, decoding, and handling the bit array.

4. **Encapsulation**:  
   - The class private fields are encapsulated, and it offers methods that operate on these fields with meaningful behavior, hiding the internal state behind these methods.

5. **Local Symptom Summary**:  
   - The class contains many methods that perform calculations and handle data decoding, which indicates substantive behavior rather than being just a data holder.

**Conclusion**:
- Based on the above analysis, this file does not exhibit symptoms of a Data Class. The class has meaningful behavior and does not primarily consist of a bunch of fields with simple accessors.

**Answer**:
NO, I did not find Data Class."
DuplicateRemovedScheduler.java,"NO, I did not find Data Class.

### Explanation:
1. **Fields:** The file defines a class with a single field `duplicatedRemover`. It is not exposed publicly but has a getter and setter method.
   
2. **Accessors:** There is a pattern of having a getter and setter for the `duplicatedRemover` field, but it is not an excess of these methods; only one field is involved.

3. **Methods and Behavior:** The class includes methods that perform substantive work, such as `push`, `shouldReserved`, `noNeedToRemoveDuplicate`, and the `pushWhenNoDuplicate` method placeholder, which suggests behavior beyond just data storage.
   
4. **Encapsulation:** The field `duplicatedRemover` is encapsulated with appropriate accessors and has some logic that operates on the data, indicating proper encapsulation.
   
5. **Local Symptom Summary:** The class has a few behaviors and methods that perform meaningful operations, so it does not appear to be primarily a data holder with minimal real behavior."
SaTokenException.java,"NO, I did not find Data Class.

**Explanation:**

1. **Fields:** The class has only one field, `serialVersionUID`, which is typical for serializable classes. It does not have any public or package-private fields.

2. **Accessors:** There are no getter or setter methods in the class.

3. **Methods and Behavior:** The class contains methods that perform substantive work: throwing exceptions under certain conditions. Methods like `throwBy` and `throwByNull` encapsulate logic for when an exception should be thrown, which is meaningful behavior.

4. **Encapsulation:** The class does not expose its fields. It primarily provides services in the form of static methods to throw exceptions based on given conditions, favoring encapsulation.

5. **Local Symptom Summary:** The class does not appear to be a data holder with minimal real behavior. It is designed to handle exception scenarios within the `Sa-Token` framework, providing meaningful behavior rather than merely holding data."
LinkedTreeMap.java,"NO, I did not find Data Class.

Explanation:
The file defines the `LinkedTreeMap` class which is a complex data structure managing a tree map with insertion order and maintaining balance through AVL rotations. It includes sophisticated logic like balancing the tree, finding nodes, and handling rotations, which are not typical operations found in a simple data class. The class provides meaningful methods that perform significant work beyond just managing simple data storage. Therefore, it does not conform to the pattern of a Data Class characterized by minimal behavior and primarily holding data."
SocketIOChannelInitializer.java,"Let's analyze the given Java file for symptoms that may indicate the ""Data Class"" code smell:

1. **Fields:**
   - The file defines a class `SocketIOChannelInitializer` with several fields, including `ackManager`, `clientsBox`, `authorizeHandler`, `xhrPollingTransport`, `webSocketTransport`, `webSocketTransportCompression`, `encoderHandler`, `wrongUrlHandler`, `scheduler`, `packetHandler`, `sslContext`, and `configuration`. However, these fields are private and are used to manage the state of the class.

2. **Accessors:**
   - There are no public getter or setter methods for the fields. The class does not primarily expose its fields.

3. **Methods and Behavior:**
   - The class has logic for initializing a channel, adding SSL handlers, and adding socket.IO handlers. It contains methods like `handlerAdded`, `start`, `initChannel`, `addSslHandler`, `addSocketioHandlers`, `createSSLContext`, `onDisconnect`, and `stop`. These methods perform substantive operations such as configuring and starting network-related services, handling SSL contexts, and processing disconnections.

4. **Encapsulation:**
   - The class encapsulates its data by keeping fields private and providing methods to manage the state and behavior of the socket channel initializer. It hides its data behind meaningful services.

5. **Local Symptom Summary:**
   - The class does not primarily look like a data holder with minimal real behavior. It contains significant behavior and operations essential for initializing and managing a channel in a socket.IO server setup.

**Conclusion:**

NO, I did not find Data Class. The class includes several methods that perform substantive operations, indicating that it has meaningful behavior beyond just holding data."
JobGroupController.java,"**NO, I did not find Data Class**

### Analysis:

1. **Fields:**  
   The `JobGroupController` class does have fields (e.g., `xxlJobInfoDao`, `xxlJobGroupDao`, `xxlJobRegistryDao`), but they are not attributes holding data. They are more accurately described as dependencies (DAOs) injected into the controller.

2. **Accessors:**  
   There are no simple getter or setter methods for the class’s attributes. The class does not expose its fields directly through getter/setter pairs.

3. **Methods and Behavior:**  
   The class contains methods that perform substantive work, such as validation, data processing, and interaction with the database through DAO calls. These methods are more than just getters/setters.

4. **Encapsulation:**  
   The class encapsulates its work by using the injected DAOs to perform operations on `XxlJobGroup` and `XxlJobRegistry` objects. It doesn’t expose internal data through many accessors.

5. **Local Symptom Summary:**  
   The `JobGroupController` class is not a data class because it is primarily responsible for handling controller logic, such as request handling, business validation, and interaction with data access layers. It does not primarily hold data without behavior.

Given this analysis, the class does not show symptoms of a Data Class as it includes behaviors and operations beyond simple data storage and retrieval."
ApiException.java,"NO, I did not find Data Class.

**Explanation:**
The class `ApiException` does not exhibit strong symptoms of a Data Class. While it does have a field and a getter method, it primarily extends `RuntimeException` and includes constructors that follow typical exception class patterns. It does not consist mainly of fields with accompanying getters/setters, nor does it lack meaningful behavior specific to its purpose of representing a custom API exception."
SaOAuth2Template.java,"### Analysis of the Java File for Data Class Code Smell

Let's analyze the provided Java file step by step following the outlined checks.

#### 1. Fields:
- The file does not explicitly define any fields (instance variables) within the `SaOAuth2Template` class. The methods operate on parameters or call methods that likely accept or return models (`SaClientModel`, `AccessTokenModel`, `CodeModel`, etc.), which are imported classes.
- **Conclusion**: No explicit fields are defined in the class.

#### 2. Accessors:
- There are no simple getter and setter methods for fields within this class.
- Methods such as `getClientModel`, `getOpenid`, `checkAccessToken`, `buildRedirectUri`, `saveAccessToken`, `getCode`, `getAccessToken`, etc., are methods that perform specific tasks and not simple getters/setters.
- **Conclusion**: No pattern of simple getters and setters observed.

#### 3. Methods and Behavior:
- The class contains numerous methods that perform specific tasks such as generating code, access tokens, client tokens, handling persistent data, and running checks and validations.
- These methods are not merely getters and setters but perform substantial work.
- **Conclusion**: Multiple methods perform substantive work beyond just getting or setting data.

#### 4. Encapsulation:
- The class methods provide an interface to interact with the OAuth2 functionality and model data without exposing the raw models or internal state of these models.
- The data models (`SaClientModel`, etc.) are manipulated and returned by methods, but the details of these models are hidden and not directly exposed.
- **Conclusion**: Encapsulation is used effectively, hiding the internal models and data.

#### 5. Local Symptom Summary:
- The class does not look like a data holder with minimal real behavior. It contains numerous methods that perform significant business logic and are crucial for OAuth2 functionality.
- Since there are no fields, no simple getters or setters, and the presence of substantial business logic methods, it does not exhibit SMELL of being a Data Class.

### Final Conclusion:
**NO, I did not find Data Class.**
- The provided `SaOAuth2Template` class contains significant business logic and functionality methods, and does not act primarily as a data holder with minimal behavior."
ReplyMessageProcessorTest.java,"NO, I did not find Data Class.

### Analysis:

1. **Fields**:  
   The class `ReplyMessageProcessorTest` does not define a class that primarily holds data. Instead, it defines a test class with fields that are mocks and spies for testing purposes.

2. **Accessors**:  
   There are no simple getter and/or setter methods in this file. The methods defined are not accessors, but rather setup and test methods.

3. **Methods and Behavior**:  
   The methods in the class are not simple get or set operations. They are related to initializing mocks, setting up test environments, and testing the functionality of `ReplyMessageProcessor`.

4. **Encapsulation**:  
   The class does not expose its data very much since it is a test class. It primarily uses mocks and spies to test the behavior of another class.

5. **Local Symptom Summary**:  
   The class is a test class with no significant signs of being a data class. It does not have multiple fields designed to hold data, nor does it have a high number of accessor methods.

Given these points, the file does not exhibit any strong symptoms of the Data Class code smell."
NodeTraversor.java,"NO, I did not find Data Class

### Explanation:

1. **Fields**: The class `NodeTraversor` does not define any fields. It only has methods, which indicates it is not primarily a data holder.

2. **Accessors**: Since there are no fields, there are also no getter or setter methods.

3. **Methods and Behavior**: The methods in `NodeTraversor` perform substantial work, such as traversing and filtering nodes in a depth-first manner. They include loops, conditionals, recursion (implemented iteratively to prevent stack overflow), and meaningful logic.

4. **Encapsulation**: As there are no fields, encapsulation is not an issue here. However, the class does not expose any data; it only provides services through its methods.

5. **Local Symptom Summary**: The class is not primarily a data holder with minimal real behavior. It contains methods that perform significant computation and logic processing, not just simple getters and setters."
DirectoryBrowserSupport.java,"Let's analyze the provided Java file for symptoms of the ""Data Class"" code smell step by step.

### 1. Fields
- The class `DirectoryBrowserSupport` defines several fields such as `owner`, `title`, `base`, `icon`, `serveDirIndex`, and `indexFileName`. 
- These fields are exposed either directly (e.g., `owner`, `title`) or through accessors (e.g., getters for other fields).

### 2. Accessors
- The class includes simple getter methods like `getTitle()`. 
- Setters are also present, such as `setIndexFileName(String fileName)`. 
- Most of the methods dedicated to these fields are accessors.

### 3. Methods and Behavior
- The class contains a substantial amount of business logic, particularly in the `serveFile` method and other helper methods that handle file operations, path scanning, and directory listing.
- There are methods like `generateResponse`, `serveFile`, `buildChildPaths`, `patternScan`, and `buildPathList`, which perform meaningful operations and involve significant processing.

### 4. Encapsulation
- The class makes reasonable efforts to encapsulate data, using private fields and providing access through public methods.
- However, it does expose some fields directly, such as `owner` and `title`.

### 5. Local Symptom Summary
- The class is not a typical Data Class because it contains a significant amount of business logic in addition to holding data.
- Most of its functionality revolves around serving files and directories from a file system, not just exposing or modifying fields.

### Conclusion
Given the analysis:

- **NO, I did not find Data Class.**
- This conclusion is based on the presence of substantial and meaningful methods that perform business logic related to file system operations, distinction from just being a container for data with basic accessors.

The class primarily serves a functional purpose in the context of directory browsing and file management, which distinguishes it from the characteristics of a Data Class."
ExcelWriter.java,"Let's analyze the provided `ExcelWriter` class step by step according to the criteria for identifying a ""Data Class"":

1. **Fields:**
   - The class has several fields, including `ExcelBuilder excelBuilder`. 
   - These fields are not exposed directly; they don't appear to be public or package-private.

2. **Accessors:**
   - The class does not show simple getter and setter methods. 
   - There are no methods labeled as getters or setters specifically for the fields.

3. **Methods and Behavior:**
   - The class contains methods that perform meaningful operations, such as `write`, `fill`, `finish`, and methods to manage the context (`writeContext`).
   - Most of its methods (`write`, `fill`, `merge`) involve business logic or complex operations, such as writing to a workbook, filling data, and merging cells.

4. **Encapsulation:**
   - The class hides its data behind methods that perform operations, meaning that the internal state is not directly exposed.
   - Methods like `write`, `fill`, and `merge` abstract the internal operations, which is a sign of good encapsulation.

5. **Local Symptom Summary:**
   - The class does not look like a primary data holder with minimal real behavior. 
   - The methods provided are substantial and perform complex operations rather than just setting or getting fields.

**Conclusion:**
NO, I did not find Data Class. The evidence is that the class has methods that perform substantial operations (writing to Excel, filling data, merging cells) and does not primarily act as a simple data holder with minimal behavior."
MethodInfo.java,"Let's analyze the `MethodInfo` class based on the provided criteria for identifying the ""Data Class"" code smell:

1. **Fields**: 
   - The class defines several fields: `owner`, `access`, `name`, and `desc`. These fields are private, which is good practice, but still serves as a base for our analysis.

2. **Accessors**: 
   - The class has many simple getter and setter methods corresponding to each field. The methods are straightforward and do not contain any complex logic.

3. **Methods and Behavior**: 
   - Besides the getters and setters, there are no other methods in the class. This indicates a lack of additional behavior beyond data manipulation.

4. **Encapsulation**: 
   - The data is not directly exposed since the fields are private. However, the data is easily accessible and modifiable through the provided getter and setter methods.

5. **Local Symptom Summary**: 
   - The class appears to be primarily a data holder with minimal real behavior, as it mainly consists of fields and their corresponding getters/setters.

**Conclusion**: 
Given the analysis, this class strongly exhibits symptoms of a Data Class. 

**Answer**: 
YES, I found Data Class. The clearest evidence is that almost all methods are getters/setters and there is no other meaningful behavior."
ApolloDataSourceFactoryBean.java,"Let's analyze the Java file step by step based on the symptoms of the ""Data Class"" code smell you mentioned:

### 1. Fields:
The class `ApolloDataSourceFactoryBean` defines several fields (`namespaceName`, `flowRulesKey`, `defaultFlowRuleValue`, and `converter`), and they are private. This is a good sign towards encapsulation, but let’s look deeper.

### 2. Accessors:
The class provides simple getter and setter methods for each field. This is consistent with the definition of a data class, as it mainly follows the pattern of exposing fields through accessors.

### 3. Methods and Behavior:
The class has methods that are primarily getters/setters. Additionally, it overrides methods from the `FactoryBean` interface (`getObject` and `getObjectType`). However, these methods do not seem to encompass complex behavior or perform substantive work beyond returning data or creating an instance.

### 4. Encapsulation:
The fields are private, which is a sign of good encapsulation, but they are exposed through getters and setters extensively. This makes the data easily accessible from outside the class, which aligns with the data class behavior where detailed operations are less present.

### 5. Local Symptom Summary:
Based on the analysis, the class primarily contains fields with corresponding getters and setters. The class does not have many methods performing substantive tasks; instead, it focuses on data exposure via the implemented methods from the `FactoryBean` interface.

### Conclusion:
**YES, I found Data Class**  
The clearest evidence is that almost all methods are getters/setters, with no substantive logic or behavior."
UmsMemberService.java,"NO, I did not find Data Class.  

The provided file defines an interface, `UmsMemberService`, which outlines method signatures for user management operations such as registration, updating passwords, and fetching user details. Since it is an interface and not a class, it does not have fields or the implementation of accessor methods. The methods described are substantive operations rather than just getters or setters, indicating that this is not a Data Class."
BillboardParticleBatch.java,"Let's analyze this Java file step by step for symptoms that may indicate the ""Data Class"" code smell:

1. **Fields**:
   - The class `BillboardParticleBatch` has several fields that store various configurations and data, like `vertices`, `indices`, `renderables`, `renderablePool`, and others. These fields are essential for managing the rendering of particles but are not exposed directly.

2. **Accessors**:
   - There are getter and setter methods for several fields, e.g., `setVertexData`, `setAlignMode`, `getAlignMode`, `setUseGpu`, `isUseGPU`, `setTexture`, and `getTexture`. These methods primarily modify or provide access to the fields.

3. **Methods and Behavior**:
   - The class includes methods like `fillVerticesGPU`, `fillVerticesToScreenCPU`, `fillVerticesToViewPointCPU`, `flush`, `getRenderables`, `save`, and `load`, which involve complex operations like rendering, saving/loading resources, and managing particles' data.
   - There are also methods with detailed logic for setting up renderables, calculating vertices, and preparing data for rendering, which indicates substantial behavior.

4. **Encapsulation**:
   - The class encapsulates data well by not exposing fields directly. Instead, it provides methods to modify and access its internal state in a controlled manner.
   - The fields are not public; they are package-private and private, which reduces data exposure.

5. **Local Symptom Summary**:
   - While the class does have fields and accessors, it also contains several methods that perform significant and complex operations relating to the internal state. This class is more than a simple data holder; it has substantial behavior related to the rendering process and managing particle system data.

Based on this analysis, there are not strong symptoms of a Data Class since the class includes significant behavior beyond just holding data. Therefore:

**NO, I did not find Data Class**. The main behavior here involves complex rendering and data management for particles, not just storing or retrieving data."
BrokerController.java,"Let's analyze the provided Java file for the ""Data Class"" code smell based on the criteria you outlined:

1. **Fields:**
   - The `BrokerController` class defines over fifty fields, including `brokerConfig`, `nettyServerConfig`, `nettyClientConfig`, several manager objects (`consumerOffsetManager`, `consumerManager`, `producerManager`, `pullMessageProcessor`, etc.), executors, queues, pools, and more. Many of these fields are initialized in the constructor.

2. **Accessors:**
   - The class contains numerous getter and setter methods for its fields, such as `getBrokerConfig()`, `getBrokerStats()`, `setBrokerStats(BrokerStats brokerStats)`, `getPullMessageExecutor()`, etc. These methods are simple and do not perform any additional logic besides accessing or modifying the class fields.

3. **Methods and Behavior:**
   - Most methods perform setup, configuration, and coordination tasks, such as `initialize()`, `registerProcessor()`, `start()`, `shutdown()`, and handling broker roles like `changeToSlave()` and `changeToMaster()`. These methods involve complex logic, involve multiple components, and perform actual operations beyond simply reading or setting fields.

4. **Encapsulation:**
   - While the class does provide a getter for many fields, it does not expose all fields directly. It does have public accessors (getters and setters) for its fields, but it doesn't expose more than it hides functionality.

5. **Local Symptom Summary:**
   - The class has many fields and provides getter and setter methods for most of them, but it also contains significant behavior methods that perform meaningful operations, such as initializing the broker, configuring remoting servers, and managing the lifecycle of the broker.

**Conclusion:**
- Based on the analysis, while the class does have many fields and accessor methods, it also contains non-trivial methods that execute complex logic. Therefore, this class does not represent a typical ""Data Class"" as it has meaningful behavior beyond just holding and providing access to data.

**Answer:**
NO, I did not find Data Class. The class contains many methods that perform substantive work, such as initializing, starting, and shutting down the broker, making it more of a service class than a simple data holder."
StringUtils.java,"NO, I did not find Data Class.

### Analysis:

1. **Fields:**
   - The class `StringUtils` does not define any fields. It consists only of static methods and a private static final field `PAD_LIMIT` and a public static final field `INDEX_NOT_FOUND`, which are constants used within the class methods.

2. **Accessors:**
   - There are no getter or setter methods in the class.

3. **Methods and Behavior:**
   - The class contains a large number of static methods that perform various operations on strings, such as trimming, replacing substrings, joining strings, and other utility functions. These methods are not simple field accessors or mutators; they perform significant work related to string manipulation.

4. **Encapsulation:**
   - The class does not expose any fields directly. Instead, it provides a variety of static methods to manipulate and process strings, enhancing encapsulation by not exposing internal data structures.

5. **Local Symptom Summary:**
   - The class is clearly focused on providing utility methods for string manipulation, rather than holding data. There is no evidence of it being primarily a data holder as it contains no fields (except constants) and its methods perform meaningful operations.

Based on these points, `StringUtils` does not exhibit symptoms of a Data Class."
PacketEncoder.java,"**NO, I did not find Data Class.**

### Analysis:

1. **Fields:**
   - The class has several fields, such as `jsonSupport` and `configuration`. These fields are private, indicating some level of encapsulation.

2. **Accessors:**
   - There is one public getter method, `getJsonSupport()`, but there are no corresponding setters. There are no other fields exposed through simple getters/setters.

3. **Methods and Behavior:**
   - The class contains numerous methods that perform substantive work, such as `encodeJsonP()`, `encodePackets()`, `encodePacket()`, `processUtf8()`, and various utility methods for handling data encoding and conversion tasks. These methods are not merely accessing or modifying fields.

4. **Encapsulation:**
   - The class maintains encapsulation by keeping fields private and providing a method to access one of them (`jsonSupport`). The other field (`configuration`) is used internally without exposure.

5. **Local Symptom Summary:**
   - The class primarily consists of methods that perform data encoding and handling, indicating significant behavior rather than merely holding data. Therefore, this does not exhibit the characteristics of a Data Class."
FastByteArrayOutputStream.java,"### Analysis

**1. Fields:**
The file defines a class with a single private field: `private final FastByteBuffer buffer;`. This does not suggest a Data Class because there is only one field.

**2. Accessors:**
There are no public fields, and the class does not have a large number of simple getter and setter methods for its fields. It does define methods like `size()` which are not simple getters but retrieve a computed property based on the internal state.

**3. Methods and Behavior:**
The class extends `OutputStream` and includes several methods that perform meaningful operations such as `write(byte[] b, int off, int len)`, `write(int b)`, `reset()`, `writeTo(OutputStream out)`, `toByteArray()`, and several `toString()` methods that involve processing or conversion logic. These methods are indicative of real behavior beyond simple data storage and retrieval.

**4. Encapsulation:**
The class encapsulates its data, as the field `buffer` is private, and only interacts with the data through defined methods that perform operations. This suggests good encapsulation rather than exposing the data directly.

**5. Local Symptom Summary:**
The class does not appear to be a primary data holder with minimal real behavior. It inherits from `OutputStream`, has a focused purpose (handling byte array operations), and includes methods that perform substantial work beyond simple data storage and retrieval. The class clearly has significant behavior and does not solely serve as a data carrier.

### Conclusion

NO, I did not find Data Class. The class includes meaningful methods that perform substantive operations, and it does not primarily act as a simple data holder."
BinaryRedisPipeline.java,"1. **Fields**: The file defines an interface, `BinaryRedisPipeline`, which does not have any fields defined. Interfaces in Java are not supposed to have fields (except for `public static final` constants), so this characteristic is not relevant here. However, the methods suggest that instances implementing this interface might use many fields to operate on.

2. **Accessors**: The interface does not have any methods that are simple getters or setters. It has many method declarations that are related to operations on a Redis database, which are not accessors.

3. **Methods and Behavior**: The class (or rather, interface) has many methods, but they are all related to operations on a Redis database (like `set`, `get`, `hget`, `zadd`, etc.). They provide actual behavior that interacts with a Redis server, not just data manipulation.

4. **Encapsulation**: The interface does not expose its data through get/set methods; instead, it abstractly describes operations that can be performed. This suggests proper encapsulation as it hides the internal state of the implementing classes.

5. **Local Symptom Summary**: The interface seems to be primarily a set of method declarations for operations on a Redis database rather than a data holder. There is significant behavior represented by the methods, which indicates that it does not fit the profile of a Data Class.

**Conclusion**: NO, I did not find Data Class. The interface `BinaryRedisPipeline` represents a protocol or API for Redis operations, not a data holder with minimal behavior. The methods are all about interacting with a Redis database and do not exhibit signs of being simple data storage and retrieval functionalities."
LineTransformationOutputStream.java,"Let's analyze the provided Java file based on the criteria for detecting a ""Data Class"":

1. **Fields**:  
   - The class `LineTransformationOutputStream` has a single private field `buf` which is of type `ByteArrayOutputStream2`. This does not indicate a class with many fields.

2. **Accessors**:  
   - There are no simple getters or setters defined for any fields. The class does not expose its fields directly or through many simple accessors.

3. **Methods and Behavior**:  
   - The class has several methods (`write(int b)`, `write(byte[] b, int off, int len)`, `close()`, `forceEol()`, `trimEOL(String line)`) that perform meaningful operations such as writing data, handling end-of-line conditions, and manipulating text. There is more than just simple getters/setters.

4. **Encapsulation**:  
   - The class encapsulates its data (the content of lines is not directly exposed). The field `buf` is private, and the class provides methods to write data and handle EOL conditions safely.

5. **Local Symptom Summary**:  
   - The class does not look like a primarily data holder with minimal real behavior. It has meaningful methods that perform substantial work rather than being just a container for data.

**Conclusion**:
NO, I did not find Data Class. The clear evidence is that the class `LineTransformationOutputStream` contains methods that do substantive work, such as handling line transformations and writing data, which is contrary to the characteristics of a Data Class."
RedissonObject.java,"Let's analyze the Java file to determine if it shows symptoms of the ""Data Class"" code smell according to the given criteria:

1. **Fields:**
   - The class defines several fields such as `commandExecutor`, `name`, and `codec`. However, these fields are not public; they are either `protected` or private constructors.

2. **Accessors:**
   - The class has a few getter methods like `getName()` and `getCodec()`. It also has setters like `setName(String name)`.
   - However, the class contains numerous other methods that perform operationsAsync with Redis and are not simple data accessors.

3. **Methods and Behavior:**
   - There are many methods that perform actual work such as `sizeInMemoryAsync`, `rename`, `copy`, `move`, `delete`, `touch`, `isExists`, `dump`, `restore`, `addListener`, and many more. These methods involve interaction with Redis and perform substantial work, not just field manipulation.

4. **Encapsulation:**
   - The class encapsulates its data behind meaningful operations. While it provides `getName()` and `getCodec()` to access some of its data, the methods provide a clear interface to interact with Redis rather than directly exposing the data.

5. **Local Symptom Summary:**
   - The class has multiple fields, some of which are exposed through getters but does not primarily consist of just getters and setters. The class does a lot of interaction with Redis through asynchronous operations, which is not typical for a Data Class.

Based on the analysis, **NO, I did not find Data Class**. The provided class includes substantial behavior beyond just holding and providing access to data. It performs various operations pertinent to Redis, which suggests it serves a purpose beyond being merely a data holder."
DokanyVolume.java,"NO, I did not find Data Class.

**Explanation:**

1. **Fields:** The class contains several fields, including `vaultSettings` and `mount`. However, they are not public or package-private, and there are no direct access to these fields outside of the class.

2. **Accessors:** There are no simple getter or setter methods for the fields; accessing `mountPoint` in the `mount` method is through an overridden method from a superclass, and `vaultSettings` is used within the methods.

3. **Methods and Behavior:** The class has more than just getter and setter methods. It includes methods like `mount`, `reveal`, `unmount`, `unmountForced`, `supportsForcedUnmount`, `isSupported`, and `getMountPointRequirement`, which involve meaningful behavior such as file system operations and state management.

4. **Encapsulation:** The class encapsulates its data by using private fields and only exposing them through methods that have business logic or functional behavior.

5. **Local Symptom Summary:** The class does not primarily serve as a data holder. It contains substantial business logic and does not exhibit the patterns of a Data Class."
AnalysisContext.java,"Let's analyze the provided Java file step by step according to the criteria for detecting the ""Data Class"" code smell:

1. **Fields:**
   - The file defines an **interface**, not a class, which means there are no fields explicitly defined here. Interfaces in Java cannot have fields; they can only have abstract methods (and constants).

2. **Accessors:**
   - The interface consists primarily of getter and setter methods for various properties like `ReadWorkbookHolder`, `ReadSheetHolder`, `ReadRowHolder`, `custom attribute`, `AnalysisEventProcessor`, and `readSheetList`. There are also some deprecated methods that were presumably getters.

3. **Methods and Behavior:**
   - Most of the methods provide access to internal state (getters) or modify it (setters) with minimal additional behavior. Apart from these, there's only one non-deprecated method `currentSheet(ReadSheet readSheet)` which handles context switching or initialization but does not contain substantial business logic.

4. **Encapsulation:**
   - The interface exposes all its intended data through methods, and it does not hide any data behind complex operations or services. The deprecated methods show a desire to hide or redirect access to more encapsulated methods.

5. **Local Symptom Summary:**
   - The interface is primarily a collection of accessor methods with very little substantive behavior. Given the nature of interfaces, direct fields cannot be present, but the nature of this interface suggests it could have been or is intended to be a simple data structure.

**Conclusion:**
Despite it being an interface, the provided interface displays strong symptoms of the Data Class code smell. The methods are almost entirely accessors, and there is no presence of significant business logic or processing behavior.

**Answer:**
YES, I found Data Class. The main sign is that the interface consists almost entirely of getter and setter methods with minimal meaningful behavior."
ClassLoaderModel.java,"**Analysis:**

1. **Fields:**
   - The class defines several private fields (`classSet`, `resources`, `loadClass`, `urls`, `classLoaders`, `tree`, `classLoaderStats`, `matchedClassLoaders`, `classLoaderClass`).
   - These fields are not public but do have corresponding getters and setters, which is a typical pattern for data classes.

2. **Accessors:**
   - The class has a large number of getter and setter methods.
   - Each private field has a corresponding getter and a setter method, which is characteristic of a data class.

3. **Methods and Behavior:**
   - The class has only one substantial method, `getType()`, which returns a string.
   - The remaining methods are all simple getters and setters, indicating minimal functionality except for data encapsulation.

4. **Encapsulation:**
   - The class encapsulates data well by keeping fields private.
   - However, it exposes all its data through getters and setters, which is a common trait of data classes.

5. **Local Symptom Summary:**
   - The class is primarily a holder for data with minimal real behavior.
   - The main sign is that almost all methods are getters/setters.

**Conclusion:**
YES, I found Data Class.  
**Evidence:** Almost all methods are getters/setters."
MethodRoadie.java,"Let's analyze the provided Java file, `MethodRoadie.java`, for symptoms of the ""Data Class"" code smell:

1. **Fields:**
   - The class defines several fields (`test`, `notifier`, `description`, `testMethod`), but none of them are public or package-private. They are private, which suggests some level of encapsulation.

2. **Accessors:**
   - There are no simple getter or setter methods provided for the fields. The only public method that interacts with the fields is the constructor.

3. **Methods and Behavior:**
   - The class contains methods that do substantive work (`run`, `runWithTimeout`, `runTest`, `runBeforesThenTestThenAfters`, `runTestMethod`, `runBefores`, `runAfters`, and `addFailure`). These methods handle test execution, timeout management, and error handling, which suggests the class has significant behavior.

4. **Encapsulation:**
   - The class encapsulates its data fields by keeping them private and providing a constructor and other methods to interact with them, which aligns with good object-oriented practices rather than exposing its data freely.

5. **Local Symptom Summary:**
   - The class is not primarily a data holder with minimal real behavior. It has multiple methods that implement significant logic related to test execution, not just get or set operations.

**Conclusion:**
NO, I did not find Data Class. The main evidence is that the class includes substantial methods that handle core functionality (test execution, error handling, etc.) rather than just being a container for data with simple accessor methods."
StubConnection.java,"Let's analyze the provided `StubConnection` class based on the criteria for Detecting Data Class code smell:

1. **Fields**:
   - The class defines several fields such as `isClosed`, `autoCommit`, `isolation`, `catalog`, `waitTimeout`, and more.
   - Not all fields are publicly exposed, but many are exposed through getter and setter methods.

2. **Accessors**:
   - There are numerous getter and setter methods (e.g., `getAutoCommit()`, `setAutoCommit(boolean)`, `getCatalog()`, `setCatalog(String)`).
   - While there are methods other than getters and setters, many of the public methods are indeed accessors.

3. **Methods and Behavior**:
   - There are many methods that only provide the boilerplate implementation required by `Connection`, with minimal real behavior.
   - Methods like `setAutoCommit`, `getCatalog`, `refreshConnectionWaitTimeout`, etc., primarily manipulate the internal state without significant processing logic.
   
4. **Encapsulation**:
   - The class uses private fields for internal state, which could be seen as encapsulated.
   - However, many fields are exposed through public getter and setter methods, reducing the level of encapsulation.

5. **Local Symptom Summary**:
   - The class has a structure typical of a stub/mock implementation used for testing, but its primary role still revolves around managing state and providing simple data retrieval and modification operations.
   - Almost all public methods are accessors, which is a strong indicator of the Data Class code smell.

Based on the analysis:

**YES, I found Data Class**  
**Clearest evidence:** ""Almost all public methods are simple getters/setters."""
ExpandedProductParsedResult.java,"### Analysis for Data Class Smell in `ExpandedProductParsedResult`

Let's break down the file based on the criteria for a Data Class:

1. **Fields**:  
   The `ExpandedProductParsedResult` class defines several fields (`rawText`, `productID`, `sscc`, `lotNumber`, `productionDate`, `packagingDate`, `bestBeforeDate`, `expirationDate`, `weight`, `weightType`, `weightIncrement`, `price`, `priceIncrement`, `priceCurrency`, `uncommonAIs`), and they are all private. While having many fields is a sign, their visibility level is private, which is a good practice. However, the large number of fields is still a concern.

2. **Accessors**:  
   There is a significant number of simple getter methods (one for each field), and there are no setter methods. The class doesn't define any setter methods due to using `final` fields, which indicates that these properties are intended to be immutable. This matches the pattern of a Data Class.

3. **Methods and Behavior**:  
   There are very few methods that do substantive work. The class primarily contains the constructor and the getter methods. The overridden `equals`, `hashCode`, and the `getDisplayResult` method are also simple and do not represent complex business logic. 

4. **Encapsulation**:  
   The class hides its internal state effectively by using private fields. The only way to access the fields is through public getter methods, which is good encapsulation. However, the large amount of data exposed via these getters is still characteristic of a Data Class.

5. **Local Symptom Summary**:  
   Based on the patterns above, the class looks like it is primarily a data holder with minimal real behavior. The main sign is that almost all methods are getters, and there are no setter methods due to immutable design.

### Conclusion

**YES, I found Data Class**  
The clearest evidence is that almost all methods are simple getters, and there are no setter methods, making it more of a data container with little behavior."
SaFoxUtil.java,"After analyzing the provided Java file, here are the findings based on the criteria for a ""Data Class"" code smell:

1. **Fields:**  
   The file defines a class (`SaFoxUtil`) that does not have any fields. It consists only of static methods and a static final string (`URL_REGEX`), indicating it is more of a utility class rather than a data container.

2. **Accessors:**  
   There are no getter or setter methods in this class. The class does not have any instance variables to manage through accessor methods.

3. **Methods and Behavior:**  
   The class contains numerous methods that perform substantive work. These methods include:
   - Printing a version string.
   - Generating random strings.
   - Checking for null or empty strings.
   - Formatting dates.
   - Searching within collections.
   - Matching patterns.
   - Converting types.
   - Manipulating URLs.
   - Joining arrays and lists into strings.
   - Decoding and encoding URLs.
   - Splitting strings to lists and vice versa.

4. **Encapsulation:**  
   The class does not expose any data fields since there are none. All functionality is encapsulated within its static methods.

5. **Local Symptom Summary:**  
   The class is primarily composed of static utility methods performing a variety of operations. There is no indication of it being a data container or holding state.

**Conclusion:**  
NO, I did not find Data Class. The class `SaFoxUtil` is a utility class with a variety of methods for performing specific tasks, and it does not exhibit the characteristics of a Data Class."
Stage.java,"Let's analyze the provided Java file for symptoms of the ""Data Class"" code smell by examining the key points you've outlined:

1. **Fields:**
   - The `Stage` class defines several fields including `viewport`, `batch`, `ownsBatch`, `root`, and various others related to input handling and debugging. However, these fields are not exposed publicly and do not have all fields with simple getters and setters.

2. **Accessors:**
   - The class has several getter and setter methods such as `getBatch()`, `getViewport()`, `setViewport(Viewport)`, and others related to the viewport, camera, and debug settings. However, these do not dominate the class.

3. **Methods and Behavior:**
   - The class includes methods like `draw()`, `act()`, which involve rendering and updating the scene, as well as handling input events (`touchDown`, `touchDragged`, `touchUp`, `mouseMoved`, `scrolled`, `keyDown`, `keyUp`, `keyTyped`).
   - These methods are not merely setting or getting values but are performing significant logic related to rendering, handling input, and managing actors.

4. **Encapsulation:**
   - The class appropriately encapsulates its data. It does not expose its fields publicly and maintains internal states through methods that perform meaningful actions. The data is hidden behind meaningful services, such as `draw()` and `act()`.

5. **Local Symptom Summary:**
   - The `Stage` class does not primarily hold data as it has methods that perform meaningful operations, such as rendering and handling user input. The methods are not just simple getters/setters; they include significant functionality.

**Conclusion:**
NO, I did not find Data Class. The `Stage` class is not a Data Class as it involves significant business logic and meaningful behavior beyond just holding and exposing data."
Finance.java,"Let's analyze the `Finance` class in the provided Java file using the symptoms of a Data Class.

1. **Fields:**
   - The class has a single field `private final Faker faker;`. There are no other fields that seem like they hold significant data for the class.
   - It also includes a key-value map, `countryCodeToBasicBankAccountNumberPattern`, which is a static field used for generating IBANs.

2. **Accessors:**
   - There are no explicit getter or setter methods for the `faker` field or any other fields. The `faker` field is used directly within the methods.

3. **Methods and Behavior:**
   - The class contains several methods (`creditCard(CreditCardType creditCardType)`, `creditCard()`, `bic()`, `iban()`, `iban(String countryCode)`) that generate financial information.
   - There are also some private helper methods (`randomCreditCardType()`, `sum(String[] string)`, `calculateIbanChecksum(String countryCode, String basicBankAccountNumber)`) that perform specific calculations.
   
4. **Encapsulation:**
   - The class does not expose its fields directly (`faker` field is private and has no getters). The data is hidden behind methods that perform specific tasks.
   - The only static field `countryCodeToBasicBankAccountNumberPattern` is not exposed directly and is used internally.

5. **Local Symptom Summary:**
   - The class does not primarily look like a data holder with minimal real behavior. It mainly contains methods that perform complex logic to generate financial identifiers (credit card numbers, BIC, IBAN).

**Conclusion:**
NO, I did not find Data Class
- The `Finance` class contains substantial behavior and methods that perform meaningful calculations and generate financial information. It does not look like a data holder class with minimal behavior."
AdminBrokerProcessor.java,"**NO, I did not find Data Class.**

Here's the local symptom summary based on the provided file:

1. **Fields**: The class `AdminBrokerProcessor` has fields such as `private static final InternalLogger log` and `private final BrokerController brokerController`. There are no numerous fields that it primarily holds, and the fields it has are not exposed directly or via simple getters/setters.

2. **Accessors**: There are a couple of private fields that do not have corresponding accessors. The primary interaction with fields is through the methods, which process requests and handle the business logic rather than exposing the state through getters/setters.

3. **Methods and Behavior**: The class has numerous methods, each handling a specific kind of request. These methods contain substantial business logic and are not merely getters/setters.

4. **Encapsulation**: While the class uses a single field `brokerController`, it does not expose it directly. Instead, it encapsulates the logic required for processing requests, pointing towards good encapsulation.

5. **Local Symptom Summary**: The class is primarily involved in processing requests, handling business logic, and interacting with other components to fulfill those requests. It does not serve as a simple container for data, nor does it expose its internal state excessively through simple accessors.

Based on these points, the class does not exhibit the symptoms of a Data Class code smell."
PreparedStatementHandler.java,"Let's analyze the provided Java file to determine if it shows symptoms of the ""Data Class"" code smell:

1. **Fields:**
   - The class `PreparedStatementHandler` does not explicitly define many fields within the provided code snippet. It only holds the fields it inherits from `BaseStatementHandler`.

2. **Accessors:**
   - There are no explicit getter or setter methods defined for the fields within `PreparedStatementHandler`. This suggests the fields are probably handled through inheritance or direct access, but not through many simple accessor methods in this class.

3. **Methods and Behavior:**
   - The methods provided (`update`, `batch`, `query`, `queryCursor`, `instantiateStatement`, `parameterize`) contain significant behavior, such as executing SQL statements, handling result sets, and managing parameters. These are not merely getters or setters, which indicates substantive behavior.

4. **Encapsulation:**
   - The class does not expose its data fields directly since there are no public fields defined and the fields are likely encapsulated in the parent class. The methods provided do not expose internal state but rather perform operations with it.

5. **Local Symptom Summary:**
   - Based on the analysis, the class does not primarily serve as a data holder with minimal real behavior. It contains several methods that perform specific tasks related to handling SQL operations, which is far from just exposing data.

**Conclusion:**
NO, I did not find Data Class. The provided methods perform significant operations and the class has a notable behavior which does not align with the characteristics of a Data Class."
SmsFlashPromotionProductRelationServiceImpl.java,"NO, I did not find Data Class.  

The provided code is an implementation of a service class, `SmsFlashPromotionProductRelationServiceImpl`, which manages the operations related to `SmsFlashPromotionProductRelation` entities. This class does not have several fields; instead, it interacts with dao and mapper classes to perform CRUD operations and more complex queries. There are no getters or setters present in this file, and the methods perform substantial work such as database operations, business logic regarding pagination, and aggregation (like `getCount`). Therefore, this class does not resemble a Data Class as it is not primarily a holder of data but a service with meaningful business logic."
PrefixPluginLogger.java,"Let's analyze the provided Java class `PrefixPluginLogger` according to the criteria for identifying the Data Class code smell:

1. **Fields:**
   - The class defines fields `markers` and `marker`. The `markers` field is static and package-private, while the `marker` field is private. 

2. **Accessors:**
   - The class has very few accessor methods. There is a getter `prefix()` for the `marker` field, and no setters are present.
   
3. **Methods and Behavior:**
   - The methods in this class do more than just set/get values. The `markersSize()` method returns the size of the `markers` map, which involves internal data but is not related to the marker object. The `logMessage()` method handles logging with additional logic that is not found in typical data classes. The constructor also contains logic for managing and retrieving markers.

4. **Encapsulation:**
   - The class encapsulates its state properly. The `marker` field is private, and the `markers` field is static but does not have public setters/getters aimed at exposing its content directly. The internal logic seems to protect the integrity of its state.

5. **Local Symptom Summary:**
   - The class has a few methods, but most of them are doing more significant work than simple attribute access. The core functionality of the class seems to be related to logging with a prefix, not just holding data.

**Analysis Result:**
NO, I did not find Data Class. The class does include some data fields, but the methods provided perform a variety of operations that indicate the class is providing substantial behavior beyond just storing data."
BitMatrix.java,"Let's analyze the Java file step by step based on the questions provided to determine if it exhibits the characteristics of a ""Data Class"":

1. **Fields:**
   - The file defines a class (`BitMatrix`) with several fields: `width`, `height`, `rowSize`, and `bits`. These fields are private, which is not typical of a Data Class that often exposes its fields.

2. **Accessors:**
   - There are several getter methods for the fields (`getWidth()`, `getHeight()`, `getRowSize()`). There are no setter methods for the fields themselves, which might suggest more controlled access rather than simple getters and setters.

3. **Methods and Behavior:**
   - The class includes a significant number of methods that perform substantive work, such as `set()`, `unset()`, `flip()`, `xor()`, `clear()`, `setRegion()`, `getRow()`, `setRow()`, `rotate180()`, `getEnclosingRectangle()`, `getTopLeftOnBit()`, `getBottomRightOnBit()`, `parse()`, and custom `equals()`, `hashCode()`, and `toString()` implementations. These methods indicate that the class handles various operations related to a 2D bit matrix, not just accessing or modifying fields directly.

4. **Encapsulation:**
   - The class uses private fields and provides controlled access to them through methods. This encapsulation is contrary to what a Data Class usually exhibits, which tends to expose its fields openly.

5. **Local Symptom Summary:**
   - Despite having getter methods for a few fields, the class is primarily designed to handle operations on a 2D bit matrix. It includes many methods that implement business logic related to the matrix operations, which is inconsistent with being a Data Class.

Based on the analysis, the class does not exhibit strong signs of being a Data Class. The presence of numerous methods that perform meaningful operations, the use of private fields, and the controlled access patterns all suggest more than a simple data holder.

**Answer:** NO, I did not find Data Class."
JobTriggerPoolHelper.java,"Let's analyze the file based on the criteria for the Data Class code smell.

1. **Fields**:
   - The class has several fields such as `fastTriggerPool`, `slowTriggerPool`, `minTim`, and `jobTimeoutCountMap`.
   - The fields are not public. They are package-private.

2. **Accessors**:
   - The class does not have many simple getter and setter methods. The only public methods are `start()`, `stop()`, `addTrigger()`, and the static methods `toStart()`, `toStop()`, and `trigger()`.

3. **Methods and Behavior**:
   - The class has methods that do substantive work. Specifically, the `addTrigger` method is implementing logic to choose a thread pool based on job timeout and executing the job. 
   - The `start()` and `stop()` methods manage the lifecycle of the thread pools.

4. **Encapsulation**:
   - The fields are encapsulated and accessible only through methods. Low exposure of internal data is noted.

5. **Local Symptom Summary**:
   - Although the class does have several fields, the methods provided do significant work, including managing concurrent execution and handling job triggering based on conditions.
   - Given the presence of such behavior, it does not conform to the Data Class smell, as it has more than just getters and setters.

**Conclusion**:
NO, I did not find Data Class. The class has several fields but also includes methods that perform substantive work, such as managing thread pools and job triggering."
MigrationRunController.java,"Let's analyze the provided Java file step by step for the ""Data Class"" code smell.

### 1. Fields
The class defines several fields, including `window`, `vault`, `executor`, `scheduler`, `keychain`, `missingCapability`, `errorComponent`, `startScene`, `successScene`, `capabilityErrorScene`, `impossibleScene`, `migrateButtonContentDisplay`, `migrationButtonDisabled`, and `migrationProgress`. The `passwordField` is an FXML field and is declared as `public`. The other fields are package-private. There is a mix of fields being exposed directly and through property accessors.

### 2. Accessors
The class includes several simple getter methods such as `getVault()`, `migrationButtonDisabledProperty()`, `isMigrationButtonDisabled()`, `migrateButtonContentDisplayProperty()`, `getMigrateButtonContentDisplay()`, `migrationProgressProperty()`, and `getMigrationProgress()`. Most of these methods are related to accessing the state of the object.

### 3. Methods and Behavior
While the class has methods like `initialize()`, `back()`, `migrate()`, `migrationProgressChanged()`, `migrationRequiresInput()`, and `loadStoredPassword()`, these methods are not limited to just getting or setting fields. They perform significant actions such as initializing components, handling user interactions, managing UI state, running background tasks, and error handling.

### 4. Encapsulation
The class attempts to encapsulate its data through the use of property accessors and not exposing the fields directly. However, the `passwordField` is declared `public`, which might break encapsulation.

### 5. Local Symptom Summary
While the class has several fields and accessor methods, it also contains substantial methods that perform significant operations beyond just getting and setting fields.

**Conclusion:**
Based on the analysis, the class does not strongly exhibit the ""Data Class"" code smell. It has both fields and meaningful behavior methods that are crucial for its functionality as a controller in a JavaFX application. Therefore, the answer is:

NO, I did not find Data Class. The class contains significant methods that perform business logic and handle UI interactions, not just data storage and retrieval."
Internet.java,"Let's analyze the provided Java file based on the criteria for identifying a ""Data Class"" code smell:

1. **Fields**:
   - The class `Internet` does not define many fields (attributes). It only has one private final field `private final Faker faker;`, which is a dependency injection.

2. **Accessors**:
   - The class has no getter or setter methods for any fields. The methods are focused on generating different types of internet-related data.

3. **Methods and Behavior**:
   - The class contains many methods that perform substantive work. These methods generate email addresses, domain names, URLs, passwords, MAC addresses, IPs (both IPv4 and IPv6), slugs, UUIDs, and user agents. Each method does significant processing and is not simply a getter or setter.

4. **Encapsulation**:
   - The class hides its data behind meaningful methods that perform operations to generate and return internet-related data. There is no direct exposure of fields, and the methods are focused on providing services rather than just accessing or setting data.

5. **Local Symptom Summary**:
   - The class does not exhibit characteristics of a Data Class. It has minimal fields and provides a variety of methods that perform useful, non-trivial operations to generate different types of internet-related data.

### Final Answer:
NO, I did not find Data Class. The main sign that this class is not a Data Class is the absence of multiple fields and the presence of many methods that perform substantive operations rather than being simple getters or setters."
AllMembersSupplier.java,"### Analysis of the Java File

#### 1. Fields:
- **Present:** The file defines a class with fields but primarily has one field `private final TestClass clazz;`.
- **Visibility:** `clazz` is private, hence not public or package-private.

#### 2. Accessors:
- **Accessors:** The file has no public getters or setters for its fields. The only field `clazz` is injected via a constructor and not exposed.
- **Pattern:** Not following the many getters/setters pattern.

#### 3. Methods and Behavior:
- **Methods:** Includes several methods that do substantive work. Methods like `getValueSources`, `addMultiPointMethods`, `addMultiPointFields`, etc., perform significant logic operations such as iterating over fields and methods, checking annotations, and manipulating collections.
- **Substantive Work:** There is no pattern of the class being primarily occupied by simple getter/setter methods.

#### 4. Encapsulation:
- **Encapsulation:** The class is well-encapsulated; its only field is private, and the class provides methods that perform meaningful operations without exposing its data through many getters/setters.

#### 5. Local Symptom Summary:
- **Summary:** The class does not exhibit the characteristics of a Data Class. It has minimal fields, most fields are well-encapsulated, and the methods contain significant business logic rather than being simple accessors.

### Conclusion:
**NO, I did not find Data Class.**
- The primary evidence is that the class contains a single private field and numerous methods that perform significant work rather than just providing access to data fields via getters/setters."
AwtCodec.java,"Let's analyze the provided Java file based on the criteria you've specified to determine if it shows signs of the Data Class code smell:

1. **Fields:**
   - The class does not define any fields. It only contains static fields (`instance`) and does not declare any data fields pertaining to Point, Rectangle, Font, or Color objects.

2. **Accessors:**
   - There are no simple getter or setter methods within the class. It uses static and instance methods to serialize and deserialize objects rather than providing accessors for fields.

3. **Methods and Behavior:**
   - The class contains substantial methods that perform work (`write`, `deserialze`, `parseFont`, `parseColor`, `parseRectangle`, `parsePoint`). These methods handle serialization and deserialization processes which do significant work and are not mere accessors.

4. **Encapsulation:**
   - The class does not expose data fields directly. It uses methods to handle data encapsulation and formatting. Fields like `x`, `y`, `width`, `height`, etc., are accessed within methods but not exposed publicly.

5. **Local Symptom Summary:**
   - The class does not appear to be a primary data holder with minimal real behavior. It provides a significant amount of behavior for serialization and deserialization of AWT objects.

Based on the analysis above, the class does not have strong symptoms of the Data Class code smell. It is primarily concerned with serialization and deserialization activities rather than just holding and exposing data.

**Answer:**
NO, I did not find Data Class."
OrderController.java,"NO, I did not find Data Class.

The provided file is a `RestController` class named `OrderController`. It is not primarily a data holder and does not exhibit the characteristics of a Data Class. While it does have some fields (such as `jdbcTemplate`, `restTemplate`, and `random`), and it also has a nested class `Order` that could be considered a potential data class candidate, the `OrderController` itself contains substantial business logic including:

1. Methods like `order`, `calculate`, and `invokerAccountService` which handle HTTP requests, database operations, and invocations of external services.
2. Fields that are not just data holders but are instead injected dependencies (`JdbcTemplate` and `RestTemplate`).

The `Order` class, which is nested within `OrderController`, indeed has multiple fields (`userId`, `commodityCode`, `count`, `money`, and `id`) and lacks methods that do significant work other than getters and setters. However, the question specifically asks to analyze the provided file, which is `OrderController.java`, not the `Order` class. Therefore, based on the `OrderController` class, it does not fit the pattern of a Data Class."
XxlJobInfoDao.java,"NO, I did not find Data Class.

**Explanation:**

The provided `XxlJobInfoDao` is an interface annotated with `@Mapper` for MyBatis, which indicates it is a Data Access Object (DAO) used for database operations. The presence of database-like methods such as `pageList`, `save`, `loadById`, `update`, `delete`, and query methods (`getJobsByGroup`, `findAllCount`, `scheduleJobQuery`, `scheduleUpdate`) suggests that this interface is primarily concerned with interacting with a database rather than holding or manipulating data itself. Therefore, it does not exhibit the characteristics of a Data Class which typically contains numerous fields with simple accessors and minimal behavior."
ConnectionPool.java,"Let's analyze the file step by step based on the criteria provided:

1. **Fields:**
   - The class `ConnectionPool<T extends RedisConnection>` defines several fields: `entries`, `connectionManager`, `config`, `masterSlaveEntry`. These fields are not public; they are package-private or protected.

2. **Accessors:**
   - The class does have getter methods like `getMinimumIdleSize(ClientConnectionsEntry entry)` and implicitly uses getter/setter patterns within its methods, but these are not trivial or only for exposing fields. They are part of complex business logic (e.g., managing connections, initializing them, etc.).

3. **Methods and Behavior:**
   - The class includes a considerable number of methods that implement meaningful behavior, such as managing and initializing connections. Methods like `add`, `initConnections`, `get`, `acquireConnection`, `tryAcquireConnection`, `createConnection`, etc., are not just simple getters/setters but are integral parts of the class's functionality.

4. **Encapsulation:**
   - The class encapsulates its data behind meaningful methods. It does not expose its internal state directly. For instance, the `entries` queue is manipulated only through methods that maintain the state of connections.

5. **Local Symptom Summary:**
   - Based on the above, the class `ConnectionPool` does not look like a Data Class. It has multiple fields but manages these fields through behavior that is crucial to its primary function (managing a pool of connections). The methods perform significant logic rather than just accessing or setting field values.

**Conclusion:**

NO, I did not find Data Class. The main sign that contradicts the Data Class smell is that the class has substantial behavior and logic beyond mere data storage, such as connections management, initialization, and error handling."
LinkedHashMultimap.java,"NO, I did not find Data Class.

### Explanation:

1. **Fields**: The file defines several fields, but they are mostly private or package-private, indicating encapsulation rather than direct exposure.
   
2. **Accessors**: While there are methods like `create`, `replaceValues`, `entries`, `keySet`, `values`, and others that might seem like simple getters, they are not just simple accessors. They perform significant functionality related to maintaining the data structure and handling operations on the multimap.

3. **Methods and Behavior**: The methods in the class perform substantial work, including maintaining the order of insertion, handling duplicate entries, managing the internal data structure, and implementing the required multimap operations.

4. **Encapsulation**: The class encapsulates its data effectively. Methods like those mentioned under ""Methods and Behavior"" manage the state internally and do not expose raw data or simple data manipulation. The fields are accessed through meaningful methods that enforce the multimap's behavior and maintain its integrity.

5. **Local Symptom Summary**: The class is not primarily a data holder with minimal real behavior. It is a functional implementation of a `Multimap` that ensures specific ordering and behavior.

Given the analysis above, the `LinkedHashMultimap` class does not exhibit the characteristics of a Data Class."
PropertyElf.java,"Let's analyze the file step by step based on the provided criteria:

1. **Fields:**  
   The class `PropertyElf` does not define any fields. Instead, it has a private static final `Pattern` object, which is used for matching getter method names. There are no other fields being exposed or manipulated directly.

2. **Accessors:**  
   The class does not have any getter or setter methods. It uses reflection to dynamically find and invoke methods which act as getters or setters on the target object, but it does not define any of these methods itself.

3. **Methods and Behavior:**  
   The class contains several methods that perform significant tasks (setting properties from given properties, getting property names of a class, getting a specific property, copying properties). These methods involve complex logic such as reflection, method invocation, and error handling. Therefore, it is not primarily focused on just holding or transferring data.

4. **Encapsulation:**  
   The class hides its single static field (`GETTER_PATTERN`) and does not expose any fields or data. Instead, it provides a set of utility methods to perform operations on objects and their properties. This shows good encapsulation around its operations rather than exposing fields or simple accessors.

5. **Local Symptom Summary:**  
   The file does not define a class that primarily holds data. Instead, it provides a set of utility methods used to manipulate and retrieve properties from objects dynamically using reflection. There are no signifiers of a Data Class here as the behavior is substantive and its methods perform meaningful tasks.

### Conclusion:
NO, I did not find Data Class.

The main sign that this is not a Data Class is the substantial behavior provided by the methods within the class, including reflection-based methods that manipulate and retrieve object properties, rather than just holding or exposing data."
PendingTransactionsDialog.java,"Let's analyze the Java file for indicators of the ""Data Class"" code smell step by step.

### 1. Fields:
- The class `PendingTransactionsDialog` defines several fields such as `contextTree`, `selectedContext`, `commitButton`, and `rollbackButton`.
- These fields are private and are not exposed directly.
- Therefore, this does not indicate a strong sign of a Data Class since the fields are encapsulated.

### 2. Accessors:
- The class does not contain many simple getter and setter methods. 
- There are some getter methods like `getCurrentContext()`, but there are no setter methods for the fields.
- Most public methods (`createDialogArea`, `endTransaction`, `loadContexts`, `showDialog`) are not accessors but methods that perform other functionalities.

### 3. Methods and Behavior:
- The class has methods that perform substantive work such as `endTransaction`, `loadContexts`, and methods related to UI creation and interaction which are not merely getters/setters.
- `endTransaction` handles transaction commit or rollback.
- `loadContexts` loads contexts based on certain conditions.
- `createDialogArea` sets up the UI components and handles UI-related behavior.

### 4. Encapsulation:
- The class's fields are private and not exposed directly.
- The access to these fields is controlled through methods.
- This suggests good encapsulation and not exposure of the data directly.

### 5. Local Symptom Summary:
- The class is not primarily a data holder with minimal real behavior.
- It has significant methods performing meaningful operations related to UI handling and data processing.

**Conclusion:**
NO, I did not find Data Class. The class `PendingTransactionsDialog` has multiple methods that perform substantive work, and its fields are not exposed directly. Therefore, it does not exhibit the characteristics of a Data Class."
JedisClusterTest.java,"NO, I did not find Data Class.

### Analysis:
1. **Fields**: The file defines a class `JedisClusterTest` with several fields, but these fields are primarily Jedis nodes and configurations used for testing. There are no fields that seem to be primarily data holders without behavior.

2. **Accessors**: The class does not have a pattern of many simple getter and setter methods. The methods are related to testing (e.g., setUp, tearDown, individual test methods) and not for accessing or modifying fields as simple data containers.

3. **Methods and Behavior**: There are numerous methods that perform substantive work, such as setting up and tearing down tests, interacting with Jedis nodes, and asserting test conditions. These methods are not merely getters or setters.

4. **Encapsulation**: The class encapsulates the behavior needed to run various tests, using the Jedis nodes and configurations to simulate scenarios for JedisCluster usage. It does not expose these fields publicly for general use but rather controls them through methods designed to test specific behaviors.

5. **Local Symptom Summary**: The class is primarily focused on testing behavior and interactions of JedisCluster. It does not act as a simple data container without behavior.

Based on the analysis, the class does not exhibit the characteristics of a Data Class."
RandomGenerator.java,"Let's analyze the provided Java file for signs of the ""Data Class"" code smell, following the guidelines provided.

1. **Fields:**
   - The class `RandomGenerator` has a field `baseStr` and `length` that are not explicitly declared in the snippet provided. They must be inherited from `AbstractGenerator`. There are no additional fields defined in this class.
   - The snippet does not show these fields being declared public; they are most likely private in `AbstractGenerator` given good encapsulation practices.

2. **Accessors:**
   - There are no getter or setter methods for `baseStr` and `length` in this class. The constructors are the only methods that seem to modify these fields, implying they are encapsulated properly through inheritance.

3. **Methods and Behavior:**
   - The class has two significant methods: `generate()` and `verify()`. 
   - `generate()` performs a calculation (`RandomUtil.randomString(this.baseStr, this.length)`) and `verify()` performs a check (`StrUtil.equalsIgnoreCase(code, userInputCode)`). These methods are doing substantive work.

4. **Encapsulation:**
   - The class does not expose data unnecessarily. Since no direct accessors are provided and the data fields are inherited from `AbstractGenerator`, the class hides its data behind meaningful services (`generate()` and `verify()`).

5. **Local Symptom Summary:**
   - This class does not primarily hold data with minimal real behavior. There are meaningful methods performing significant operations beyond just getting or setting fields.

Based on the analysis above:

**NO, I did not find Data Class.**

The main reason is that the `RandomGenerator` class contains meaningful methods (`generate()` and `verify()`) that perform substantial work, indicating more complex behavior than simple data handling."
RouterNanoHTTPD.java,"Let's analyze this Java file step by step for symptoms of the ""Data Class"" code smell.

1. **Fields:**  
   The file defines several classes with fields, but the class `UriResource` has multiple fields such as `uri`, `uriPattern`, `priority`, `handler`, `initParameter`, and `uriParams`. These fields are not exposed directly but have getters and setters, indicating some level of encapsulation.

2. **Accessors:**  
   There are many simple getter and setter methods in `UriResource`, such as `getUri()`, `setPriority(int)`, and `getUriParams()`. The class does not have many setter methods for its fields, but it does include getter methods for several fields.

3. **Methods and Behavior:**  
   The `UriResource` class has methods that perform behaviors beyond simple data handling, such as `process(Map<String, String>, IHTTPSession)`, `match(String)`, and `compareTo(UriResource)`. These methods are not just getters or setters.

4. **Encapsulation:**  
   The class tends to hide its data behind meaningful services, such as `process` which involves more than just data manipulation – it involves handling HTTP sessions and routing.

5. **Local Symptom Summary:**  
   While `UriResource` does have several fields and getter methods, it also contains behavior that goes beyond just holding data. It processes HTTP sessions, matches URIs, and compares resources, which are indicative of behavior that should not be present in a pure data class.

**Conclusion:**
NO, I did not find Data Class. While `UriResource` has many fields and getter methods, it also includes substantial methods like `process` and `match` that perform meaningful work and are not just simple accessors. Therefore, it does not exhibit the primary symptoms of a Data Class, which would be primarily holding data with minimal real behavior."
JavassistProxyFactory.java,"Let's analyze the given `JavassistProxyFactory` class for symptoms of the ""Data Class"" code smell:

### 1. Fields
- The class has a few fields:
  - `private static ClassPool classPool;`
  - `private static String genDirectory = """";`
- There are no public or package-private fields.

### 2. Accessors
- There are no getter or setter methods defined in the class.
- The class is not designed to expose its fields directly or through accessor methods.

### 3. Methods and Behavior
- The class contains several methods that perform substantive work, including:
  - `main` method for executing the proxy generation.
  - `generateProxyClass` method for creating proxy classes.
  - `modifyProxyFactory` method for modifying the `ProxyFactory` class.
  - Helper methods like `isThrowsSqlException`, `isDefaultMethod`, `getAllInterfaces`, `toJavaClass`.
- It does not contain many simple getter and/or setter methods.

### 4. Encapsulation
- The class tightly controls its state and operations, using private methods and encapsulating how proxies are generated and modified.

### 5. Local Symptom Summary
- There are very few fields and no getters/setters. 
- The class contains meaningful, non-trivial methods that perform hefty tasks related to generating and modifying proxy classes.

**Conclusion**:
NO, I did not find Data Class.

The class `JavassistProxyFactory` is not primarily a data holder but a utility class designed for generating and modifying proxy classes, thus showing behaviors indicative of a class with significant functionality rather than a simple data container."
ClusterConnectionManager.java,"Let's analyze the provided Java file in the context of the Data Class code smell:

1. **Fields:**
   - The file defines several fields, including `lastPartitions`, `monitorFuture`, `lastClusterNode`, `clusterNodesCommand`, `configEndpointHostName`, `natMapper`, `slot2entry`, and `client2entry`. However, these fields are utilized meaningfully throughout the class and are not just exposed without encapsulation.
   
2. **Accessors:**
   - There are very few simple getter and setter methods for these fields. For example, there is a `getLastClusterNode()` method but no corresponding setter, and no other simple field accessor methods are present.
   
3. **Methods and Behavior:**
   - The class contains numerous methods that perform substantive work, including handling cluster topology, managing connections, and interpreting Redis cluster state. These operations are critical for the functionality of the Redisson library in managing a Redis cluster.
   
4. **Encapsulation:**
   - The class encapsulates its data well. Its fields are not public, and while there are some access methods, they are not simple accessors. For example, the `getEntry` methods provide access to entries but do so in a way that requires understanding of the underlying data structure, and they are not just simple getters.
   
5. **Local Symptom Summary:**
   - The class is not primarily a data holder with minimal real behavior. It defines and utilizes several fields but primarily focuses on performing cluster management tasks, maintaining state, and handling cluster changes.

**Conclusion:**
NO, I did not find Data Class.

The provided code does not exhibit the characteristics of a Data Class as it has significant behavior and methods that perform meaningful work rather than being just a container for data with an abundance of accessors."
RequestLimiter.java,"Let's analyze the Java file for symptoms that may indicate the ""Data Class"" code smell based on the criteria provided:

1. **Fields:** 
   - The class `RequestLimiter` defines several fields: `qpsAllowed` and `data`.
   - The fields `qpsAllowed` and `data` are private, not public or package-private, which is a good sign that it tries to encapsulate its data.

2. **Accessors:**
   - The class has a few getter methods (`getQpsAllowed`, `getSum`, `getQps`, `canPass`) and a setter method (`setQpsAllowed`), but not a large number of simple getters/setters.

3. **Methods and Behavior:**
   - The class has several methods that perform substantive work, such as `increment()`, `add(int x)`, `getSum()`, `getQps()`, `canPass()`, and `tryPass()`.
   - These methods are not just simple data accessors; they include logic for modifying and querying data, which implies the class performs some meaningful behavior.

4. **Encapsulation:**
   - The class uses encapsulation by making its fields private and providing controlled access via methods.

5. **Local Symptom Summary:**
   - The class contains a mix of data fields and methods that perform non-trivial operations.
   - While it has a getter and a setter, its main functionality is more than just data storage.

Based on the analysis:

**NO, I did not find Data Class**

The class `RequestLimiter` performs significant calculations and operations (`add(int x)`, `getSum()`, `getQps()`, `canPass()`, `tryPass()`), which indicates it has real behavior and is not simply a data holder."
MockNamingService.java,"Let's analyze the provided Java file according to the criteria for detecting a ""Data Class"" code smell.

1. **Fields:**
   - The file defines a class (`MockNamingService`), but it does not explicitly declare any fields. It implements the `NamingService` interface and provides method implementations that are primarily placeholders.

2. **Accessors:**
   - There are no getter or setter methods defined in the provided code. The class does not expose any fields directly.

3. **Methods and Behavior:**
   - The class has many methods (as required by the `NamingService` interface), but they are merely method stubs that either do nothing (returning `null` or throwing unchecked exceptions) or are required to fulfill the interface contract. There are no methods that do substantive work or contain business logic.

4. **Encapsulation:**
   - Since there are no fields defined and no accessors, there is nothing being exposed or hidden by the class. However, the methods that are implemented do not add any encapsulation value— they are simply placeholders and do not enforce any encapsulation principles.

5. **Local Symptom Summary:**
   - The class primarily contains method implementations that are minimal and do not contain any real behavior. The methods are necessary to implement the `NamingService` interface but do not perform any substantive tasks.

**Answer:**
NO, I did not find Data Class.  
While the class does not contain any intrinsic data fields or meaningful behavior, it does not even resemble a Data Class because it is an implementation of an interface with empty method bodies, rather than a class that primarily exposes data. The lack of fields and meaningful methods suggests it's more of a placeholder or mock implementation than a Data Class."
MethodVisitor.java,"NO, I did not find Data Class.

Explanation:
- **Fields**: The provided file defines an interface named `MethodVisitor`, which does not have any fields. Interfaces do not contain fields by definition.
- **Accessors**: There are no getter or setter methods in this interface, as it is a pure interface with method declarations only.
- **Methods and Behavior**: The interface contains multiple method declarations that define a behavior signature rather than operations on fields.
- **Encapsulation**: Since there are no fields, the concept of encapsulation is not applicable here.
- **Local Symptom Summary**: The `MethodVisitor` interface does not exhibit characteristics of a Data Class. It is an interface defining a contract for visiting various parts of a method's bytecode instructions, which involves significant behavior rather than just holding data."
FlowControllerV1.java,"NO, I did not find Data Class.

### Analysis:

1. **Fields**: 
   - The file mainly defines a controller class, `FlowControllerV1`, which does not have fields primarily intended for data storage. The fields it has (`repository` and `sentinelApiClient`) are used for dependency injection and interaction with other parts of the application.

2. **Accessors**:
   - There are no getters or setters for fields in the class. The methods are controller endpoints and utility functions that interact with the repository and API client.

3. **Methods and Behavior**:
   - The class contains many methods that perform substantive tasks such as querying, adding, updating, and deleting flow rules. These methods include business logic checks, error handling, and interactions with other services.

4. **Encapsulation**:
   - The class is well-encapsulated, exposing its behavior via RESTful endpoints without directly exposing its internal data structures or fields. The methods perform operations and return structured results.

5. **Local Symptom Summary**:
   - The class does not appear to be a data holder with minimal real behavior. It is a REST controller providing operations to manage flow rules, indicating it has significant behavioral responsibilities rather than just holding data."
DiagnosedStreamCorruptionException.java,"Let's analyze the provided Java file for the presence of a ""Data Class"" code smell.

1. **Fields:**
   The class `DiagnosedStreamCorruptionException` defines three private fields: `diagnoseFailure`, `readBack`, and `readAhead`. These fields are not public or package-private, which reduces the direct exposure of the data.

2. **Accessors:**
   The class includes three simple getter methods: `getDiagnoseFailure()`, `getReadBack()`, and `getReadAhead()`. These methods provide access to the private fields.

3. **Methods and Behavior:**
   Apart from the getter methods, there is only one additional method, `toString()`, which overrides the superclass method to provide a detailed string representation of the exception, including the diagnostic information.

4. **Encapsulation:**
   The class encapsulates its fields, making them private and only accessible through getter methods. It does not expose its data through public fields or by having an excessive number of getter and setter methods.

5. **Local Symptom Summary:**
   While the class includes getter methods for its fields, it provides a meaningful method, `toString()`, which includes business logic to format and concatenate the exception information. Although it has a few getter methods, it is not burdened with many accessors, and it includes substantive behavior in the `toString()` method.

**Conclusion:**
NO, I did not find Data Class. The class includes both data (fields) and behavior (the `toString()` method). Although it has getter methods, it is not primarily a data holder without meaningful behavior."
XMLConfigBuilder.java,"Let's analyze the provided Java file for symptoms of the ""Data Class"" code smell step-by-step:

1. **Fields:**
   - The class `XMLConfigBuilder` defines several fields (`parsed`, `parser`, `environment`, `localReflectorFactory`) which are not public but are used throughout the class.
   - There are no public or package-private fields that suggest easy access to internal data.

2. **Accessors:**
   - There are no simple public getter and setter methods for its fields. 
   - The fields are mostly internal and accessed via methods that perform substantial work.

3. **Methods and Behavior:**
   - The class has several private methods like `parseConfiguration`, `settingsAsProperties`, `loadCustomVfs`, etc., which perform detailed parsing and setting operations.
   - There is also one public method `parse()` which orchestrates the parsing and configuration of the XML input.
   - The methods are not merely accessing or modifying fields; they are handling parsing configurations, setting various components, loading resources, and other complex behaviors.

4. **Encapsulation:**
   - The class encapsulates its data by keeping its fields private and providing a single public method `parse()` to interact with its functionalities.
   - No data is exposed through simple accessors that do not perform any business logic.

5. **Local Symptom Summary:**
   - Based on the analysis, the class does not exhibit characteristics of a Data Class because it has significant behavior in the form of parsing XML and setting up configuration, not just holding and exposing data.

**Conclusion:**
NO, I did not find Data Class. The class `XMLConfigBuilder` contains substantial behavior methods that process XML configurations and set up the MyBatis configuration, rather than just serving as a container for data with simple accessors."
Lexeme.java,"Let's analyze the file step by step according to the provided guidelines:

1. **Fields:**
   - The class `Lexeme` defines several fields: `offset`, `begin`, `length`, `lexemeText`, and `lexemeType`.
   - These fields are primarily package-private (private) with corresponding getter and setter methods.

2. **Accessors:**
   - There are several getter and setter methods for each field (`offset`, `begin`, `length`, `lexemeText`, `lexemeType`).
   - The class also includes a method `getBeginPosition()` which is derived but is not a simple accessor.
   - `getEndPosition()` and `getLength()` are simple getter variations.
   - `getLexemeTypeString()` returns a string representation of the lexeme type and is not just a simple accessor.
   - The constructors and other methods are not simple accessors.

3. **Methods and Behavior:**
   - Besides accessors, there are methods implementing `Comparable`, `equals`, and `hashCode`.
   - The `toString()` method provides a string representation of the object.
   - The `append` method is not an accessor and shows some substantive behavior (merging two lexemes).
   - The class also has several static fields (constants for lexeme types) and methods to convert types to readable strings.

4. **Encapsulation:**
   - The fields are private, but there are many getter and setter methods, indicating a heavy reliance on accessors.
   - The class does provide some encapsulation through the use of private fields, but almost all data can be accessed or modified through the public interface.
   - It hides some complexity in methods like `hashCode()` and `equals()`, but the core data remains easily accessible.

5. **Local Symptom Summary:**
   - The class has several fields with corresponding getters and setters.
   - There are more methods that are accessors than methods with substantive behavior.
   - While there is some meaningful behavior in methods like `append()`, `equals()`, and `hashCode()`, the primary purpose appears to be data storage and access.

Based on the analysis:

**YES, I found Data Class** - almost all methods are either getters/setters or methods that provide simple operations over the fields (like `equals()`, `hashCode()`)."
DBeaverCore.java,"Let's analyze the file step by step based on the criteria provided:

1. **Fields**:
   - The class `DBeaverCore` defines several fields such as `tempFolder`, `workspace`, `queryManager`, `qmLogWriter`, and `certificateStorage`.
   - These fields are private, which is a good practice for encapsulation, but there are no public or package-private fields displayed.

2. **Accessors**:
   - The class has several accessor methods such as `getWorkspace()`, `getDefaultResourceHandler()`, `getApplication()`, `getQueryManager()`, `getPreferenceStore()`, `getCertificateStorage()`, `getSecureStorage()`, and `getExternalFileManager()`.
   - Most of these accessor methods are simple getters without any additional logic.

3. **Methods and Behavior**:
   - The class contains methods that perform substantive work such as `initialize()`, `dispose()`, and `getTempFolder()`.
   - In particular, `initialize()` initializes various parts of the core, and `dispose()` handles cleanup and shutdown tasks.
   - `getTempFolder(DBRProgressMonitor monitor, String name)` handles the creation of temporary directories.

4. **Encapsulation**:
   - The class is encapsulated well as all fields are private, and access to them is provided through methods.
   - The class does not expose direct access to its fields, but rather hides them behind accessor methods.

5. **Local Symptom Summary**:
   - Although the class has several getter methods, it also has significant non-trivial methods that perform meaningful tasks.
   - The class is involved in the initialization and disposal of the application, which are substantial tasks rather than just holding data.

**Conclusion**:
NO, I did not find Data Class. While the class has multiple getter methods, it also includes several methods that perform substantial and meaningful operations, making it more than just a simple data holder."
AztecCode.java,"### Analysis of the Java File for Data Class Code Smell

1. **Fields:**
   - The file defines a class, `AztecCode`, with several private fields: `compact`, `size`, `layers`, `codeWords`, and `matrix`.
   - Fields are not exposed directly (public), which is good for encapsulation.

2. **Accessors:**
   - There are getter and setter methods for each field (`compact`, `size`, `layers`, `codeWords`, `matrix`).
   - Most public methods in this class are simple get and set methods for its fields.

3. **Methods and Behavior:**
   - The class mostly contains getter and setter methods.
   - There are no methods performing substantial work, calculations, or business logic.

4. **Encapsulation:**
   - The class encapsulates its fields through private access modifiers and provides public access via getter and setter methods.
   - The data is not exposed directly, adhering to encapsulation principles, but the methods provided are basic accessors.

5. **Local Symptom Summary:**
   - The class primarily acts as a data holder with minimal behavior.
   - The main sign is that almost all methods are getters and setters.

### Conclusion:
**YES, I found Data Class**  
The clearest evidence is that almost all public methods are getters and setters."
EntryConfig.java,"### Analysis of the File `EntryConfig.java`

#### 1. Fields:
- The class defines several fields: `resourceName`, `entryType`, `resourceType`, `acquireCount`, `args`, and `contextConfig`.
- All fields are private and final, indicating a level of encapsulation, but this does not preclude it from being a Data Class.

#### 2. Accessors:
- The class has simple getter methods for each field (`getResourceName`, `getEntryType`, `getAcquireCount`, `getArgs`, `getContextConfig`, `getResourceType`).
- There are no setter methods because the fields are final, which reinforces the Data Class pattern by preventing mutation after creation.

#### 3. Methods and Behavior:
- The class has multiple constructors that initialize the fields, which is typical for a Data Class.
- Apart from the constructors and getters, there is only one other method: `toString()`, which is a generally included method for any class to provide a string representation of its state.

#### 4. Encapsulation:
- Due to the fields being private and final, the class seems to encapsulate its data well.
- However, it does expose all its data indirectly through many getter methods, which is characteristic of a Data Class.

#### 5. Local Symptom Summary:
- The class appears to be a Data Class because it primarily consists of fields and their corresponding getter methods, with very little actual behavior.
- The main sign is the presence of numerous getter methods and the lack of substantive behavior methods.

### Conclusion:
**YES, I found Data Class.** The clearest evidence is the presence of multiple getter methods and the absence of substantive behavior methods, with the class essentially functioning as a carrier of data."
ScriptProcessorBuilder.java,"NO, I did not find Data Class.

The provided Java file defines a class `ScriptProcessorBuilder` that includes several fields (attributes) for configuration purposes but does not primarily exhibit the characteristics of a Data Class. While it does have setter-like methods (`language`, `scriptFromFile`, `scriptFromClassPathFile`, `script`, `thread`) for setting its fields, these methods are not mere simple setters; they include additional behavior such as reading from files and converting input streams to strings. Furthermore, the class includes a `build` method that instantiates a new `ScriptProcessor` object with the configured data, indicating some level of behavior beyond just holding and exposing data. Therefore, the class does not look like a primary data holder with minimal real behavior."
MapTypeAdapterFactory.java,"Let's go through the provided Java file and analyze it based on the criteria you've outlined for detecting a ""Data Class"" code smell.

1. **Fields:**
   - The class `MapTypeAdapterFactory` defines fields such as `constructorConstructor` and `complexMapKeySerialization`.
   - Additionally, the nested class `Adapter` defines fields like `keyTypeAdapter`, `valueTypeAdapter`, and `constructor`.
   - These fields are not public; they are package-private or private, which is a good sign.

2. **Accessors:**
   - There are getter and setter methods for some fields, but these are limited.
   - The constructor in `Adapter` class serves the role of initializing the fields, rather than having individual setter methods for each field.
   - There are no simple getter/setter methods; the class primarily uses constructors and member methods for operations.

3. **Methods and Behavior:**
   - The class provides methods like `create`, `getKeyAdapter`, and the methods `read` and `write` within the `Adapter` class.
   - These methods are not simple accessors; they deal with complex operations such as JSON serialization and deserialization.
   - The `Adapter` class handles the creation, reading, and writing of JSON data based on conditions and input types, indicating significant behavior.

4. **Encapsulation:**
   - The class encapsulates its fields well by not exposing them outside the class.
   - The only public methods are `create` from the `MapTypeAdapterFactory` class and `read/write` from the `Adapter` class, which are not simple getters/setters but expose meaningful services.

5. **Local Symptom Summary:**
   - Overall, this class is not primarily a data holder with minimal real behavior. It contains substantial logic for JSON serialization and deserialization.
   - While it has member variables, they are well-encapsulated, and the class has significant behavior through its methods.

**Conclusion:**
NO, I did not find Data Class.

The `MapTypeAdapterFactory` and its nested `Adapter` class are designed to perform specific serialization and deserialization tasks rather than simply holding and providing access to data. Therefore, they do not exhibit the typical symptoms of a Data Class."
AttributeNameHistoWalker.java,"Let's analyze the provided Java file for symptoms of the ""Data Class"" code smell:

1. **Fields:**  
   - The class `AttributeNameHistoWalker` has two private fields: `isCompileAttribute` and `attributeName`.

2. **Accessors:**  
   - The class does not have any getter or setter methods. The fields are accessed and set directly within the constructor.

3. **Methods and Behavior:**  
   - The class has one method, `visit(IMetaMember mm)`, which does substantive work (making decisions based on the attributes, calling methods, and manipulating the histogram). This method is not just a simple getter or setter.

4. **Encapsulation:**  
   - The fields are private and exposed only through the constructor and the `visit` method. This demonstrates a level of encapsulation rather than direct exposure.

5. **Local Symptom Summary:**  
   - The class defines a couple of fields and has behavioral methods that do more than just get and set fields. Primarily, the class performs operations with the purpose of populating a histogram based on certain attributes of the `IMetaMember` object passed to the `visit` method.

**Conclusion:**
NO, I did not find Data Class. The main sign is that the class contains a meaningful method (`visit`) that performs substantive work, not dominated by getters/setters."
PageModelExtractor.java,"Let's analyze the Java file for the symptoms of the ""Data Class"" code smell step-by-step based on the provided criteria:

1. **Fields:**  
   The file defines a class (`PageModelExtractor`) with several fields including `targetUrlPatterns`, `targetUrlRegionSelector`, `helpUrlPatterns`, `helpUrlRegionSelector`, `clazz`, `fieldExtractors`, `objectExtractor`, and `logger`. These fields are not public; they are private, with some being package-private by default. There are no direct field accessors, but getter methods are provided for some fields.

2. **Accessors:**  
   While the class provides several getter methods (e.g., `getClazz`, `getTargetUrlPatterns`, `getHelpUrlPatterns`, `getTargetUrlRegionSelector`, `getHelpUrlRegionSelector`), these are not overwhelmingly present, and most methods are not simple accessors. The class also contains logic that processes page data.

3. **Methods and Behavior:**  
   The class has methods that perform substantive work, primarily related to processing web pages and extracting data (`init`, `getAnnotationExtractByUrl`, `getAnnotationExtractCombo`, `getAnnotationExtractBy`, `getSetterMethod`, `initClassExtractors`, `process`, `processSingle`, `convert`, `setField`). These methods involve complex logic such as extracting data using selectors, formatting data, and handling exceptions.

4. **Encapsulation:**  
   The class hides most of its fields behind private access and does not expose data directly. The provided accessors do not lead to a significant exposure of internal data. The class provides meaningful methods that handle the complexities of web extraction rather than simply exposing its fields.

5. **Local Symptom Summary:**  
   The class does not look like a primary data holder with minimal real behavior. It contains several methods that perform significant tasks related to web extraction, which goes beyond basic data storage.

Based on this analysis:

**NO, I did not find Data Class.**

The clear evidence here is that the class contains numerous methods that perform complex logic related to processing and extracting data from web pages, rather than being a simple structure that only holds data with trivial accessors."
TreeTypeAdapter.java,"### Analysis of the Java File

Let's go through each question step-by-step to determine if the `TreeTypeAdapter` class fits the ""Data Class"" code smell criteria.

#### 1. Fields:
- **Observation:** The `TreeTypeAdapter` class defines several fields:
  ```java
  private final JsonSerializer<T> serializer;
  private final JsonDeserializer<T> deserializer;
  final Gson gson;
  private final TypeToken<T> typeToken;
  private final TypeAdapterFactory skipPast;
  private final GsonContextImpl context;
  private TypeAdapter<T> delegate;
  ```
- **Analysis:** The class does define multiple fields, but they are not all public; some are package-private or private. The class also has some internal classes (`SingleTypeFactory`, `GsonContextImpl`) with their own fields.

#### 2. Accessors:
- **Observation:** The class does not have many simple getter and setter methods. Instead, it has methods that provide more logic:
  - `read`, `write`: These methods handle the serialization/deserialization of JSON.
  - `delegate`: This is a private method used internally, not a public accessor.
  - The static factory methods (`newFactory`, `newFactoryWithMatchRawType`, `newTypeHierarchyFactory`) are not simple accessors.
- **Analysis:** Most public methods do not act as simple accessors; they perform meaningful operations such as reading and writing JSON.

#### 3. Methods and Behavior:
- **Observation:** The class has methods that perform substantive work:
  - `read`: Deserializes JSON data.
  - `write`: Serializes data into JSON.
- **Analysis:** There are multiple methods involved in serialization and deserialization beyond just field access. The class has significant behavior, not just data storage.

#### 4. Encapsulation:
- **Observation:** The class uses private/protected access modifiers for its fields and methods. It does expose fields using the methods `read` and `write`, but these methods don’t simply access fields.
- **Analysis:** The data fields are not exposed directly. They are hidden behind the `read` and `write` methods, which provide meaningful services.

#### 5. Local Symptom Summary:
- **Observation:** Based on the analysis, this class does not fit the ""Data Class"" criteria because it contains substantial methods providing meaningful behavior and uses encapsulation to hide its fields behind methods that handle specific tasks.
- **Analysis:** Most public methods do not act as simple accessors and do real work. It is clear that this class is not merely a data holder but also a functional component for JSON serialization and deserialization.

### Conclusion
```markdown
NO, I did not find Data Class
```
The `TreeTypeAdapter` class has significant behavior through its `read` and `write` methods and properly encapsulates its fields instead of exposing them through simple getters/setters."
Spider.java,"Let's analyze the provided Java file step by step for symptoms of the ""Data Class"" code smell.

### 1. Fields:
The class `Spider` defines a significant number of fields (attributes) that are related to different aspects of web crawling:
- `downloader`
- `pipelines`
- `pageProcessor`
- `startRequests`
- `site`
- `uuid`
- `scheduler`
- `logger`
- `threadPool`
- `executorService`
- `threadNum`
- `stat`
- `exitWhenComplete`
- `spawnUrl`
- `destroyWhenExit`
- `newUrlLock`
- `newUrlCondition`
- `spiderListeners`
- `pageCount`
- `startTime`
- `emptySleepTime`

### 2. Accessors:
The class contains setter and getter methods for a significant number of fields. Examples include:
- `public Spider setScheduler(Scheduler scheduler)`
- `public Scheduler getScheduler()`
- `public void setUUID(String uuid)`
- `public String getUUID()`
- `public Spider thread(int threadNum)`
- `public int getThreadAlive()`
- `public void setExitWhenComplete(boolean exitWhenComplete)`
- `public boolean isExitWhenComplete()`

### 3. Methods and Behavior:
While the class does have many getter and setter methods, there are also several substantial methods that implement core functionality related to web crawling, such as:
- `public void run()`
- `protected void processRequest(Request request)`
- `public void close()`
- `protected void sleep(int time)`
- `private boolean waitNewUrl()`
- `private void signalNewUrl()`
- `protected void initComponent()`
- `public <T> List<T> getAll(Collection<String> urls)`

These methods are not just simple getters/setters; they implement logic for downloading pages, processing requests, and managing the lifecycle of the spider.

### 4. Encapsulation:
The fields are generally not public, and many are protected, which means they are not fully exposed outside the class. However, there are many methods that act as setters and getters, indicating that the data is somewhat exposed.

### 5. Local Symptom Summary:
While the class has many fields and accessor methods, it also houses significant logic for crawling and managing web requests, which undermines the primary hallmark of a Data Class—the absence of meaningful behavior. The class provides substantial assistance in managing the crawling process, including handling of threading, scheduling, and data processing.

### Conclusion:
Based on this analysis, the `Spider` class does have a significant number of fields and many simple getter/setter methods, but it also contains a substantive amount of behavior that performs meaningful work. Therefore, it does **not** qualify as a classic Data Class.

**Answer:**  
NO, I did not find Data Class. The class contains substantial methods that implement core functionality related to web crawling and managing data, not just being a simple data holder."
RandomService.java,"### Analysis of the Java file for Data Class smell

**1. Fields:**
- The file defines a class with a few fields: `SHARED_RANDOM` and `random`.
- The `SHARED_RANDOM` field is `private static final`, indicating it’s a shared constant.
- The `random` field is `private final`, indicating it's an instance-bound object used by methods.

**2. Accessors:**
- There are no getter or setter methods. The class does not simply expose its fields or have a high proportion of methods dedicated to accessing fields.

**3. Methods and Behavior:**
- The class contains many methods that perform substantive work, such as:
  - `nextInt(int n)` and `nextInt(int min, int max)` for generating random integers.
  - `nextLong()` and `nextLong(long n)` for generating random longs.
  - `nextDouble()` for generating random doubles.
  - `nextBoolean()` for generating random booleans.
  - `hex()` and `hex(int length)` for generating random hexadecimal strings.
- These methods perform useful operations and generate random numbers, which indicates behavior beyond simple data holding.

**4. Encapsulation:**
- The class properly encapsulates the data. The `random` field is private, and its values are manipulated through public methods. There is no direct exposure of the internal data other than via methods that provide meaningful behavior.

**5. Local Symptom Summary:**
- The class does not exhibit signs of being a Data Class because it contains meaningful methods that perform random number generation and other related tasks, not just simple field accessors.

### Conclusion:
**NO, I did not find Data Class.**

The class `RandomService` has several methods that perform substantive work related to generating random numbers and strings. It does not primarily serve as a data holder, as it contains no simple getters/setters and possesses clear behavior."
RuleContainer.java,"NO, I did not find Data Class.

### Detailed Analysis:
1. **Fields**: The `RuleContainer` class has several fields (`orderValues`, `testRules`, and `methodRules`). These fields are not public; they are private, which is a good practice for encapsulation.

2. **Accessors**: The class does define simple methods to manipulate its fields, such as `setOrder`, `add`, but does not primarily consist of getter/setter pairs.

3. **Methods and Behavior**: The class contains several methods that perform substantive work, such as sorting rules based on their order (`getSortedEntries`) and applying rules in a specific order (`apply`). These methods encapsulate meaningful behavior beyond just data handling.

4. **Encapsulation**: The data (fields) of this class is well encapsulated behind meaningful methods. It exposes its data through specific methods rather than making fields directly accessible.

5. **Local Symptom Summary**: This class has a mix of fields and behavior. It’s not primarily a data holder with minimal behavior; instead, it manages the order and application of test and method rules, which is typical of a utility or manager class rather than a data class.

Given these observations, the `RuleContainer` class does not exhibit the symptoms of a Data Class."
LocalCacheListener.java,"Let's analyze the provided Java file step by step for signs of the ""Data Class"" code smell:

1. **Fields:**
   - The class `LocalCacheListener` defines several fields: `disabledKeys`, `name`, `commandExecutor`, `cache`, `object`, `instanceId`, `codec`, `options`, `cacheUpdateLogTime`, `lastInvalidate`, `invalidationTopic`, `syncListenerId`, and `reconnectionListenerId`.
   - These fields are not exposed as public, they use private access modifiers and are mostly managed through getters/setters or used in methods.

2. **Accessors:**
   - The class includes methods like `getInstanceId`, `getInvalidationTopic`, `getInvalidationTopicName`, and `getUpdatesLogName`, which are simple getters.
   - There are no setter methods provided for most fields. Only setters or mutators are implicitly present in the `createCache` method and implemented methods like `add` and `updateCache`.

3. **Methods and Behavior:**
   - The class has several methods with substantive work such as `createCache`, `add`, `clearLocalCacheAsync`, `disableKeys`, `remove`, `loadAfterReconnection`, and `getClearSemaphore`.
   - Methods like `generateId` and the implementations related to handling invalidation and updates (`isDisabled`, `updateCache`, etc.) suggest more than just simple data manipulation.
   - The class is also abstract and contains an abstract method `updateCache`, indicating that subclasses are expected to provide some behavior.

4. **Encapsulation:**
   - The class encapsulates its fields well. It uses private fields and provides controlled access through methods.
   - There is no direct public exposure of fields, and the data is managed through method interactions.

5. **Local Symptom Summary:**
   - While the class does have multiple fields and includes some getters, it does more than just hold and expose data. It has several methods that perform meaningful actions and is designed to be extended by subclasses through its abstract method.

**Conclusion:**

NO, I did not find Data Class. The class has a significant number of methods that perform meaningful tasks and is structured in a way that suggests it is more than just a container for data. It is designed to handle logic related to caching and invalidation, and its behavior extends beyond simple getters and setters."
TransactionMQProducer.java,"Let's analyze the provided Java file based on the criteria for the ""Data Class"" code smell:

1. **Fields:**
   The class defines several fields such as `transactionCheckListener`, `checkThreadPoolMinSize`, `checkThreadPoolMaxSize`, `checkRequestHoldMax`, `executorService`, and `transactionListener`. These fields hold data relevant to the state of the `TransactionMQProducer` object.

2. **Accessors:**
   The class includes many methods that are simple getters and setters for its fields. Most public methods are indeed accessors. Examples include:
   - `getTransactionCheckListener()` and `setTransactionCheckListener()`
   - `getCheckThreadPoolMinSize()` and `setCheckThreadPoolMinSize()`
   - `getCheckThreadPoolMaxSize()` and `setCheckThreadPoolMaxSize()`
   - `getCheckRequestHoldMax()` and `setCheckRequestHoldMax()`
   - `getExecutorService()` and `setExecutorService()`
   - `getTransactionListener()` and `setTransactionListener()`

3. **Methods and Behavior:**
   The class has a few methods that do more than just get or set fields, such as `start()`, `shutdown()`, and `sendMessageInTransaction()`. However, these methods primarily manage the lifecycle and configuration of the producer rather than performing extensive calculations or business logic.

4. **Encapsulation:**
   The class hides its internal state behind public getter and setter methods. While the fields themselves are private, their values are accessible and modifiable through various accessor methods, maintaining encapsulation but also indicating a significant reliance on these methods for functionality.

5. **Local Symptom Summary:**
   The class primarily consists of fields and numerous accessor methods with minimal real behavior. The `start()`, `shutdown()`, and `sendMessageInTransaction()` methods manage the state and transaction processing but do not indicate complex data manipulations or business logic.

**Conclusion:**
YES, I found Data Class.
**Evidence:** ""almost all methods are getters/setters""

The class has a lot of fields and corresponding getter and setter methods, and the primary remaining methods (`start()`, `shutdown()`, and `sendMessageInTransaction()`) manage the configuration and lifecycle without performing extensive behavior."
PlainPermissionManager.java,"Let's go through the file step by step to identify symptoms of a ""Data Class"" code smell:

1. **Fields:**
   - The class defines several fields related to access control settings, including maps, lists, and strings. However, these fields are private, which is a good encapsulation practice.

2. **Accessors:**
   - There are some getter and setter methods, such as `getAclConfigDataVersion()` and `isWatchStart()`, but these are not numerous. Many of the methods manipulate these fields instead of just accessing them.

3. **Methods and Behavior:**
   - The class contains many methods that perform significant functionality, such as loading configuration, updating access configurations, deleting access configurations, and validating access resources. These methods are not limited to just getting or setting fields.

4. **Encapsulation:**
   - The class encapsulates its data behind methods and does not expose its fields directly. It follows good encapsulation practices by maintaining private fields and providing methods to interact with these fields and perform operations.

5. **Local Symptom Summary:**
   - Despite having several fields and some accessors, the class contains substantial methods that perform meaningful business logic and data manipulation. Therefore, it does not primarily serve as a data holder with minimal real behavior.

Based on the analysis:

**NO, I did not find Data Class.**

The class contains a lot of substantive methods and does not primarily act as a simple data holder."
JSONTokener.java,"Let's analyze this file step by step according to the guidelines provided:

1. **Fields:**
   - The class `JSONTokener` defines several fields for managing the parsing state of a JSON structure, including `character`, `eof`, `index`, `line`, `previous`, `usePrevious`, `reader`, and `config`.
   - These fields are not public or package-private; they are private. There are no fields that are directly exposed.

2. **Accessors:**
   - The class provides methods such as `back()`, `end()`, `more()`, `next()`, `next(char c)`, `next(int n)`, `nextClean()`, `nextString(char quote)`, `nextTo(char delimiter)`, `nextTo(String delimiters)`, `nextValue()`, and `skipTo(char to)`.
   - These methods do not primarily consist of simple getters and setters. They perform operations on the parsing state and manipulate the internal fields.

3. **Methods and Behavior:**
   - There are methods that perform substantive work, such as `nextString(char quote)` that processes a JSON string, `nextValue()` that parses the next JSON structure, and `toJSONArray()` that converts the JSON source into a `JSONArray`.
   - The methods do more than just get or set fields; they include parsing logic and error handling.

4. **Encapsulation:**
   - The fields are encapsulated and are not directly exposed. The class provides operations (`next()`, `nextString()`, etc.) to manipulate these fields in a controlled manner.
   - The class hides the implementation details of JSON parsing behind meaningful operations.

5. **Local Symptom Summary:**
   - The class does not appear to be a primary data holder with minimal real behavior since it includes several substantive methods for parsing JSON.
   - The class is focused on processing JSON input, maintaining parsing state, and performing parsing tasks.

**Conclusion:**
NO, I did not find Data Class. The class includes several methods that perform substantive parsing tasks, not just getting or setting fields. The internals are encapsulated, and there is significant behavior rather than minimal logic."
AndroidMusic.java,"### Analysis of the Java file for ""Data Class"" Code Smell

1. **Fields:**
   - The class defines several fields, including `audio`, `player`, `isPrepared`, `wasPlaying`, `volume`, and `onCompletionListener`. None of the fields are public, but several are package-private (`protected`), and they include both primitives and objects.

2. **Accessors:**
   - The class includes getter and setter methods for several fields (`volume` has a getter and setter), but these aren't the only methods in the class. There are other methods related to controlling the music playback.

3. **Methods and Behavior:**
   - The methods in this class are not just getters/setters. They include methods like `play`, `pause`, `stop`, `setPosition`, `getPosition`, `getDuration`, and lifecycle methods (`dispose` and `onCompletion`). These methods perform significant operations related to music playback and state management.

4. **Encapsulation:**
   - The class does not expose its data directly since the fields aren't public. Moreover, it includes methods that provide functionalities beyond simple access to the fields, such as playing, pausing, and stopping the music.

5. **Local Symptom Summary:**
   - The class has several fields and provides methods to manipulate the state of a music player. It's not just holding data but also provides behaviors that are substantial and relevant to its functionality, which includes controlling and managing the music player.

### Conclusion
NO, I did not find Data Class. The class not only holds data but also includes several methods that perform significant operations, thus adding meaningful behavior, which is contrary to the characteristics of a Data Class."
WriteWorkbookHolder.java,"### Analysis:

1. **Fields:**
   - The class `WriteWorkbookHolder` defines numerous fields (attributes) that hold various types of data, such as `Workbook`, `File`, `OutputStream`, `InputStream`, and maps. These fields are intended to represent different attributes of a workbook and related configurations.

2. **Accessors:**
   - The class includes many getter and setter methods for each of its fields. For example, methods like `getWorkbook()`, `setWorkbook(Workbook workbook)`, `getWriteWorkbook()`, `setWriteWorkbook(WriteWorkbook writeWorkbook)`, etc., are present. Most of the class’s public methods are indeed accessors.

3. **Methods and Behavior:**
   - There are very few methods that perform substantive work beyond basic initialization and handling of input/output streams. The only meaningful method is `copyTemplate()`, which is responsible for copying a template file to a temporary stream. This method, however, is primarily procedural and does not encapsulate significant business logic.

4. **Encapsulation:**
   - The class's fields are not exposed directly (they are private), but they are extensively accessible and modifiable through a large number of getter and setter methods. This approach means that the class predominantly exposes its data rather than providing higher-level behavior or business logic.

5. **Local Symptom Summary:**
   - The class primarily serves as a holder for workbook-related data and configuration settings. It contains numerous fields and a significant number of getter/setter methods, with very little real behavior that goes beyond simple data manipulation and initialization.

### Conclusion:
YES, I found Data Class. The clearest evidence is ""almost all methods are getters/setters."""
DefaultDateTypeAdapter.java,"After analyzing the provided Java file, let's evaluate the symptoms of a ""Data Class"" step by step:

1. **Fields:**  
   The class `DefaultDateTypeAdapter` does define fields, primarily `dateType` and `dateFormats`. These fields are not public or package-private but are private and accessed via methods. There is no direct exposure of fields.

2. **Accessors:**  
   While there is no explicit getter and setter for `dateType` and `dateFormats`, the field `dateType` is set in the constructors and not modified elsewhere, indicating a form of encapsulation. However, there are no additional simple accessors for these fields in the given code snippet.

3. **Methods and Behavior:**  
   The class has methods like `write`, `read`, and `deserializeToDate` that perform significant behavior, such as serialization and deserialization of dates. These methods are not simple getters or setters but handle complex tasks.

4. **Encapsulation:**  
   The class encapsulates its data behind meaningful services (`write`, `read`, `deserializeToDate`) that perform serialization and deserialization. The internal `dateFormats` list, while initialized in constructors, is not exposed directly.

5. **Local Symptom Summary:**  
   The class does not appear to be primarily a data holder with minimal real behavior. Instead, it has multiple constructors and methods that handle complex serialization and deserialization tasks. This behavior contradicts the symptoms of a Data Class.

Based on this analysis:

**NO, I did not find Data Class.**  
The class performs meaningful operations rather than just exposing data through getters and setters."
AckSchedulerKey.java,"Let's analyze the provided `AckSchedulerKey` class step by step based on the criteria for the ""Data Class"" code smell:

1. **Fields:**
   - The class defines a private final field `index`.
   - The fields are not exposed directly and are private, which is good.

2. **Accessors:**
   - There is one simple getter method `getIndex()` for the `index` field.
   - There are no setter methods as the field is `final`.
   - The other methods (`hashCode` and `equals`) are overridden, but they are not simple getters or setters.

3. **Methods and Behavior:**
   - The class has two methods that perform substantive work: `hashCode()` and `equals()`.
   - These methods are crucial for making the object suitable for use in hashed collections, which indicates some kind of behavior beyond just data storage.

4. **Encapsulation:**
   - The field `index` is encapsulated and accessed through a simple getter method.
   - The class inherits from `SchedulerKey`, suggests that it might be part of a larger framework where specific behaviors are defined.

5. **Local Symptom Summary:**
   - While the class does have fields and a getter, it also includes meaningful methods (`hashCode` and `equals`) that provide more than just data storage.

Based on the analysis:

**NO, I did not find Data Class**  
The class has fields and a getter but includes substantive methods that contribute to meaningful behavior beyond simple data holding."
TableView.java,"Let's analyze the given Java file based on the criteria for detecting the ""Data Class"" code smell.

1. **Fields**:
   - The class `TableView` defines several fields: `columnDefineArray`, `hasBorder`, `borders`, and `padding`.
   - `columnDefineArray` is the only field exposed through a constructor parameter and associated methods. 
   - `hasBorder` and `borders` are accessed via getter/setter methods.
   - `padding` is also accessed via getter/setter methods.

2. **Accessors**:
   - The class provides getter/setter methods for `borders`, `hasBorder`, and `padding`.
   - There are methods like `borders()`, `borders(int border)`, `hasBorder(boolean hasBorder)`, `hasBorder()`, and `padding(int padding)`.

3. **Methods and Behavior**:
   - Besides accessors, the class has methods that perform actions like `draw()`, `drawRow(int[] widthCacheArray, int rowIndex)`, `getData(int rowIndex, ColumnDefine columnDefine)`, `getDataFormat(ColumnDefine columnDefine, int width)`, `getTableHigh()`, `drawSeparationLine(int[] widthCacheArray)`, and `addRow(Object... columnDataArray)`.
   - These methods perform substantive work related to rendering and managing the table structure and data.

4. **Encapsulation**:
   - The class hides most of its implementation details behind methods rather than exposing its fields directly.
   - Only `columnDefineArray` is handled through constructors and methods, while other data fields are encapsulated and accessed through getter/setters or other methods.

5. **Local Symptom Summary**:
   - While `TableView` does have a few getter/setter methods for certain fields, it also contains methods that do significant work outside of just setting and getting field values. 
   - These methods are related to creating and formatting the table output, handling data, and drawing the table, which indicates more than just being a data holder.

**Conclusion**:
NO, I did not find Data Class.
The class `TableView` contains several methods that perform meaningful tasks, not just simple data accessors. This suggests that it is not primarily a data holder with minimal real behavior."
HttpClientDownloader.java,"Let's analyze the provided Java file based on the criteria specified to determine if it exhibits symptoms of the ""Data Class"" code smell.

1. **Fields:**
   - The file defines a class with several fields, such as `logger`, `httpClients`, `httpClientGenerator`, `httpUriRequestConverter`, `proxyProvider`, and `responseHeader`.
   - Most of these fields are package-private (default visibility) or private.

2. **Accessors:**
   - There are getter and setter methods for some fields, specifically for `httpUriRequestConverter` and `proxyProvider`. However, there are no public fields, and the rest are private with no additional getters or setters provided.

3. **Methods and Behavior:**
   - The class contains methods that perform significant work, such as `download()` and `handleResponse()`. These methods are involved in downloading web pages and handling HTTP responses, which are not simple data manipulations.
   - There are very few simple getters/setters, and most of the public methods are performing substantive tasks.

4. **Encapsulation:**
   - The class encapsulates its data well. Most fields are private, and access is provided through methods where appropriate. The fields are not publicly exposed.
   - The class hides its data behind meaningful services (`download` and `handleResponse`) rather than simply exposing its state.

5. **Local Symptom Summary:**
   - The class does not look like it is primarily a data holder with minimal real behavior. It has significant methods that perform meaningful work, and it maintains encapsulation by not exposing its fields directly.

### Conclusion:
NO, I did not find Data Class.
The class contains fields that are appropriately encapsulated and has multiple methods that perform meaningful tasks, which are not simple get/set operations."
CN_QuantifierSegmenter.java,"Let's analyze the provided Java file for symptoms of the ""Data Class"" code smell:

1. **Fields:**
   The class `CN_QuantifierSegmenter` defines several fields like `nStart`, `nEnd`, and `countHits`. These fields are notably not public, they are private, which is a good encapsulation practice. Thus, this does not strongly suggest a Data Class based on field exposure.

2. **Accessors:**
   The file does not have many getter or setter methods. The fields `nStart`, `nEnd`, and `countHits` are private and are accessed or modified directly within methods rather than through accessors.

3. **Methods and Behavior:**
   The class contains several methods that perform specific tasks such as `analyze`, `reset`, `processCNumber`, `processCount`, `needCountScan`, and `outputNumLexeme`. These methods contain logical operations and are not simple getters or setters. Hence, the presence of methods with substantive behavior suggests that this class is not primarily a data holder.

4. **Encapsulation:**
   The class maintains good encapsulation by keeping fields private and providing public methods (`analyze` and `reset`) to manipulate the data and state. This is opposite to what we would expect in a Data Class that exposes its data through many getters and setters.

5. **Local Symptom Summary:**
   Based on the above points, the class is actively involved in business logic with methods that perform complex operations and does not primarily serve as a data holder. The absence of many simple getters and setters and the presence of methods indicating significant behavior mean that this class does not exhibit the symptoms of a Data Class.

**Conclusion:**
NO, I did not find Data Class.

The class `CN_QuantifierSegmenter` contains methods that do substantive work and maintains encapsulation by keeping fields private and controlled through specific methods rather than general accessor methods."
CompareObjectsSettings.java,"### Step-by-Step Analysis:

1. **Fields**:
   - The class defines several fields (`nodes`, `skipSystemObjects`, `compareLazyProperties`, `compareOnlyStructure`, `compareScripts`, `showOnlyDifferences`, `outputType`, `outputFolder`).
   - All fields are private except for the `OutputType` enum.

2. **Accessors**:
   - The class has many getter/setter methods for each field, including `getNodes()`, `isSkipSystemObjects()`, `setSkipSystemObjects(boolean)`, etc.
   - Most public methods are indeed these accessors.

3. **Methods and Behavior**:
   - There are a couple of methods (`loadFrom`, `saveTo`) that handle loading and saving of settings, going beyond simple get/set operations.
   - However, these methods don't perform complex business logic or significant calculations.

4. **Encapsulation**:
   - The class hides the data fields using private access modifiers.
   - It exposes the data via getter/setter methods, indicating that internal data encapsulation is maintained, but the class itself acts mainly as a data holder.

5. **Local Symptom Summary**:
   - The class contains almost all methods as getters/setters, except for `loadFrom` and `saveTo` which perform simple operations to manage the state.
   - This pattern aligns with the characteristics of a Data Class.

### Conclusion

**YES, I found Data Class**

**Clearest Evidence**:
The class has almost all methods as getters/setters, and contains only simple methods to load and save settings."
InlineSizeHistoVisitable.java,"1. **Fields:**
   - The class `InlineSizeHistoVisitable` defines fields such as `logger` and `inlinedCounted`. The field `inlinedCounted` is used to keep track of inlined methods that have already been counted.

2. **Accessors:**
   - There are no getter or setter methods for the fields. The only public methods in the class are `reset`, `visit`, and `visitTag`, none of which are simple accessors.

3. **Methods and Behavior:**
   - The class has methods that do substantive work. For example, the `visit` method processes `IMetaMember` objects to iterate through compilations and visit parse tags. The `processParseTag` method processes individual tags, handling different tag types like `TAG_METHOD`, `TAG_INLINE_SUCCESS`, and `TAG_PHASE`. These methods perform significant logic rather than just getting or setting fields.

4. **Encapsulation:**
   - The class encapsulates its data and provides meaningful behavior through its methods. The field `inlinedCounted` is private and is only manipulated through class methods, maintaining encapsulation. Additionally, it doesn't expose its fields directly or through many simple accessors.

5. **Local Symptom Summary:**
   - The class does not appear to be a data holder with minimal real behavior. It includes substantial behavior within its methods and maintains encapsulation by keeping fields private.

**Answer:**
NO, I did not find Data Class

The main evidence against it being a Data Class is the presence of substantial methods (`visit`, `processParseTag`, and `visitTag`) that perform significant logic and the proper encapsulation of data fields."
CodahaleHealthChecker.java,"NO, I did not find Data Class.

### Analysis:

**1. Fields:**
- The file defines fields within the nested classes `ConnectivityHealthCheck` and `Connection99Percent`, but not directly in the `CodahaleHealthChecker` class.
- These fields are private, indicating encapsulation rather than being public or package-private.

**2. Accessors:**
- There are no getter or setter methods provided in the class.

**3. Methods and Behavior:**
- The primary method `registerHealthChecks` does significant work by parsing health check properties, registering checks with `HealthCheckRegistry`, and handling different configurations.
- Each nested class (`ConnectivityHealthCheck` and `Connection99Percent`) includes a `check()` method that performs meaningful operations such as checking database connection health and evaluating wait times.

**4. Encapsulation:**
- The class does not expose its internal state widely; it utilizes private fields and nested private classes to encapsulate its behavior and data.

**5. Local Symptom Summary:**
- The class introduces health-check capabilities for a connection pool and includes methods that perform substantial computations and business logic.
- There are no symptoms of it being a Data Class since it contains meaningful behavior and no simple getters/setters or minimal fields."
ClassicPluginStrategy.java,"Let's analyze the provided `ClassicPluginStrategy` Java class for the symptoms of a Data Class:

1. **Fields:**
   - The class has several fields such as `pluginManager`, `coreClassLoader`, among others.
   - These fields are not exposed directly (public or package-private), but there is a getter method for `pluginManager`.

2. **Accessors:**
   - There are several getter and setter methods, but they are not overwhelming. Notably, there is a getter for `pluginManager`.
   - Most of the methods are not simple accessors; they perform various operations related to plugin strategies.

3. **Methods and Behavior:**
   - The class has many methods that do substantive work, such as `createPluginWrapper`, `getShortName`, `initializeComponents`, `findComponents`, `load`, etc.
   - These methods involve significant functionality related to plugin management, class loading, dependency resolution, and more.

4. **Encapsulation:**
   - The class encapsulates much of its data behind meaningful services. The fields are not exposed directly or through simple getters, and the methods provide a higher level of operations over these fields.

5. **Local Symptom Summary:**
   - The class looks like it is a functional class rather than a data holder. It contains ample behavior and logic beyond simple data handling.

**Conclusion:**

NO, I did not find Data Class. The class contains significant behavior and numerous methods that perform substantial operations, indicating it is a functional component rather than a simple data holder."
ClientHead.java,"Let's analyze the `ClientHead` class according to the criteria for identifying a Data Class:

1. **Fields:**
   - The class defines several fields (attributes), primarily representing the state of a client session, including `namespaceClients`, `channels`, `handshakeData`, `sessionId`, `store`, `disconnectableHub`, `ackManager`, `clientsBox`, `disconnectScheduler`, `configuration`, `currentTransport`, and `lastBinaryPacket`.

2. **Accessors:**
   - There are multiple simple getter methods such as `getOrigin()`, `getHandshakeData()`, `getAckManager()`, `getSessionId()`, `getRemoteAddress()`, `getStore()`, `isConnected()`, `getNamespaces()`, `isChannelOpen()`, `getCurrentTransport()`, and `getLastBinaryPacket()`.
   - While there are setter methods like `setLastBinaryPacket`, there is a mix of simple accessor methods and methods that perform some behavior (e.g., `bindChannel`, `releasePollingChannel`, `disconnect`, `schedulePingTimeout`).

3. **Methods and Behavior:**
   - The class includes several methods that perform meaningful work, such as managing the client's transport channels, handling handshakes, sending packets, disconnecting clients, scheduling timeouts, and more.
   - Therefore, not all methods are just for accessing fields; there are methods that perform actual logic and operations.

4. **Encapsulation:**
   - The class encapsulates the client's state to some extent, with most fields being private and accessible through methods that perform specific operations.
   - However, it also contains public fields and a public constant (`CLIENT`), which could be a sign of some level of exposure, but it's not excessive.

5. **Local Symptom Summary:**
   - While the class does have several fields and accessors, it also contains numerous methods that perform substantive operations rather than just being getters and setters.

**Conclusion:**

```plaintext
NO, I did not find Data Class
```

**Explanation:**
The `ClientHead` class contains a variety of methods that perform actual operations and business logic. Although it does contain fields and accessors, these are not the defining characteristics, and the class shows evidence of more than just holding data."
Closer.java,"NO, I did not find Data Class.

**Explanation:**

1. **Fields:** The class `Closer` has a few fields (`suppressor`, `stack`, `thrown`), but not a large number of them. These fields are not exposed publicly and are mostly hidden behind methods that provide meaningful behavior.

2. **Accessors:** There are very few methods typical of simple getters and setters. The fields are not exposed through direct accessors, but are handled and manipulated internally within the methods for meaningful operations.

3. **Methods and Behavior:** The class contains methods that perform substantial work, such as managing the closing of resources (`register`, `rethrow`, `close`). These methods handle exceptions, manage a stack of resources, and provide a utility to manage the closing process, indicating meaningful behavior.

4. **Encapsulation:** The fields are not exposed. The `stack` and `thrown` fields are private and manipulated within the methods that provide complex behavior related to the class's purpose.

5. **Local Symptom Summary:** The class is not primarily a data holder with minimal real behavior. It provides functionality to manage `Closeable` resources, suppress exceptions, and propagate them as necessary, which is significant and not just data handling.

In conclusion, `Closer` does not exhibit the patterns typical of a Data Class, as it provides meaningful behavior rather than just being a container of data."
Tokeniser.java,"NO, I did not find Data Class.

**Explanation:**
Looking at the provided `Tokeniser` class, several characteristics can be noted:

1. **Fields:** The class does define several fields, but they largely represent internal state or pending data, not just simple data attributes.
2. **Accessors:** While there are getter and setter-like methods (like `getState` and `transition`), they do not primarily consist of simple getters and setters.
3. **Methods and Behavior:** The class has a significant number of methods that perform substantive work, such as parsing input, consuming character references, managing tokens, and generating errors, indicating that it is not just a data holder.
4. **Encapsulation:** The class does encapsulate its data effectively, providing methods to access and modify the internal state rather than exposing fields directly.
5. **Local Symptom Summary:** Based on the substantial behavior and use of internal state and methods, the class appears to be part of a larger parsing mechanism, not a simple data class.

The primary functionality of the class involves parsing and tokenizing HTML input, which involves more than just holding and accessing data."
HazelcastPubSubStore.java,"### Analysis

1. **Fields:**
   - The class defines several fields: `hazelcastPub`, `hazelcastSub`, `nodeId`, and `map`. These fields are private, indicating some level of encapsulation.

2. **Accessors:**
   - There are no public fields.
   - There are no getter or setter methods for the fields in this class. The constructor initializes the fields, and that’s the only access provided directly.

3. **Methods and Behavior:**
   - The class contains methods that perform meaningful operations such as `publish`, `subscribe`, `unsubscribe`, and `shutdown`. These methods do more than just get or set fields; they handle subscription, message publishing, and cleanup.

4. **Encapsulation:**
   - The class encapsulates its fields behind the constructor and methods that perform operations rather than exposing fields directly.

5. **Local Symptom Summary:**
   - The class includes several methods that perform substantive work, such as handling message subscriptions and publishing. Therefore, it does not appear to be a simple data holder with minimal real behavior.

### Conclusion
NO, I did not find Data Class. The clearest evidence is that the class contains several methods that perform meaningful operations related to message handling and subscription management, rather than being limited to getters/setters or simply holding data."
ContentType.java,"### Analysis Step-by-Step

1. **Fields:**
   - The class `ContentType` has several private final fields: `contentTypeHeader`, `contentType`, `encoding`, and `boundary`. These fields are not exposed directly but are likely accessed via getter methods.

2. **Accessors:**
   - The class contains multiple getter methods: `getContentTypeHeader()`, `getContentType()`, `getEncoding()`, `getBoundary()`, and `isMultipart()`. It does not have any setter methods because the fields are final and initialized in the constructor.

3. **Methods and Behavior:**
   - The class has a few methods that perform meaningful work: 
     - `getDetailFromContentHeader()` is used to extract details from the header string using regular expressions.
     - `isMultipart()` checks if the content type is multipart/form-data.
     - `tryUTF8()` tries to add a UTF-8 charset to the content type header if the current encoding is null.
   - Most methods are simple data retrieval or checks, which suggests a focus on data management.

4. **Encapsulation:**
   - The private fields indicate encapsulation, and most of the data exposure happens through methods. However, the absence of setter methods and the presence of mostly getters indicate limited modification capabilities.
   - The data is hidden behind these methods, although the class primarily serves to store and retrieve information.

5. **Local Symptom Summary:**
   - The class primarily seems to be a holder of data with a few utility methods that manipulate or describe its data.
   - The main signs are the presence of several fields, numerous getter methods, and a limited number of methods that perform meaningful logic or behavior.

### Conclusion

**YES, I found Data Class**

**Evidence:** Almost all methods are getters, and there are very few methods that perform substantial work."
ResultLoaderMap.java,"### Analysis of `ResultLoaderMap.java` for Data Class Code Smell

#### 1. Fields:
The file defines a class named `ResultLoaderMap` with a primary field `private final Map<String, LoadPair> loaderMap`, which holds data. Inside the nested static class `LoadPair`, there are several fields such as `serialVersionUID`, `FACTORY_METHOD`, `serializationCheck`, `metaResultObject`, `resultLoader`, `log`, `configurationFactory`, `property`, `mappedStatement`, and `mappedParameter`. The fields in `LoadPair` are mostly package-private or private, with negligible exposure without getters/setters.

#### 2. Accessors:
- The `ResultLoaderMap` class has several methods that provide access to its internal state, but they are not just simple getters or setters. For instance, `getProperties()`, `getPropertyNames()`, `size()`, `hasLoader()`, `load()`, `remove()`, and `loadAll()`, which manipulate or retrieve state in ways beyond just accessing field values.
- Inside the nested `LoadPair` class, there's a getter for `log` (`getLogger()`), which is a simple accessor, but other fields are typically accessed through more complex load and initialization processes within the methods, not direct simple accessors or mutators.

#### 3. Methods and Behavior:
- The `ResultLoaderMap` class has methods that manage the state and provide substantive behavior related to its primary role: managing lazy-loaded properties.
- Inside the `LoadPair` class, methods like `load()`, `getConfiguration()`, and initialization logic demonstrate more than just simple access to fields, involving business logic, error handling, and configuration retrieval.
- There are no simple setter methods in either class, and getter methods are used to manipulate internal state rather than just return field values.

#### 4. Encapsulation:
- The `ResultLoaderMap` and `LoadPair` classes encapsulate their internal state with methods that perform operations related to lazy loading and property management, rather than exposing the fields directly or with simple accessors/mutators.
- Most fields in `LoadPair` are package-private or private, and even the `loaderMap` in `ResultLoaderMap` is encapsulated with methods that provide necessary functionality.

#### 5. Local Symptom Summary:
Based on the patterns above, the classes do not look like they are primarily data holders with minimal real behavior. They encapsulate complex behavior such as managing lazy-loaded properties through methods that go beyond mere getters and setters.

**Conclusion:**
NO, I did not find Data Class.

The `ResultLoaderMap` and `LoadPair` classes encapsulate significant behavior and do not merely act as containers for data with simple accessors."
HikariConfig.java,"1. **Fields:**  
   The file defines a class `HikariConfig` with numerous fields, such as `dataSourceClassName`, `jdbcUrl`, `dataSourceJndiName`, `driverClassName`, `connectionTimeout`, `validationTimeout`, `maxLifetime`, among others. These fields are primarily used to hold configuration properties.

2. **Accessors:**  
   The class has a large number of getter and setter methods corresponding to the fields. Each field has a getter method and often a setter method with some validation logic (e.g., ensuring a timeout is not below a certain threshold).

3. **Methods and Behavior:**  
   While there are several methods that get or set fields, there are also methods that perform more significant operations, such as `validate()`, `validateNumerics()`, and `logConfiguration()`. These methods are involved in configuration validation and logging.

4. **Encapsulation:**  
   The class mostly uses private fields with corresponding public setter and getter methods, hiding the data behind these accessors. However, it also has methods that perform validation and logging, which adds some level of behavior, though most of the public methods are accessors.

5. **Local Symptom Summary:**  
   The class seems to predominantly act as a configuration holder with a fair amount of fields and corresponding getter/setter methods for each field. However, it also incorporates some level of behavior with validation and logging methods.

**Conclusion:**
The class has strong symptoms of a Data Class due to the large number of fields and corresponding simple getter/setter methods, but it also includes more substantive methods for validation and logging.

**Answer:**  
YES, I found Data Class. The main sign is that almost all methods are getters/setters for numerous fields used to store configuration properties."
Configuration.java,"Let's analyze the provided Java file step by step based on the criteria for detecting the ""Data Class"" code smell.

1. **Fields:**
   - The class `Configuration` defines several private fields: `environment`, `settings`, `useSmart`, `enableRemoteDict`, and `enableLowercase`. This indicates that it is holding data.

2. **Accessors:**
   - The class has several simple getter methods (`isUseSmart`, `getEnvironment`, `getSettings`, `isEnableRemoteDict`, `isEnableLowercase`) and one setter method (`setUseSmart`). This suggests that most of its public methods are for accessing and modifying its fields.

3. **Methods and Behavior:**
   - Besides the constructor and one method (`getConfigInPluginDir`) that deals with configuration file paths, all other methods are just getters/setters. There are no methods performing substantial work or business logic, which is a hallmark of a Data Class.

4. **Encapsulation:**
   - The class encapsulates its fields by making them private and providing public accessors. This is generally a good practice, however, the prominence of the accessors in relation to other methods hints towards minimal real behavior.

5. **Local Symptom Summary:**
   - The class primarily holds data and contains many methods for getting and setting the class's data. It has only one method, `getConfigInPluginDir`, that performs any sort of real behavior.

**Conclusion:**
YES, I found Data Class. The clearest evidence is that almost all methods are getters/setters."
VCardResultParser.java,"Let's analyze the provided Java file step by step to determine if it shows symptoms of the ""Data Class"" code smell.

### 1. Fields
**Analysis:** The file defines fields like `BEGIN_VCARD`, `VCARD_LIKE_DATE`, and several others. However, these fields are not meant to store data related to instances of the class but are used for pattern matching. The class does not have instance fields that store data.

**Conclusion:** No evidence of the class primarily holding data through fields.

### 2. Accessors
**Analysis:** There are no getter or setter methods within the class. The methods defined are not simple accessors but more complex parsing methods.

**Conclusion:** No evidence of methods dominated by accessors.

### 3. Methods and Behavior
**Analysis:** The class has methods like `parse`, `matchVCardPrefixedField`, `decodeQuotedPrintable`, `matchSingleVCardPrefixedField`, `toPrimaryValue`, `toPrimaryValues`, `toTypes`, `isLikeVCardDate`, `formatNames`, and `maybeAppendComponent`. These methods perform various parsing operations and transformations, which represent substantive work.

**Conclusion:** Evidence of substantive behavior through several complex methods.

### 4. Encapsulation
**Analysis:** The pattern matching fields are private static final, indicating proper encapsulation. The class does not expose its core data but rather processes and hides its internal logic behind meaningful methods.

**Conclusion:** The class tends to hide data and core logic behind meaningful services.

### 5. Local Symptom Summary
**Conclusion:** Based on the analysis, the class does not look primarily like a data holder with minimal real behavior. It contains many methods that do substantive parsing and data transformation work.

### Final Answer
NO, I did not find Data Class.  
**Evidence:** The class contains several methods that perform complex parsing and transformation tasks, indicative of more than just data holding."
InterceptorProcessor.java,"Let's analyze the provided Java file for symptoms of the ""Data Class"" code smell:

1. **Fields:**
   - The class `InterceptorProcessor` defines several fields:
     - `locationMatcher`
     - `interceptorMethodConfig`
     - `exceptionHandlerConfig`
     - `classLoader`
   - These fields are not public; they have package-private visibility.

2. **Accessors:**
   - The class provides getter and setter methods for each of its fields:
     - `getLocationMatcher`, `setLocationMatcher`
     - `getInterceptorMethodConfig`, `setInterceptorMethodConfig`
     - `getExceptionHandlerConfig`, `setExceptionHandlerConfig`
   - These methods are simple and consistent with typical data class accessors.

3. **Methods and Behavior:**
   - The class contains a substantial method `process` that performs complex operations involving bytecode manipulation, parameter handling, and exception management.
   - There is another method `errorHandler` that also performs specific logic related to exception handling.
   - These methods are not simple accessors, instead, they implement real logic central to the class's purpose.

4. **Encapsulation:**
   - While the class provides getter/setter methods for its fields, it also hides its behavior behind meaningful methods like `process` and `errorHandler`.
   - The fields themselves are not public, indicating a level of encapsulation.

5. **Local Symptom Summary:**
   - The class contains both fields with corresponding getters/setters and meaningful methods with business logic.
   - Its behavior goes beyond just holding and exposing data, as it includes significant logic for interacting with bytecode, managing bindings, and handling exceptions.

**Conclusion:**
- **NO, I did not find Data Class**
- The provided class includes significant behavior in the form of methods that perform complex tasks. While it does contain fields and getter/setter methods, the presence of non-trivial methods for processing bytecode and handling errors indicates that it is not primarily a data holder."
HandleCallbackParam.java,"### Analysis of the Java Code

1. **Fields:**
   - The class defines several fields: `logId`, `logDateTim`, `handleCode`, and `handleMsg`.
   - All fields are private, which is a positive sign for encapsulation.

2. **Accessors:**
   - There are getter and setter methods for each field, and these are the most numerous public methods.
   - The presence of both getter and setter methods for each field is typical of a Data Class.

3. **Methods and Behavior:**
   - Besides the constructors and the `toString()` method, there are no other methods that perform substantive work.
   - The bulk of the public methods are getters and setters, indicating very few methods that handle business logic.

4. **Encapsulation:**
   - The fields are private, and all public fields are exposed through getter and setter methods, maintaining encapsulation.
   - However, the class does not have any complex behavior methods that hide the data behind meaningful services.

5. **Local Symptom Summary:**
   - The class is primarily composed of fields and their corresponding getters and setters.
   - There are no other methods that perform substantive computations or encapsulate business logic.

### Conclusion

Based on the analysis, the class `HandleCallbackParam` strongly exhibits the symptoms of a Data Class. The class is mainly a container for data with almost all public methods being getters/setters.

**Final Answer:**
YES, I found Data Class. The main sign is ""almost all methods are getters/setters""."
SimpleWebServer.java,"Let's analyze the provided Java code file `SimpleWebServer.java` for signs of the ""Data Class"" code smell.

1. **Fields**:
   The class contains several fields, such as `rootDirs`, `quiet`, and `cors`. These fields store the state of the web server, which is a typical characteristic of a data class.

2. **Accessors**:
   The class doesn't expose direct public fields but does have a constructor that initializes these fields. However, there are no simple getter or setter methods for `quiet` and `cors`. The only public fields are the static, final `INDEX_FILE_NAMES` and `LICENCE`. There are no getter or setter methods for `rootDirs`, implying that these fields are either accessed directly or not changed after being initialized.

3. **Methods and Behavior**:
   A significant portion of the class's methods (like `serve`, `serveFile`, `listDirectory`, among others) perform meaningful work, particularly around handling HTTP requests, serving files, and responding to clients. These methods involve business logic related to web server functionality.

4. **Encapsulation**:
   The class encapsulates its data reasonably well. The fields `quiet` and `cors` are private, and there are no direct public setters for them. Instead, they are set through the constructor. The `rootDirs` is protected, which suggests it might be intended for use within the package or subclasses.

5. **Local Symptom Summary**:
   While the class does have several fields that store the state of the web server, it also contains a large number of methods that perform meaningful computations and business logic. The class provides significant functionality beyond just holding data.

**Answer**:
NO, I did not find Data Class. The class contains several fields but the majority of its methods perform meaningful computations and business logic, which indicates that it is not primarily a data holder with minimal real behavior."
AbstractWriteHolder.java,"Let's analyze the provided Java code step by step based on the criteria for identifying a Data Class:

1. **Fields:**
   - The class `AbstractWriteHolder` contains a significant number of fields, such as `needHead`, `relativeHeadRowIndex`, `excelWriteHeadProperty`, `writeHandlerMap`, `ownWriteHandlerMap`, `useDefaultStyle`, `automaticMergeHead`, `excludeColumnIndexes`, `excludeColumnFiledNames`, `includeColumnIndexes`, and `includeColumnFiledNames`. These fields cover various configurations and properties for Excel writing.

2. **Accessors:**
   - There are numerous getter and setter methods for the fields defined in the class. For example, `getNeedHead()`, `setNeedHead(Boolean needHead)`, `getRelativeHeadRowIndex()`, `setRelativeHeadRowIndex(Integer relativeHeadRowIndex)`, `getExcelWriteHeadProperty()`, `setExcelWriteHeadProperty(ExcelWriteHeadProperty excelWriteHeadProperty)`, etc.

3. **Methods and Behavior:**
   - While there are methods that perform specific tasks such as `compatibleOldCode()`, `compatibleOldCodeCreateRowCellStyleStrategy()`, `initAnnotationConfig()`, and others, these are relatively few in comparison to the sheer number of accessor methods. The majority of public methods are indeed accessors or adhere to the functionality of converting or reconfiguring other objects rather than performing significant business logic.

4. **Encapsulation:**
   - The class does encapsulate its data within private fields and provides access to these fields via getter and setter methods. However, the substantial volume of getters and setters indicates a high level of exposure to its internal state.

5. **Local Symptom Summary:**
   - Based on the above analysis, the class appears to be primarily a data holder with minimal real behavior. The evidence for this is the overwhelming number of fields and accessor methods compared to methods that perform substantial operations.

**Final Answer:**
YES, I found Data Class.  
**Evidence:** almost all methods are getters/setters, indicating the class is primarily a data holder with minimal real behavior."
TestProxies.java,"NO, I did not find Data Class.

### Analysis:

1. **Fields**:  
   - The `TestProxies` class does not define any fields of its own. It uses fields from `HikariConfig`, `HikariDataSource`, `Connection`, `StubConnection`, `PreparedStatement`, and `StubStatement`, but these are not defined within `TestProxies`.

2. **Accessors**:  
   - The class does not have any getter or setter methods. It only contains methods that are test annotations (`@Test`) with methods performing various assertions and tests on database connections.

3. **Methods and Behavior**:  
   - The class is primarily composed of test methods that contain a significant amount of behavior, including setup and verification of various database operations and their resulting states and exceptions.

4. **Encapsulation**:  
   - The class does not expose any fields directly. It encapsulates the data handling through its test methods, which are designed to verify behavior rather than modify state.

5. **Local Symptom Summary**:  
   - The class is clearly a test class designed to test various behaviors of database connections and statements. It does not act as a simple data holder or contain mostly accessors; instead, it focuses on testing and verifying the correctness of operations in a database connection pool context.

This class exhibit the characteristics of a test class rather than a data class, making it clear that it does not have the symptoms of the Data Class code smell."
JITDataModel.java,"Let's analyze this Java file step-by-step following the outlined criteria to determine if it exhibits symptoms of a ""Data Class"":

1. **Fields:**
   - The class `JITDataModel` contains several fields such as `packageManager`, `stats`, `jitEvents`, `codeCacheTagList`, `compilerThreads`, `endOfLog`, `jdkMajorVersion`, and `baseTimestamp`.
   - Fields are declared as private, demonstrating encapsulation.

2. **Accessors:**
   - The class has getter and setter methods for several fields. Specifically, for:
     - `jdkMajorVersion`: `setJDKMajorVersion(int version)` and `getJDKMajorVersion()`.
     - `baseTimestamp`: `getBaseTimestamp()` and `setBaseTimestamp(long baseTimestamp)`.
     - `packageManager`: `getPackageManager()`.
     - `stats`: `getJITStats()`.
     - `endOfLog`: `getEndOfLogTag()` and `setEndOfLog(Tag tag)`.
   - These basic accessor methods are common, but not the majority of the methods.

3. **Methods and Behavior:**
   - There are methods that perform more significant operations like `reset()`, `getCompilerThreads()`, `createCompilerThread(String threadId, String threadName)`, `getCompilerThread(String threadId)`, `addEvent(JITEvent event)`, `getEventListCopy()`, `addNativeBytes(long count)`, `updateStats(IMetaMember member, Map<String, String> attrs)`, `findMetaMember(MemberSignatureParts msp)`, `buildAndGetMetaClass(Class<?> clazz)`, `addCodeCacheEvent(CodeCacheEvent event)`, and `getCodeCacheEvents()`.
   - These methods are not merely getters/setters and involve actions like resetting state, managing collections, updating statistics, and more.

4. **Encapsulation:**
   - The fields are private, and access is provided through public methods.
   - The class provides meaningful methods that encapsulate the behavior and operations relevant to its data, suggesting a proper object-oriented design rather than simple data exposure.

5. **Local Symptom Summary:**
   - While there are getter/setter methods, they are not the overwhelming majority.
   - The class includes several methods with substantial behavior, reflecting real functionality and responsibility beyond just holding data.
   - The class uses methods for operations and maintains internal consistency, which is contrary to what a typical Data Class would look like.

**Conclusion:**
NO, I did not find Data Class. While there are some accessor methods, the class performs significant operations and maintains encapsulation and behavior that disqualify it from being purely a data holder."
BytecodeInstruction.java,"Let's analyze the provided Java file against the criteria for detecting the ""Data Class"" code smell.

1. **Fields:**
   - The class `BytecodeInstruction` defines several fields: `offset`, `opcode`, `parameters`, `hasComment`, and `comment`. These fields are primarily storing data and are not exposed publicly. Instead, they are accessed through getter and setter methods, showing good encapsulation so far.

2. **Accessors:**
   - The class has many simple getter and setter methods for its fields (`getOffset`, `setOffset`, `getOpcode`, `setOpcode`, `getParameters`, `addParameter`, `hasParameters`, `getComment`, `setComment`, and `hasComment`). These methods are quite common in classes that mainly store data.

3. **Methods and Behavior:**
   - The class includes methods that do substantive work:
     - `getCommentWithMemberPrefixStripped()`: Processes and manipulates the `comment` field.
     - `getLabelLines()`: Calculates the number of lines required for a label based on the opcode and parameters.
     - `toStringComplete()`, `toString(int maxOffset, int line)`, `toStringNonSwitch(int maxOffset)`, and `toStringSwitch(int maxOffset, int line)`: These methods perform string conversion operations, formatting the data in specific ways for display.
     - `hashCode()` and `equals(Object obj)`: These methods provide behavior related to the comparison and identification of objects, which are essential for meaningful behavior.
   
4. **Encapsulation:**
   - The class is generally well-encapsulated, with fields being private and accessed through methods. However, it does expose some data through many simple accessors, which can be a sign that it might be more of a data-holding structure.

5. **Local Symptom Summary:**
   - While the class has many accessor methods and fields, it also contains several methods that perform significant operations on the data, such as formatting, calculating label lines, and hash code generation and equals checking. These methods suggest that the class has more than just data-holding responsibilities.

**Conclusion:**
NO, I did not find Data Class. The primary reason is that the `BytecodeInstruction` class includes several methods that perform substantive work, such as formatting and calculations, rather than only being a simple data holder with accessors."
BatchResult.java,"### Analysis of the Java File for ""Data Class"" Smell

Let's go through each of the questions step by step:

1. **Fields:**
   - The class `BatchResult` defines several fields: `mappedStatement`, `sql`, `parameterObjects`, and `updateCounts`.
   - These fields are private, which is good for encapsulation, but it does suggest that this class is primarily used to hold data.

2. **Accessors:**
   - The class has many getter methods: `getMappedStatement()`, `getSql()`, `getParameterObject()`, `getParameterObjects()`, `getUpdateCounts()`.
   - There is also a setter method: `setUpdateCounts(int[] updateCounts)`.
   - The pattern here is that most public methods are accessors, which can be a sign of a data class.

3. **Methods and Behavior:**
   - There are only a few methods in this class, and most of them are just simple accessors.
   - The method `addParameterObject(Object parameterObject)` is the only one that might be considered to do some substantive work, but it's just adding an object to the list. This is still more on the side of data manipulation than business logic.

4. **Encapsulation:**
   - The class uses private fields and provides public accessor methods, which adheres to encapsulation principles.
   - However, the majority of the public methods are simple getters/setters, which can indicate poor encapsulation of behavior.

5. **Local Symptom Summary:**
   - The class `BatchResult` looks like it is primarily a container for data with minimal real behavior. The main sign is that almost all methods are getters/setters.

### Conclusion
Based on the analysis above:

- **YES, I found Data Class**  
- **Evidence:** ""Almost all methods are getters/setters"""
AbstractSendMessageProcessor.java,"Let's analyze the provided Java file for symptoms that may indicate the ""Data Class"" code smell:

1. **Fields:**
   - The class `AbstractSendMessageProcessor` does have fields, but these are not primarily data fields that are openly exposed or accessed through many simple getters/setters. Fields like `brokerController`, `storeHost`, and `sendMessageHookList` do not suggest a simple data holder pattern.

2. **Accessors:**
   - The class does contain a getter method for `storeHost`, but this is just one instance and does not indicate a pattern of having many simple accessors. There are no setter methods in this class, and most of the public methods are not accessors.

3. **Methods and Behavior:**
   - The class contains multiple methods that perform substantive tasks such as `buildMsgContext`, `buildInnerMsg`, `msgCheck`, `msgContentCheck`, and others. These methods involve complex logic and are not just simple getters/setters.

4. **Encapsulation:**
   - The class encapsulates its data well through methods that perform business logic. It does not simply expose its fields directly or through numerous simple accessors.

5. **Local Symptom Summary:**
   - Based on the analysis, the class does not appear to be a Data Class. Most methods are performing meaningful work and encapsulating behavior rather than merely holding and exposing data.

**Conclusion:**
NO, I did not find Data Class. The evidence is that the class contains substantive methods that perform complex logic rather than just being a holder for data with simple accessors."
StpLogic.java,"### Analysis of the `StpLogic` Class

1. **Fields:**
   - The class contains various fields that store state, such as `loginType`.
   - The field `loginType` is public.

2. **Accessors:**
   - The class contains many methods that act as getters and setters for its fields. For example, `getLoginType()`, `setLoginType(String loginType)`.
   - These are typical accessors without any complex logic.

3. **Methods and Behavior:**
   - While the class has getter and setter methods, it also includes many methods that perform significant work, such as session management, token creation, deletion, and user authentication.
   - It includes methods like `login`, `logout`, `checkRole`, `checkPermission`, which manage the session and security logic tightly integrated with the data.

4. **Encapsulation:**
   - Although `loginType` is public, it is also available through a getter and setter.
   - The class encapsulates many operations and interactions through methods, not just through direct field access.

5. **Local Symptom Summary:**
   - The class has a mix of fields and extensive behavior. While there are many accessors, these are intertwined with significant logic methods that perform various security operations. Therefore, it does not appear to be a simple data holder.

### Conclusion

**NO, I did not find Data Class.**

The `StpLogic` class contains significant business logic and handles complex operations related to session management and security, which precludes it from being classified as a Data Class."
QueueTest.java,"NO, I did not find Data Class.

Explanation:
The provided Java file is actually a test class (`QueueTest`) for the `Queue` class. It contains multiple test methods to verify the behavior and functionality of the `Queue` class, such as testing adding and removing elements, resizing, and iterating over the queue. These methods do not define or exhibit the characteristics of a Data Class. Instead, they are focused on testing various aspects of the queue's behavior, confirming that the class functions as intended. There are no fields, getters, or setters defined in this test class; it only interacts with the `Queue` class through its methods."
DetectionResultRowIndicatorColumn.java,"Let's analyze the file based on the provided criteria for identifying the ""Data Class"" code smell.

1. **Fields:**  
   The class `DetectionResultRowIndicatorColumn` defines a private field `isLeft`. However, it also inherits from `DetectionResultColumn` which may have additional fields. The field `isLeft` is not public or package-private, only accessible through a getter. There is no evidence of additional fields in the snippet provided.

2. **Accessors:**  
   The class has a getter for the `isLeft` field (`boolean isLeft()`). There is one setter method (`void setRowNumbers()`) that sets internal state rather than just setting a field. This method processes segments of the `Codeword` array.

3. **Methods and Behavior:**  
   The class includes several methods that perform substantive work such as `adjustCompleteIndicatorColumnRowNumbers`, `getRowHeights`, `adjustIncompleteIndicatorColumnRowNumbers`, `getBarcodeMetadata`, and `removeIncorrectCodewords`. These methods involve iterating over and processing arrays of `Codeword` objects, which is indicative of behavior rather than just holding data.

4. **Encapsulation:**  
   The class encapsulates its data behind meaningful methods. The `isLeft` field is not directly exposed, and the processing logic is contained within methods that handle business logic related to PDF417 barcode decoding.

5. **Local Symptom Summary:**  
   Based on the analysis, the class `DetectionResultRowIndicatorColumn` has more than simple getters and setters. It contains several methods that perform meaningful work on its fields and associated objects. Therefore, there is no indication that this class is primarily a data holder with minimal real behavior.

**Conclusion:**
NO, I did not find Data Class. The evidence against it is that the class contains several methods performing substantive work, not just encapsulating data."
RedissonSessionRepository.java,"### Analysis of the Java File for Data Class Symptoms

**1. Fields:**  
- The class `RedissonSessionRepository.RedissonSession` defines several fields such as `principalName`, `delegate`, and `map`. These fields primarily store data related to a session.

**2. Accessors:**  
- The inner class `RedissonSession` has getter and setter methods for its fields, including `getId()`, `getAttribute()`, `setAttribute()`, `setLastAccessedTime()`, `getLastAccessedTime()`, `setMaxInactiveInterval()`, `getMaxInactiveInterval()`, `isExpired()`, and `changeSessionId()`. All these methods are essentially interacting with the fields directly.

**3. Methods and Behavior:**  
- Most of the methods in `RedissonSession` are focused on managing the session attributes, which are essentially getters, setters, and session management utilities like expiration handling (`updateExpiration()`). There are very few methods that perform complex behavior beyond that.

**4. Encapsulation:**  
- The class exposes its internal state primarily through getters and setters, without hiding the session-related operations behind meaningful methods. While some operations like `updateExpiration()` and `resolvePrincipal()` provide some encapsulation, they are relatively simple and do not hide the data behind richer abstractions.

**5. Local Symptom Summary:**  
- The `RedissonSession` class appears to be primarily a data holder with minimal real behavior, as evidenced by the abundance of getter and setter methods and the focus on interacting directly with its fields.

### Conclusion

**YES, I found Data Class**

**Brief evidence:** Almost all methods are getters/setters, with minimal complex behavior."
RelationshipTest.java,"NO, I did not find Data Class.

This file appears to be a test class for `Relationships` class in the `com.github.javafaker` package. Here’s the analysis based on the criteria you provided:

1. **Fields**: The `RelationshipTest` class doesn't define any fields itself. It uses a `Faker` instance, but this is used for mocking and testing purposes, not for data storage.
   
2. **Accessors**: There are no getter or setter methods in this file. The methods are test cases, which do not involve simple methods that get or set fields.

3. **Methods and Behavior**: The methods are test cases with assertions and mocking, indicating behavior rather than data manipulation or storage.

4. **Encapsulation**: There’s no sign of data exposure here; the class is focused on testing behavior rather than exposing fields or providing data access.

5. **Local Symptom Summary**: The class is clearly focused on testing rather than data storage or simple data manipulation, hence it doesn’t exhibit the characteristics of a Data Class."
BaseSwaggerConfig.java,"NO, I did not find Data Class

**Explanation:**

1. **Fields:** The class `BaseSwaggerConfig` does not define any fields. Instead, it operates using local variables within its methods.

2. **Accessors:** There are no getter or setter methods in this class.

3. **Methods and Behavior:** The class contains methods that perform substantive work related to setting up Swagger documentation, including API information, security schemes, and security contexts. These methods construct and configure a `Docket` instance, which is essential for Swagger integration.

4. **Encapsulation:** The class does not expose any fields directly. It uses abstract methods and method parameters to achieve the desired configuration encapsulation.

5. **Local Symptom Summary:** The class is primarily focused on configuring Swagger documentation and does not act as a simple data holder with minimal real behavior. It contains significant logic for setting up and customizing Swagger documentation.

Hence, there are no strong symptoms of a Data Class in this file."
MapperBuilderAssistant.java,"### Analysis of `MapperBuilderAssistant.java` for Data Class Symptoms

#### 1. Fields:
The file defines a class with several fields, such as `currentNamespace`, `resource`, `currentCache`, and `unresolvedCacheRef`. However, these fields are mostly private.

#### 2. Accessors:
There is a pattern where the class has getter and setter methods, but not for all fields. For instance, there are getter and setter methods for `currentNamespace` and `resource`, but others like `currentCache` and `unresolvedCacheRef` do not have public setters and might have private accessors.

#### 3. Methods and Behavior:
The class contains several methods that perform meaningful operations such as `useCacheRef`, `useNewCache`, `addParameterMap`, `buildParameterMapping`, `addResultMap`, `addMappedStatement`, `buildResultMapping`, and others. These methods involve complex processes and operations beyond just setting or getting fields.

#### 4. Encapsulation:
The class hides its data behind meaningful services. For example, `useCacheRef` and `useNewCache` handle cache operations, `addParameterMap` manages parameter mappings, and `addMappedStatement` deals with statement creation and configuration.

#### 5. Local Symptom Summary:
The class is not designed to be a primary data holder. It includes several methods that are responsible for the configuration and management of MyBatis mapper operations. The class has construct methods, validation methods, and transformation methods that show it performs significant work beyond data storage.

### Conclusion:
NO, I did not find Data Class.  
**Main evidence:** The class contains numerous methods that perform complex and meaningful operations, not just getters and setters."
BuildCommand.java,"Let's analyze the provided Java file in the context of the ""Data Class"" code smell:

### 1. Fields:
- The class `BuildCommand` has several fields (`job`, `follow`, `sync`, `wait`, `checkSCM`, `parameters`, `consoleOutput`, `retryCnt`), which are used to store data related to the build command.

### 2. Accessors:
- The class does not include explicit getter and setter methods for its fields. However, some fields are annotated with `@Argument` and `@Option` which are used for command-line argument parsing, suggesting they are intended to be accessed and modified via command-line input directly, effectively acting as implicit accessors.

### 3. Methods and Behavior:
- The `run()` method contains significant business logic, including:
  - Checking job permissions.
  - Handling build parameters.
  - Checking for SCM changes.
  - Scheduling the job.
  - Waiting and displaying the build progress.
- The method `printUsageSummary()` provides usage information.
- Substantive work is performed by the `run()` method and related functionality, which contradicts the typical behavior of a data class.

### 4. Encapsulation:
- While the class has some fields exposed (`job`, `follow`, `sync`, `wait`, `checkSCM`, `parameters`, `consoleOutput`, `retryCnt`), a significant part of the class is encapsulated in the `run()` method and related logic.
- There is an internal class `CLICause` which provides additional functionality and does not act as a simple data holder.

### 5. Local Symptom Summary:
- The class is not primarily a data holder with minimal real behavior. It includes several fields but also has a large `run()` method with significant business logic.

### Conclusion:
NO, I did not find Data Class. The class `BuildCommand` includes considerable behavior, particularly in the `run()` method, which performs substantial business operations, not just data storage and simple access."
FrameworkField.java,"Let's analyze the `FrameworkField` class based on the provided criteria:

1. **Fields**:
   - The class has a single private field: `private final Field field;`.
   - It does not have public or package-private fields.

2. **Accessors**:
   - The class has several methods that access and manipulate the `field`:
     - `getField()`
     - `getName()`
     - `getAnnotations()`
     - `getAnnotation(Class<T> annotationType)`
     - `getType()`
     - `getDeclaringClass()`
     - `get(Object target)`
   - These methods are more like wrappers around the `field`'s methods rather than simple getters or setters. They provide additional functionality instead of just returning or setting the field value.

3. **Methods and Behavior**:
   - Other than the accessor-like methods, there are methods like `isShadowedBy`, `isBridgeMethod`, `getModifiers`, which are doing more than just accessing data.
   - The `get(Object target)` method performs logic to retrieve the field value from a given object.
   - The constructor also contains logic to make the field accessible if it is public.

4. **Encapsulation**:
   - While there is a getter for the `field`, the class hides direct access to it behind methods that perform operations.
   - It does expose some data, but it is not solely about data storage and retrieval; it also provides some services related to handling fields.

5. **Local Symptom Summary**:
   - The class has more than just simple getters or setters. Many of its methods involve operations related to `Field` objects.
   - The primary purpose is not to merely store and expose data, but to provide a wrapper with additional functionality around the `Field` class.

Based on the above analysis:

**NO, I did not find Data Class**.

The `FrameworkField` class provides more than just simple data encapsulation and accessors. It includes behavior that manipulates and operates on the underlying `Field` object, indicative of more complex responsibilities beyond being a simple data holder."
CmsSubjectCategoryExample.java,"Let's analyze the provided Java file for signs of the ""Data Class"" code smell according to the criteria you've specified:

1. **Fields:**  
   - The class `CmsSubjectCategoryExample` defines several fields such as `orderByClause`, `distinct`, and `oredCriteria`.
   - These fields are not public, but they do have corresponding getter and setter methods.

2. **Accessors:**  
   - The class has numerous getter and setter methods for its fields (e.g., `setOrderByClause`, `getOrderByClause`, `setDistinct`, `isDistinct`, `getOredCriteria`).
   - There are also several other methods that operate closely on these fields, such as `or`, `createCriteria`, `createCriteriaInternal`, and `clear`.

3. **Methods and Behavior:**  
   - Most methods either set or manipulate the fields, or they help in constructing criteria for database queries.
   - There are very few methods that do substantial work other than the many methods for setting and retrieving fields or modifying lists.

4. **Encapsulation:**  
   - While the fields themselves are not directly exposed, the class provides extensive getter and setter methods, making the state of the object easily accessible and modifiable.
   - The `or` and `createCriteria` methods expose manipulation of the internal `oredCriteria` list, which indirectly exposes the internal representation.

5. **Local Symptom Summary:**  
   - The class is primarily composed of fields and methods that manipulate these fields or generate criteria for database queries.
   - The amount of substansive logic is minimal, mostly revolving around setting up and modifying `Criteria` objects.

**Conclusion:**
YES, I found Data Class

**Clearest evidence:**
Almost all methods are related to either getting or setting fields or manipulating criteria objects, indicating minimal real behavior encapsulated within the class."
GsonBuilder.java,"### Analysis of GsonBuilder for Data Class Code Smell

Let's analyze the provided `GsonBuilder` class according to the criteria given to determine if it exhibits the ""Data Class"" code smell:

1. **Fields:**
   The class defines several fields (attributes) such as `excluder`, `longSerializationPolicy`, `fieldNamingPolicy`, `instanceCreators`, `factories`, `hierarchyFactories`, `serializeNulls`, `datePattern`, `dateStyle`, `timeStyle`, `complexMapKeySerialization`, `serializeSpecialFloatingPointValues`, `escapeHtmlChars`, `prettyPrinting`, `generateNonExecutableJson`, and `lenient`. These fields are private and managed through methods, which is good for encapsulation.

2. **Accessors:**
   While the class does not include traditional getter and setter methods for each field, it does have many configuration methods that set the values of its fields (e.g., `setVersion()`, `excludeFieldsWithModifiers()`, `generateNonExecutableJson()`, etc.). Most of its public methods are configuration methods that modify its internal state.

3. **Methods and Behavior:**
   The methods in this class are not merely getters and setters. They are configuration methods that set up the state of the `GsonBuilder` instance to configure how a `Gson` instance will behave. There are methods that configure serialization policies, enable/disable certain features, and set specific settings. These are substantive methods that perform real behavior.

4. **Encapsulation:**
   The fields are private, and while there isn't a strict adherence to traditional getter/setter patterns, the class does not expose its data in a way that lacks encapsulation. Instead, it provides methods to configure its behavior through method chaining, which is a different pattern used to encapsulate the internal state changes.

5. **Local Symptom Summary:**
   The class primarily holds data and provides methods to configure this data (`GsonBuilder`);
   however, most methods modify internal state to configure behavior rather than being mere getters/setters. Therefore, although it holds significant configuration data, most of its methods are meaningful in performing configuration tasks rather than just data access tasks.

### Conclusion:
**NO, I did not find Data Class.**
While the class holds many fields and has methods to set these fields, most of these methods are not simple getters/setters but configuration methods that perform meaningful tasks to set up the behavior of `Gson` instances. The methods are not merely for data access but for configuring the object's settings."
RedissonBloomFilter.java,"Let's analyze the provided Java file according to the guidelines:

1. **Fields**:
   - The class `RedissonBloomFilter` defines several fields: `size`, `hashIterations`, `commandExecutor`, and `configName`. These fields are used to manage the internal state of the Bloom filter but are not directly exposed with public visibility. Instead, they are protected or private with appropriate accessor methods where needed.

2. **Accessors**:
   - While there are getter methods like `getExpectedInsertions()`, `getFalseProbability()`, `getSize()`, and `getHashIterations()`, these methods are not merely simple accessors in the traditional sense. They involve asynchronous data retrieval from Redis, indicating some behavior rather than just returning a field value. There are no setter methods provided for the core attributes, which reduces the typical ""data class"" symptom here.

3. **Methods and Behavior**:
   - The class contains more than just getter/setter methods. It includes multiple methods that perform substantive work, such as calculating optimal parameters (`optimalNumOfHashFunctions`, `optimalNumOfBits`), hashing data (`hash` methods), performing Redis operations (like `add`, `contains`, `tryInit`), and managing the object's lifecycle (`expireAsync`, `expireAtAsync`, `clearExpireAsync`, `renameAsync`, `renamenxAsync`).

4. **Encapsulation**:
   - The class encapsulates its state fairly well. The fields are not public, and even when data needs to be accessed, it is usually wrapped in more complex operations. The class does expose some state through getter methods, but these are not just simple fields getters.

5. **Local Symptom Summary**:
   - Looking at the overall structure, even though the class has fields and some getter-like methods, it does not primarily serve just as a data holder. It includes significant behavior related to managing and using a Bloom filter.

**Conclusion**:
NO, I did not find Data Class. The class includes substantial behavior and operations beyond just holding and exposing data."
InvokeCountOperation.java,"Let's analyze the provided Java file step by step according to the criteria you've outlined:

1. **Fields:**
   - The class `InvokeCountOperation` has two fields: `opcodeInvokeCountMap` and `limitPerInvoke`. These fields are private.

2. **Accessors:**
   - There are no public getter or setter methods for the fields. The only public method is `getReport()`, which is not just a simple accessor.

3. **Methods and Behavior:**
   - The class has a constructor and three methods. Two of these methods (`processInstructions` and `count`) contain meaningful behavior, including logic and data processing. Only the `getReport()` method only exposure a field indirectly through its `toString()` method.

4. **Encapsulation:**
   - The fields are private, and the class provides no direct access to them via public setters. Instead, it performs operations that modify or retrieve the state of these fields in a controlled manner.

5. **Local Symptom Summary:**
   - The class contains more behavior than just getters and setters. It includes methods that perform specific logic and process data, which suggests it has more functionality than just being a dataholder.

Based on the above analysis:

**NO, I did not find Data Class.** This class has fields that are encapsulated and methods that perform meaningful tasks, which are indicative of a class with behavior rather than a simple data holder."
AbstractSentinelAspectSupport.java,"### Analysis:

1. **Fields:**
   - The class does not define any fields (attributes). It has no instance variables declared.

2. **Accessors:**
   - The class does not have any getter or setter methods. It only contains method definitions.

3. **Methods and Behavior:**
   - The class has many methods, but these methods perform substantive work. They deal with exception handling, method resolution, fallback handling, and more. Essentially, these methods manipulate and use data in meaningful ways rather than just storing or retrieving it.

4. **Encapsulation:**
   - The class does conceal its data as there is no public data exposed. The methods are mostly `protected` or `private`, which implies that the class is designed to encapsulate its behavior.

5. **Local Symptom Summary:**
   - The class does not look like a data holder with minimal behavior. Instead, it has a significant amount of logic performing exception handling, method resolution, and fallback strategies.

### Conclusion:

NO, I did not find Data Class.

The class `AbstractSentinelAspectSupport` is primarily a utility class that provides functionality related to handling exceptions, method invocation, and fallbacks, rather than just holding data."
SaTokenConfig.java,"Let's analyze the given Java file to determine if it exhibits the ""Data Class"" code smell according to the questions provided:

### 1. Fields
The class `SaTokenConfig` defines numerous fields (attributes). These fields include `tokenName`, `timeout`, `activityTimeout`, `isConcurrent`, `isShare`, `isReadBody`, `isReadHead`, `isReadCookie`, `tokenStyle`, `dataRefreshPeriod`, `tokenSessionCheckLogin`, `autoRenew`, `tokenPrefix`, `isPrint`, `isLog`, `jwtSecretKey`, `idTokenTimeout`, `basic`, `currDomain`, `checkIdToken`, `cookie`, and `sso`. These fields are not public but have both getter and setter methods, which is a common pattern for data classes.

### 2. Accessors
There is a significant pattern of simple getter and setter methods in the class. Each field has a corresponding getter and setter pair, except for deprecated methods. Most of the public methods in the class are indeed accessors, with the exception of the `toString` method and some deprecated methods.

### 3. Methods and Behavior
The class has very few methods that could be considered substantive work. Apart from the `toString` method, the primary methods are the myriad getters and setters for the fields. There are no methods that perform complex calculations or business logic.

### 4. Encapsulation
The class attempts to maintain some level of encapsulation by providing getter and setter methods instead of exposing fields directly. However, the large number of such methods suggests that the class is primarily focused on data, not on hiding the data behind meaningful operations.

### 5. Local Symptom Summary
Based on the above points, the class looks like it is primarily a data holder with minimal real behavior. The main signs are:
- A large number of fields and corresponding getter/setter methods.
- Very few methods beyond getters and setters.
- Minimal complex behavior or business logic.

### Conclusion
Based on the analysis:

**YES, I found Data Class**  
The clearest evidence is ""almost all methods are getters/setters."""
HelpCommand.java,"To analyze the provided Java file for symptoms of the ""Data Class"" code smell, we will go through the criteria step-by-step:

1. **Fields:**
   - The class `HelpCommand` defines a field `private String cmd;`. However, this is not, by itself, a strong indicator of a Data Class since there are no additional fields and this field is properly encapsulated with a setter.

2. **Accessors:**
   - The class has only one setter method `public void setCmd(String cmd)`.
   - There are no getter methods for this field or for any data structure within this class.

3. **Methods and Behavior:**
   - The class contains several methods with substantive work: `process()`, `createHelpDetailModel()`, `createHelpModel()`, `createCommandVO()`, `createArgumentVO()`, `createOptionVO()`, `isEmptyName()`, `complete()`, `allCommands()`, and `findCommand()`.
   - These methods handle the actual business logic, such as processing commands, creating models, and completion logic.

4. **Encapsulation:**
   - The class uses proper encapsulation techniques. The data field `cmd` is private and is accessed via a setter.
   - The class provides services through its methods rather than exposing its internal data directly.

5. **Local Symptom Summary:**
   - The class does not exhibit the patterns of a Data Class. It contains a significant amount of behavior and encapsulates its fields properly.

**Conclusion:**
- **NO, I did not find Data Class**. The class `HelpCommand` is not a Data Class as it contains methods that perform substantive work and properly encapsulates its fields."
UrlConnectionClient.java,"NO, I did not find Data Class.

This class, `UrlConnectionClient`, handles HTTP communication using `HttpURLConnection`. It includes methods like `execute`, `openConnection`, `prepareRequest`, and `readResponse` which perform substantive work such as network requests, preparing requests, and reading responses. These methods are not just simple getters or setters but involve significant business logic and calculations related to HTTP communication. The embedded `TypedInputStream` class also has methods that are more than just getters but manipulate an `InputStream`. There are no patterns indicative of a Data Class."
AssemblyProcessor.java,"### Analysis of `AssemblyProcessor` for Data Class Symptoms

#### 1. Fields:
- The class does define several fields, such as `builder`, `assemblyStarted`, `methodStarted`, `methodInterrupted`, `previousLine`, `nativeAddress`, `entryAddress`, `assemblyMethods`, and `architecture`. However, these fields are not public or package-private; they are private, which is a sign that the developer attempted to encapsulate the data.

#### 2. Accessors:
- The class does have a simple getter method `getAssemblyMethods()`, but it doesn't have a significant number of simple setter/getter methods. Most fields are not exposed via getter/setters except for `assemblyMethods`.

#### 3. Methods and Behavior:
- The class has methods that perform substantive work such as `handleLine`, `complete`, and `attachAssemblyToMembers`. These methods are not merely getter/setter methods and involve parsing, processing, and attaching assembly code to method signatures.

#### 4. Encapsulation:
- The class hides its data behind methods. Most fields are private, and the data is exposed primarily through method behaviors rather than direct field access or excessive getter/setter methods.

#### 5. Local Symptom Summary:
- The class has several fields, but they are appropriately encapsulated. It also contains methods that perform substantive work and are not merely simple getters/setters.

### Conclusion
NO, I did not find Data Class. The class has fields that are encapsulated, and it contains methods that perform significant processing rather than being just a simple data holder with minimal real behavior."
JavaBeanDeserializer.java,"After analyzing the provided Java class `JavaBeanDeserializer`, I will step through the criteria to determine if it exhibits the signs of a Data Class:

1. **Fields**:  
The class has several fields including `fieldDeserializers`, `sortedFieldDeserializers`, `clazz`, `beanInfo`, `extraFieldDeserializers`, `alterNameFieldDeserializers`, `fieldDeserializerMap`, `smartMatchHashArray`, `smartMatchHashArrayMapping`, `hashArray`, `hashArrayMapping`, and `autoTypeCheckHandler`. The fields are mostly private or protected, though `beanInfo` is public. It does not expose fields directly but does have getter-like behaviors for some fields.

2. **Accessors**:  
There are getter methods like `getFieldDeserializer(String key)`, `getFieldDeserializer(long hash)`, and others that provide access to the fields. However, there are no public setter methods, and many methods are more than simple getters, performing operations such as creating instances or parsing fields based on input.

3. **Methods and Behavior**:  
While there are methods that operate on the state of the object (e.g., `deserialze`, `createInstance`, `parseField`), the class does contain a significant number of methods that deal with the behavior of deserialization and parsing, which involves more than just accessing or setting field values.

4. **Encapsulation**:  
The class hides most of its internal state and provides methods that perform meaningful operations, showing a higher level of encapsulation than a typical Data Class which would expose more of its state or have very simple accessor methods. The class also contains many methods that handle the deserialization process internally, maintaining its state carefully.

5. **Local Symptom Summary**:  
While the class does contain a lot of fields and methods for accessing and manipulating these fields, most methods perform substantial operations beyond just getting or setting the fields. The class is deeply involved in the process of deserialization and does more than just act as a container of data.

**Conclusion**:  
NO, I did not find Data Class.尽管该类有许多字段和访问这些字段的方法，但它并没有大量仅用于访问字段的简单 getter 和 setter 方法。该类包含执行复杂任务（如反序列化）的方法，展示了比典型数据类更多的行为和封装性。"
RetrofitError.java,"Let's analyze the provided Java file for symptoms of the ""Data Class"" code smell based on the criteria you've outlined:

1. **Fields:**
   - The class `RetrofitError` defines several fields: `url`, `response`, `converter`, `successType`, and `networkError`. None of these fields are exposed directly (i.e., none are public or package-private without a corresponding private field).

2. **Accessors:**
   - The class includes getter methods for each of its non-transient fields (`getUrl()`, `getResponse()`, `isNetworkError()`, `getSuccessType()`). There are no setter methods for these fields, indicating immutability after construction.

3. **Methods and Behavior:**
   - The class includes several methods, but their behavior is primarily about returning the values of its fields (`getBody()` and `getBodyAs(Type type)` do contain some logic, but are more about data transformation and not complex business logic).

4. **Encapsulation:**
   - The data is encapsulated via private fields with corresponding public getter methods. No data fields are directly exposed.

5. **Local Symptom Summary:**
   - The class primarily holds data and provides getters to access that data. It includes very little substantive behavior aside from data transformation that is closely tied to the data it holds.

**Conclusion:**
While the class does not exhibit all the classic symptoms of a Data Class (e.g., it has constructors with parameters and some transformation methods), it primarily consists of data holding and data retrieval methods, with minimal behavior. This leans towards the class being a Data Class.

**Answer:**
YES, I found Data Class. The clearest evidence is ""most methods are getters, and the class primarily holds and retrieves data."""
Selectable.java,"NO, I did not find Data Class.

**Local Symptom Summary:**
The provided file is an interface named `Selectable` which defines a series of operations for selecting and manipulating selectable text without holding any data fields. It does not exhibit symptoms of a Data Class as it contains no fields and only declares methods that perform operations related to text selection and extraction, without any simple getters or setters for fields."
CellFormulaTagHandler.java,"NO, I did not find Data Class.

Explanation:
- **Fields**: The provided class `CellFormulaTagHandler` does not define any fields within itself.
- **Accessors**: There are no getter or setter methods in the class.
- **Methods and Behavior**: The class has three methods (`startElement`, `endElement`, and `characters`), all of which perform substantive work related to handling XML elements specific to cell formulas in an Excel sheet. They are not merely getters or setters.
- **Encapsulation**: The class interacts with other objects (`XlsxReadContext`, `XlsxReadSheetHolder`) in a meaningful way to achieve its functionality, thus encapsulating behavior rather than just exposing data.
- **Local Symptom Summary**: The class has a clear purpose of handling specific XML tags related to Excel formulas and implementing logic specific to that handling. It does not appear to be a data holder with minimal real behavior."
ClassWriter.java,"### Analysis of `ClassWriter.java` for Data Class Smell

Let's break down the file based on the criteria provided:

1. **Fields:**
   - The class `ClassWriter` defines several fields, including `version`, `index`, `pool`, `items`, `threshold`, `key`, `key2`, `key3`, `typeTable`, `access`, `name`, `thisName`, `superName`, `interfaceCount`, `interfaces`, `firstField`, `lastField`, `firstMethod`, and `lastMethod`.
   - These fields store various pieces of information regarding the class being built, such as version numbers, constant pool data, and class structure details.

2. **Accessors:**
   - There are no explicitly defined getter or setter methods for the fields.
   - It does modify fields directly within methods (e.g., in `visit` and `newConstItem`), but does not simply expose fields through getters and setters.

3. **Methods and Behavior:**
   - The class has several methods that perform substantive work, such as `toByteArray()`, `newConstItem()`, `newUTF8()`, `newClassItem()`, `newFieldItem()`, `newMethodItem()`, `newString()`, `newNameTypeItem()`, `get()`, and `put()`.
   - These methods handle the creation, retrieval, and storage of various elements in the constant pool and manage the data structure of the class.

4. **Encapsulation:**
   - Some fields are private (e.g., `access`, `name`, `superName`, `interfaceCount`, `interfaces`), and others are package-private (e.g., `pool`, `items`, `threshold`, `key`, `key2`, `key3`, `typeTable`, `firstField`, `lastField`, `firstMethod`, `lastMethod`).
   - The class maintains internal state and manages access to its data through methods rather than exposing fields directly.

5. **Local Symptom Summary:**
   - While the class does have a significant number of fields, it also has several methods that perform meaningful operations, such as computing the bytecode of the class and managing constant pool entries.
   - The methods are not merely getters and setters but handle complex tasks related to bytecode generation.

### Conclusion
- Based on the analysis, **NO, I did not find Data Class**.
- The `ClassWriter` class contains multiple fields but also implements several methods that perform substantive tasks, indicating that it has meaningful behavior beyond just holding data."
CompareToBuilder.java,"**NO, I did not find Data Class**

### Analysis of the Java File

1. **Fields:**
   - The class `CompareToBuilder` has one field, `comparison`, which is private and used internally for storing the state of the comparison result.

2. **Accessors:**
   - There are no simple getter and setter methods for the field `comparison`. Instead, there are methods like `appendSuper`, `append`, and their overloaded versions, which are used for comparing fields of objects and chaining these comparisons.

3. **Methods and Behavior:**
   - Most methods perform significant operations such as comparing fields of objects, handling various data types, and managing the state of the comparison. These methods are crucial for the class's functionality and business logic.

4. **Encapsulation:**
   - The class encapsulates its state (`comparison`) by not providing public access to it. The state is modified and used within the class's methods, and its value is only exposed through the `toComparison` and `build` methods, which provide a single value representing the final comparison result.

5. **Local Symptom Summary:**
   - The class `CompareToBuilder` is designed to perform complex operations for comparing objects based on multiple fields. It contains no unnecessary data members and methods all contribute to its main functionality, which is building and returning a comparison result.

Based on this analysis, there are no strong symptoms of a Data Class in the file provided. The class has a clear purpose and performs substantive work."
DataFormatter.java,"NO, I did not find Data Class.

**Explanation:**
- **Fields:** The class does define several fields (attributes) that hold its state, such as `decimalSymbols`, `dateSymbols`, and various formatting patterns and settings. However, these fields are not exposed publicly or through simple getters/setters.
- **Accessors:** There are a few accessors (e.g., `setDefaultNumberFormat`, `addFormat`), but they are not simple getters/setters. The majority of methods are not mere accessors.
- **Methods and Behavior:** The class contains numerous methods that perform substantive work, such as formatting dates, numbers, and cells, and handling different formatting cases.
- **Encapsulation:** The class maintains good encapsulation by keeping its fields private and providing specific methods for interacting with the data.
- **Local Symptom Summary:** The class has significant behavior related to formatting and parsing, indicating it does more than just hold data."
AccessTokenModel.java,"### Analysis

1. **Fields**:
   - The class defines several fields: `accessToken`, `refreshToken`, `expiresTime`, `refreshExpiresTime`, `clientId`, `loginId`, `openid`, `scope`.
   - Most fields (`accessToken`, `refreshToken`, `expiresTime`, `refreshExpiresTime`, `clientId`, `openid`, `scope`) are public, which is a strong sign.

2. **Accessors**:
   - There are two getter methods (`getExpiresIn()`, `getRefreshExpiresIn()`) that do some calculation.
   - However, no setter methods are provided, which is unusual for a true data class that typically includes both.

3. **Methods and Behavior**:
   - There are minimal methods that do substantive work: `getExpiresIn()`, `getRefreshExpiresIn()`, and `toLineMap()`.
   - `toString()` and constructors are typical.
   - The methods that do exist mostly revolve around accessing or transforming the data, not much business logic.

4. **Encapsulation**:
   - The class exposes its data fields directly because they are public.
   - No encapsulation is seen as there are no getter and setter methods for controlling access to the fields.

5. **Local Symptom Summary**:
   - The class primarily holds data with all fields being public.
   - It contains very few methods that do substantive work.

### Conclusion

**YES, I found Data Class**
- **Evidence**: ""all fields are public"" and ""very few methods do substantive work beyond accessors""."
NiceSecurePasswordField.java,"2. **Accessors:**
   The class includes several methods that are essentially passing through calls to the `passwordField` object, such as `getText()`, `textProperty()`, `getCharacters()`, `setPassword(CharSequence)`, `setPassword(char[])`, `wipe()`, `selectAll()`, and `selectRange(int, int)`. These methods primarily serve to expose the functionality of the `passwordField` internally without adding much behavior.

3. **Methods and Behavior:**
   Most of the methods in this class do not perform significant operations on their own. They either delegate calls to methods of the `passwordField` or handle UI-specific details like setting up icons and buttons. The main substantive work seems to be related to UI configuration and some icon handling.

4. **Encapsulation:**
   While the fields themselves are private, the class exposes a lot of its data (primarily through the `passwordField`'s properties and methods). There aren't many meaningful service methods that encapsulate behavior; instead, it provides many getters and setters (or passthrough methods) that expose the underlying fields of `passwordField`.

5. **Local Symptom Summary:**
   The class has several signs of being a Data Class. Most of its public methods are simple accessors or pass-through calls without additional behavior. The class itself is primarily concerned with setting up a UI component (`StackPane`) and its associated elements, rather than performing meaningful operations.

**Conclusion:**
YES, I found Data Class. The main sign is that almost all public methods are either accessors or pass-through methods without substantial behavior."
GeometryViewerRegistry.java,"Let's analyze the provided Java file, `GeometryViewerRegistry.java`, for the symptoms of a Data Class code smell:

### Analysis

1. **Fields:**
   - The class does define several fields, including `Map<String, GeometryViewerDescriptor> viewers`, `List<LeafletTilesDescriptor> predefinedTiles`, and `List<LeafletTilesDescriptor> userDefinedTiles`.
   - These fields are not public, but they are exposed through getter methods.

2. **Accessors:**
   - The class has several getter and setter methods, such as `getSupportedViewers()`, `getViewer()`, `getPredefinedLeafletTiles()`, `getUserDefinedLeafletTiles()`, `getDefaultLeafletTiles()`, `setDefaultLeafletTiles()`, and methods to update and flush configurations.
   - While these methods primarily expose or modify the state of the fields, some methods like `updateTiles()` and `flushConfig()` perform additional substantive work.

3. **Methods and Behavior:**
   - The majority of methods deal with accessing or modifying the state of the fields.
   - There are a few methods that do more substantive work, such as reading from configuration files and updating preferences, but these are relatively small in number.

4. **Encapsulation:**
   - The class encapsulates its data well, providing synchronized getter and setter methods for certain fields (`predefinedTiles`, `userDefinedTiles`, and `defaultLeafletTiles`).
   - Data is more hidden behind methods rather than being directly exposed, although there are many accessors.

5. **Local Symptom Summary:**
   - The class holds significant data related to geometry viewers and leaflet tiles, and provides access to this data primarily through getter and setter methods.
   - However, it also contains methods that perform meaningful operations, such as reading configurations and updating tiles.

### Conclusion
Based on the analysis, the classic symptoms of a Data Class are present, but there are notable exceptions where the class is not purely a data holder. It has methods that perform substantive work, such as reading configurations and updating preferences.

**Final Answer:**
NO, I did not find Data Class. While the class has many accessor methods, it also includes methods that perform significant operations, thus not fitting the strict definition of a Data Class."
RestMethodInfoTest.java,"NO, I did not find Data Class. The provided Java file, `RestMethodInfoTest`, appears to be a comprehensive test suite for the `RestMethodInfo` class in a Retrofit library. Here's the breakdown based on the provided criteria:

1. **Fields:** The file does not define a class with individual fields that act primarily as data storage. Instead, it contains tests that instantiate and verify the behavior and state of `RestMethodInfo` instances through various test methods.

2. **Accessors:** There are no explicit simple getter and setter methods defined in the test file. The file focuses on testing scenarios rather than defining access methods for data handling.

3. **Methods and Behavior:** The file contains numerous methods, but they are all test methods designed to validate the functionality and behavior of `RestMethodInfo` under different conditions and inputs. These methods are not simple accessors but substantial tests that ensure the class behaves as expected.

4. **Encapsulation:** The test file does not provide insight into the encapsulation practices of the `RestMethodInfo` class itself, as it only tests this class. Based on the testing methods, though, it can be inferred that the class encapsulates its logic well, given the need for the test file to cover a wide range of cases and edge conditions.

5. **Local Symptom Summary:** This class does not appear to be a Data Class because it contains no significant fields defined for data storage and all methods are focused on testing the behavior of an external class (`RestMethodInfo`). There are no methods doing simple data handling; rather, almost all methods are test cases that include substantial assertions and setup code.

In summary, the given file is a test class that does not exhibit signs of a Data Class based on the individual criteria provided."
AssertUtil.java,"NO, I did not find Data Class.

**Explanation:**

1. **Fields:** The file does not define any fields in the `AssertUtil` class. It only contains static methods.

2. **Accessors:** There are no getter or setter methods in this class. The class does not expose any data through such methods.

3. **Methods and Behavior:** The class contains several methods that perform substantive work, specifically assertion and comparison logic. These methods are not simple data accessors.

4. **Encapsulation:** Since the class does not have any fields, it cannot exhibit poor encapsulation related to data fields.

5. **Local Symptom Summary:** The `AssertUtil` class is primarily a utility class with methods for performing assertions and comparisons. It does not act as a data holder with minimal real behavior."
FieldAttributes.java,"Let's analyze the Java file step by step according to the given criteria:

1. **Fields:**  
   - The class `FieldAttributes` has several fields, primarily `private final Field field;`. The field is encapsulated and not exposed directly.

2. **Accessors:**  
   - The class contains multiple simple getter methods that provide access to the data stored in the `field` object. For example, `getDeclaringClass()`, `getName()`, `getDeclaredType()`, `getDeclaredClass()`, `getAnnotation(Class<T> annotation)`, `getAnnotations()`, `hasModifier(int modifier)`, `get(Object instance)`, and `isSynthetic()`. There are no setter methods since the field is final and immutable.

3. **Methods and Behavior:**  
   - Most methods do not perform substantive work but rather delegate to methods of the `Field` object, fetching or checking properties of the field. There are no methods that perform complex calculations or business logic.

4. **Encapsulation:**
   - The class hides the `field` object behind various accessor methods, providing a higher-level abstraction without fully exposing the underlying `Field` object.

5. **Local Symptom Summary:**
   - The class primarily serves as a holder for attributes related to a `Field` object, with methods that do not add significant behavior beyond simple data retrieval.

**Conclusion:**
- Based on the analysis, the class has strong symptoms of a Data Class, with minimal real behavior and primarily serving to encapsulate and provide access to attributes of a `Field` object.

**Answer:**  
YES, I found Data Class. The clearest evidence is that almost all methods are getters that provide information about the encapsulated `Field` object with no additional behavior."
ExcelWriteFillExecutor.java,"Let's analyze the provided Java file step by step for symptoms of the ""Data Class"" code smell.

1. **Fields:**
   The class defines several fields (attributes) such as `templateAnalysisCache`, `templateCollectionAnalysisCache`, `collectionFieldStyleCache`, `collectionRowHeightCache`, `collectionLastIndexCache`, `relativeRowIndexMap`, `currentDataPrefix`, and `currentUniqueDataFlag`. These fields are not public, but they have private visibility with getter and setter methods to manipulate them. This suggests they are intended to maintain the state of the object, which is not inherently indicative of a Data Class.

2. **Accessors:**
   The class does not explicitly show many simple getter and/or setter methods in the provided code, as these attributes are private and not providing traditional getters and setters. However, the private methods indicating manipulation of fields (like `getRelativeRowIndex`, `setRelativeRowIndex`) could be seen as a form of encapsulated access.

3. **Methods and Behavior:**
   The class has many methods that perform substantive work, such as `fill`, `shiftRows`, `increaseRowIndex`, `doFill`, `getOneCell`, `createCellIfNecessary`, `createRowIfNecessary`, `checkRowHeight`, `readTemplateData`, `prepareData`, and `dealAnalysisCell`. These methods are doing significant processing and handling the business logic of filling data into an Excel spreadsheet template.

4. **Encapsulation:**
   The class adheres to good encapsulation practices, where the internal state (fields) is not exposed directly. Instead, it is accessed and modified through methods like `fill`, `initAnalysisCell`, etc.

5. **Local Symptom Summary:**
   The class does not primarily appear to be a data holder with minimal real behavior. It has several methods that perform complex operations related to filling data into Excel templates, thus indicating substantial behavior rather than data encapsulation alone.

**Conclusion:**
NO, I did not find Data Class. The provided Java class `ExcelWriteFillExecutor` contains significant logic and behavior for handling data filling in Excel templates, which contradicts the characteristics of a Data Class."
Throwables.java,"NO, I did not find Data Class

**Explanation:**

1. **Fields:** There are very few fields in the provided Java file, and those that are present (`TEST_FRAMEWORK_METHOD_NAME_PREFIXES`, `TEST_FRAMEWORK_TEST_METHOD_NAME_PREFIXES`, `REFLECTION_METHOD_NAME_PREFIXES`) are not exposed outside the class.
   
2. **Accessors:** The file does not define any simple getters or setters. The methods defined in the class perform specific tasks related to processing exceptions and stack traces.

3. **Methods and Behavior:** The class contains several methods that perform meaningful work, such as rethrowing exceptions, formatting stack traces, and filtering specific parts of the stack trace. The methods are not limited to just getting or setting fields.

4. **Encapsulation:** The class uses good encapsulation practices. None of the essential fields are public or package-private, and the methods are static utilities that do not expose internal state.

5. **Local Symptom Summary:** The class appears to be a utility class with methods focused on dealing with `Throwable` objects, formatting stack traces, and filtering specific parts of the stack trace. It does not look like a Data Class due to the lack of exposed fields and the presence of substantive behavior.

Based on these observations, the class does not exhibit symptoms of a Data Class."
BeanCopier.java,"Let's analyze the `BeanCopier` class in `cn.hutool.core.bean.copier` based on the criteria for identifying a Data Class:

1. **Fields:**
   - The class defines several fields: `source`, `dest`, `destType`, and `copyOptions`.
   - These fields are private, not public, which is good practice for encapsulation.

2. **Accessors:**
   - There are no getter or setter methods for the fields. The class does not expose its fields through accessors.

3. **Methods and Behavior:**
   - The class has several meaningful methods:
     - `copy()`: Core functionality for copying properties from the source to the destination.
     - `beanToBean()`, `mapToBean()`: Helper methods for specific types of copying.
     - `mapToMap()`, `beanToMap()`: Additional functionality for converting between different types.
     - `valueProviderToBean()`: Comprehensive method for copying values to a bean from a provider.
   - Most methods involve substantial work, including iterating over properties, performing type conversions, and handling exceptions.

4. **Encapsulation:**
   - The class encapsulates its data well. The data fields are private, and methods do not expose internal state without processing.
   - The class provides a single public method `copy()` that users can call to perform the copying, hiding the internal workings.

5. **Local Symptom Summary:**
   - The class is not merely a data holder. It performs significant operations to copy properties between objects or maps, transforming data according to options provided.

Based on this analysis:

**NO, I did not find Data Class**. The class contains meaningful behavior and performs significant operations rather than merely holding or exposing data through simple accessors."
AndroidGraphics.java,"Let's analyze the provided Java file methodically to determine whether it exhibits symptoms of the ""Data Class"" code smell.

### 1. Fields:
- The class defines many fields such as `width`, `height`, `safeInsetLeft`, `safeInsetTop`, `safeInsetBottom`, `safeInsetRight`, `app`, `gl20`, `gl30`, `eglContext`, `glVersion`, `extensions`, and others. These fields are used to store configuration and state information.
- **Evidence:** Numerous fields are defined and used throughout the class for configuration and state.

### 2. Accessors:
- The class has numerous getter and setter methods.
- Examples include `getWidth`, `getHeight`, `getBackBufferWidth`, `getBackBufferHeight`, `getGL20`, `setGL20`, `isGL30Available`, `getGL30`, `setGL30`, and many more.
- Many of the public methods are indeed getter and setter methods.
- **Evidence:** Presence of numerous getter and setter methods that predominantly access or modify instance fields.

### 3. Methods and Behavior:
- There are multiple methods that perform significant functionality, not limited to simple data access.
- Examples of substantive methods include `updatePpi`, `setupGL`, `onSurfaceChanged`, `onSurfaceCreated`, `onDrawFrame`, and many lifecycle methods.
- These methods implement complex logic such as setting up the GL context, handling rendering, and managing lifecycle events.
- **Evidence:** Methods like `onSurfaceCreated` perform complex setup logic, and `onDrawFrame` implements rendering logic, indicating real behavior.

### 4. Encapsulation:
- The class provides encapsulation of its data through methods like getters and setters, following Object-Oriented principles.
- While some fields are declared with `volatile`, most are not publicly accessible and are typically accessed through methods.
- **Evidence:** Use of getter and setter methods with limited public fields supports a level of encapsulation.

### 5. Local Symptom Summary:
- While the class has many fields and accessors, it also contains significant methods that perform real behavior, such as those related to rendering, managing the GL context, and handling lifecycle events.
- **Evidence:** Although it has numerous fields typical of a data holder class, it contains many methods that perform substantial work beyond simple data access, reducing its appearance as a typical Data Class.

Based on the analysis, the class does not primarily serve just as a data holder with minimal real behavior.

### Conclusion:
NO, I did not find Data Class

The class not only holds data but also includes multiple methods that perform complex operations, indicating it is not primarily a data holder."
ExecutorRouteBusyover.java,"NO, I did not find Data Class

The provided Java file defines a class `ExecutorRouteBusyover` that extends `ExecutorRouter`. This class contains only one method, `route`, which performs substantive work such as iterating through a list of addresses, interacting with an `ExecutorBiz` service, and handling exceptions. While the class could grow to include more getters/setters and data-holding capabilities, based on the current file content, it does not exhibit strong symptoms of a Data Class. The class primarily consists of behavior rather than data exposure or simple accessors."
IncompleteElementException.java,"NO, I did not find Data Class.

**Local Symptom Summary:**
- **Fields:** The class has only one field (`serialVersionUID`), which is a constant used for serialization purposes. This is not indicative of a Data Class.
- **Accessors:** There are no getter or setter methods defined in the class.
- **Methods and Behavior:** The class defines constructor methods that call the superclass constructors, but these do not constitute substantial behavior or methods that perform calculations or business logic.
- **Encapsulation:** The single field is private, and there are no public fields or extensive accessors, indicating good encapsulation.
- **Overall:** The class is primarily an exception class extending `BuilderException` and does not function as a data holder with minimal real behavior."
NioClientTest.java,"NO, I did not find Data Class.

**Explanation:**
The provided Java file contains the `main` method for `NioClientTest`, which is a client application that tests the `NioClient` class. It initializes a client, sets a channel handler, listens for incoming messages, and sends messages to a server. This class does not define any fields, getters, or setters. Instead, it uses the `NioClient` class to perform substantial behavior like reading and writing data, handling exceptions, and providing user interaction. Therefore, it does not exhibit the characteristics of a Data Class."
ClientHandler.java,"NO, I did not find Data Class.  
**Explanation:**

1. **Fields:** The class `ClientHandler` has three private fields (`httpd`, `inputStream`, `acceptSocket`), which is not a large number. The fields are private, showing encapsulation practices.

2. **Accessors:** There are no getter or setter methods defined in the class.

3. **Methods and Behavior:** The class contains more than just getter and setter methods. It has the `close()` method and the overridden `run()` method. The `run()` method includes significant behavior (managing resources, handling sessions, logging exceptions, etc.), which indicates that it contains meaningful work and is not just a data holder.

4. **Encapsulation:** The fields are private, and the class provides a `close()` method to handle the cleanup of resources, demonstrating encapsulation and good design principles.

5. **Local Symptom Summary:** The class does not exhibit the characteristics of a Data Class since it performs significant behavior in its methods and follows good encapsulation practices."
DefaultJedisSocketFactory.java,"### Analysis of the Java File for Data Class Symptoms

Let's go through the provided Java class, `DefaultJedisSocketFactory`, to look for signs of a Data Class code smell.

#### 1. Fields:
The class defines several fields, including:
- `hostAndPort`
- `connectionTimeout`
- `socketTimeout`
- `ssl`
- `sslSocketFactory`
- `sslParameters`
- `hostnameVerifier`
- `hostAndPortMapper`

These fields are encapsulated with private visibility, which is not a sign of a Data Class by itself, but the presence of multiple fields is noted.

#### 2. Accessors:
The class includes numerous getter and setter methods, such as:
- `getHostAndPort` / `setHostAndPort`
- `getConnectionTimeout` / `setConnectionTimeout`
- `getSoTimeout` / `setSoTimeout`
- `isSsl` / `setSsl`
- and many more for each field.

This indicates a strong presence of accessor methods.

#### 3. Methods and Behavior:
The class has one method, `createSocket`, which performs meaningful work related to creating and configuring a socket. It also includes business logic related to SSL/TLS configuration and hostname verification.

The other methods are simply getters and setters for fields. This means that the majority of the public methods are indeed accessors.

#### 4. Encapsulation:
Though the fields are not directly public, the class provides numerous public methods to get and set these fields. This could suggest that the class relies heavily on exposing its internal state through accessors.

#### 5. Local Symptom Summary:
The class primarily consists of fields and their corresponding getters and setters. While there is one method (`createSocket`) that performs substantive work, the overall majority of the public methods are accessors. This meets the criteria for a Data Class.

### Conclusion:
**YES, I found Data Class** — almost all methods are getters/setters, and there is minimal real behavior beyond these accessors."
CronExpression.java,"After analyzing the provided Java file for `CronExpression`, let's address the questions regarding the ""Data Class"" code smell:

1. **Fields:**
   - The class defines several fields, many of which are transient `TreeSet<Integer>` objects representing cron expression components like seconds, minutes, hours, etc. These fields are not public, but they have getters and setters.

2. **Accessors:**
   - There are getter methods for fields such as `seconds`, `minutes`, `daysOfMonth`, `months`, `daysOfWeek`, `years`, `cronExpression`, and `timeZone`. However, these are not simple fields and represent somewhat complex data structures.

3. **Methods and Behavior:**
   - There are several methods that perform complex operations like parsing cron expressions (`buildExpression`), validating cron expressions (`isValidExpression`), and computing the next valid time (`getTimeAfter`). These methods handle significant business logic related to cron scheduling.

4. **Encapsulation:**
   - The class exhibits good encapsulation by making most of its fields private and offering method-based access. There are no public fields that are frequently exposed.

5. **Local Symptom Summary:**
   - Although the class has methods for getting and setting fields, these methods are not simple or numerous getters and setters typical of a Data Class. Instead, they manage fairly complex internal state and logic.

**Conclusion:**
- **NO, I did not find Data Class**
   - While the class has multiple fields and two types of getters (one for a typical field like `cronExpression` and another for complex data structures like `seconds`), the presence of substantial methods that perform parsing and date computation indicates that this class contains meaningful behavior beyond simple data storage. This behavior is essential for the functionality of cron scheduling and evaluation, which rules out classification as a Data Class."
PooledDataSource.java,"Let's analyze the file based on the criteria you provided to determine if it might have the ""Data Class"" code smell.

### 1. Fields:
The file defines a class (`PooledDataSource`) with several fields, mostly protected. Examples include `poolMaximumActiveConnections`, `poolMaximumIdleConnections`, `poolMaximumCheckoutTime`, and many others. These fields are generally used to configure and manage the connection pool and are not public.

### 2. Accessors:
There is a significant pattern of getter and setter methods for each of the fields. For example, `getPoolMaximumActiveConnections`, `setPoolMaximumActiveConnections`, `getPoolMaximumIdleConnections`, `setPoolMaximumIdleConnections`, etc. Most public methods are indeed accessors for these fields.

### 3. Methods and Behavior:
The class contains more than just simple getters and setters:
- `getConnection()`, `getConnection(String username, String password)` to manage database connections.
- Methods to deal with connection state, such as `forceCloseAll()`, `pushConnection(PooledConnection conn)`, `popConnection(String username, String password)`, `pingConnection(PooledConnection conn)`.
- Implementations of `DataSource` methods like `getLoginTimeout()`, `setLoginTimeout(int loginTimeout)`, etc.

In addition, there are methods related to internal operations (`popConnection`, `pushConnection`, `pingConnection`) that perform substantive and meaningful work beyond just setting or retrieving values.

### 4. Encapsulation:
While the class exposes configuration via getters and setters, it maintains a good amount of internal state and behavior hidden behind methods like `forceCloseAll`, `pushConnection`, `popConnection`, and `pingConnection`. These methods manage the actual logic for pooling connections and ensuring their validity.

### 5. Local Symptom Summary:
The class holds a lot of data related to connection pooling but includes substantial methods that manage the lifecycle of connections, which go beyond simple data holding and getter/setter operations.

**Conclusion:**

NO, I did not find Data Class. The class has a significant amount of substantive behavior and meaningful methods that manage connection pooling, which indicates it serves a more complex purpose than a simple data holder."
EmbedServer.java,"### Analysis of the Java File

Let's go through the questions step-by-step based on the provided Java file:

1. **Fields:**
   - The `EmbedServer` class defines fields like `executorBiz` and `thread`.
   - The `EmbedHttpServerHandler` inner class defines fields like `executorBiz`, `accessToken`, and `bizThreadPool`.
   - **Observation:** There are fields, but they are not public and are primarily used for the class's operational logic.

2. **Accessors:**
   - The `EmbedServer` class does not have extensive getters and setters.
   - The `EmbedHttpServerHandler` inner class has a constructor but no getters/setters.
   - **Observation:** There are no excessive getters or setters; the fields are accessed and modified directly or through the constructor.

3. **Methods and Behavior:**
   - `EmbedServer` has methods like `start()`, `stop()`, `startRegistry()`, and `stopRegistry()` which are not merely getter/setters. They handle significant operations such as starting and stopping the server, and managing registry.
   - `EmbedHttpServerHandler` has methods like `channelRead0()`, `process()`, `writeResponse()`, `channelReadComplete()`, `exceptionCaught()`, and `userEventTriggered()`. These are not simple accessors but perform complex tasks related to handling HTTP requests.
   - **Observation:** The class and its inner class contain methods that perform substantial tasks, not just data access.

4. **Encapsulation:**
   - The fields are not exposed publicly; they are private and used within the class or passed through the constructor.
   - **Observation:** Encapsulation is maintained; fields are not exposed directly.

5. **Local Symptom Summary:**
   - The main class `EmbedServer` and its nested class `EmbedHttpServerHandler` both contain substantial behaviors and do not primarily act as data holders.
   - **Conclusion:** The class does not exhibit the symptoms of a Data Class. It contains meaningful methods that handle network operations, request processing, and more.

### Final Answer:
NO, I did not find Data Class.  
**Evidence:** The class contains substantial methods that handle network operations, request processing, and business logic, rather than merely serving as a data holder with simple accessors."
SentinelDubboConsumerFilter.java,"Let's analyze the provided Java file step by step to determine if it exhibits symptoms of the ""Data Class"" code smell:

1. **Fields:**
   - The `SentinelDubboConsumerFilter` class does define some fields, specifically within the nested `EntryHolder` static class (`entry` and `params`).
   - These fields are not public or package-private in the main class `SentinelDubboConsumerFilter`; instead, they are encapsulated within a nested class.

2. **Accessors:**
   - There are no getter or setter methods for the fields defined in the `SentinelDubboConsumerFilter` class except for `EntryHolder`.
   - The `EntryHolder` class has a constructor but does not provide any getters or setters for its fields.

3. **Methods and Behavior:**
   - The class contains methods that perform substantive work such as `invoke`, `syncInvoke`, and `asyncInvoke`, which handle the flow of execution and error tracing for Dubbo service calls.
   - Other methods like `getMethodName` and `getInterfaceName` are overridden from a super class and perform specific tasks related to resource naming.

4. **Encapsulation:**
   - The class encapsulates its data within the `EntryHolder` class through a constructor, and the data is not directly exposed.
   - The main class methods handle behavior like invocation, tracing, and exception handling, ensuring that data interactions are governed by methods rather than direct access.

5. **Local Symptom Summary:**
   - There are very few fields, and most of them are encapsulated within a nested static class.
   - The methods in the `SentinelDubboConsumerFilter` class perform significant behavior related to invocation and error handling.
   - There are no predominant accessors (getters/setters) in the main class, and data is handled through method interactions.

Based on the analysis above, the `SentinelDubboConsumerFilter` class does not exhibit the symptoms of a Data Class. It performs meaningful operations and encapsulates its data and behavior appropriately.

**Conclusion:**
NO, I did not find Data Class. The class contains methods that perform significant behavior and does not primarily serve as a holder for data with simple accessors."
QueryParser.java,"Let's go through the questions step by step based on the provided Java code:

1. **Fields:**
   - The class `QueryParser` defines several fields (`combinators`, `AttributeEvals`, `tq`, `query`, `evals`).
   - These fields are private, which is a good practice for encapsulation.
   - There aren’t any public or package-private fields.

2. **Accessors:**
   - The class doesn’t provide any getter or setter methods for its fields. The fields are private and accessed only within the class.

3. **Methods and Behavior:**
   - The class contains numerous methods that perform substantive work, such as parsing the CSS query into an Evaluator tree (`parse()`), processing different parts of the query (`byId()`, `byClass()`, etc.), and handling pseudo-selectors.
   - These methods are not simple accessors; they involve complex operations like parsing, validation, and decision-making based on the input query.

4. **Encapsulation:**
   - The class hides its data behind meaningful services (methods that perform parsing and evaluation logic). The fields are private, and there are no direct accessors.
   - The only data exposed is via the `toString()` method, which returns the original query string.

5. **Local Symptom Summary:**
   - The class does not have the symptoms of a Data Class. It has several private fields but no public accessors. Most of its methods perform complex parsing and evaluation tasks, so it is not merely a data holder with minimal behavior.

**Conclusion:**
NO, I did not find Data Class. The class `QueryParser` contains substantial behavior and does not primarily function as a simple data holder."
HikariDataSource.java,"Let's analyze the given Java file for symptoms of the ""Data Class"" code smell step by step based on the provided criteria.

1. **Fields:**
   - The class `HikariDataSource` has several private fields: 
     - `isShutdown`: An `AtomicBoolean` for tracking shutdown state.
     - `fastPathPool`: A `HikariPool` object.
     - `pool`: Another `HikariPool` object.
   - These fields are not public or package-private; they are encapsulated within private scope.

2. **Accessors:**
   - The class does not have explicit getter and setter methods for its fields.
   - Some configuration settings are inherited from `HikariConfig` (superclass), which suggests the presence of getters/setters in the superclass.
   - The class also includes a few methods like `getPoolName()`, `isRunning()`, etc., which could be seen as accessors in context.

3. **Methods and Behavior:**
   - The class has several methods that do more than just get or set fields:
     - `getConnection()`: Manages connections and lazy initializes the pool.
     - `close()`: Shuts down the pool.
     - `evictConnection(Connection connection)`: Manages connections by evicting them.
     - `isClosed()`: Checks the shutdown state.
   - These methods perform substantive work such as managing database connections and pool lifecycle, which is beyond simple data manipulation.

4. **Encapsulation:**
   - The class encapsulates most of its data fields and only exposes them through behavior-oriented methods.
   - Tracking states and managing database connections are done primarily through encapsulated logic rather than simple accessors.

5. **Local Symptom Summary:**
   - While the class does contain several fields, the evidence suggests that it is not primarily a data holder with minimal behavior. Instead, it manages a connection pool, handles lifecycle, and encapsulates the business logic necessary for these operations.

**Conclusion:**
NO, I did not find Data Class.
- **Evidence:** The class contains substantive methods that perform meaningful operations like managing database connections and handling the lifecycle of the connection pool, which indicates that it is not just a simple data holder."
Excluder.java,"### Analysis of the Java File for Data Class Smell

Let's go through each of the questions based on the provided Java file.

1. **Fields**:
   - The class `Excluder` does define several fields such as `version`, `modifiers`, `serializeInnerClasses`, `requireExpose`, `serializationStrategies`, and `deserializationStrategies`. These are not exposed publicly; they are declared as `private`.

2. **Accessors**:
   - The class provides numerous methods that modify or retrieve the state of its fields, such as `withVersion`, `withModifiers`, `disableInnerClassSerialization`, `excludeFieldsWithoutExposeAnnotation`, `withExclusionStrategy`, and the `create` method generates handlers that use and manipulate the object’s fields. Most of these methods return a new `Excluder` object with the desired modifications, following the builder pattern. However, there aren't simple getters and setters in the traditional sense. Most methods perform some form of logic with the fields rather than merely setting or getting them.

3. **Methods and Behavior**:
   - The class contains quite a bit of method logic that is not merely reading or setting values of fields. Methods like `excludeField`, `excludeClass`, `excludeClassChecks`, `isAnonymousOrLocal`, `isInnerClass`, `isStatic`, `isValidVersion`, `isValidSince`, and `isValidUntil` contain substantive behavior related to field exclusion logic, rather than just manipulating or retrieving the fields.

4. **Encapsulation**:
   - The class hides its state behind specific methods that perform tasks such as creating type adapters, excluding fields based on certain conditions, and applying strategies. This does not suggest that the data is overly exposed.

5. **Local Symptom Summary**:
   - While the class does contain several fields and methods to manipulate those fields, the majority of its methods provide complex behavior related to field exclusion rather than just serving as getters and setters. Therefore, it does not strongly resemble a typical data class.

### Conclusion

**Answer: NO, I did not find Data Class**

**Reason:** The class `Excluder` contains fields and methods to manipulate those fields, but a significant portion of the methods perform meaningful logic related to field exclusion, serialization, and deserialization. The class is not primarily a data holder with minimal real behavior but rather a utility class with substantial behavior that defines the exclusion logic."
JedisClusterCommand.java,"Let's analyze the Java file for symptoms that indicate the ""Data Class"" code smell, following the steps provided:

### 1. Fields:
- The class `JedisClusterCommand` has several fields: `connectionHandler`, `maxAttempts`, and `maxTotalRetriesDuration`.
- These fields are private, indicating that they are not directly exposed, which is a sign of good encapsulation.

### 2. Accessors:
- There are no getter or setter methods for the fields `connectionHandler`, `maxAttempts`, and `maxTotalRetriesDuration`.
- The class does not seem to have many simple getter and/or setter methods.
- Most public methods are not accessors but perform operations (`run`, `runBinary`, `runWithAnyNode`).

### 3. Methods and Behavior:
- The class primarily contains methods that perform substantive work, such as handling cluster commands, managing retries, and dealing with exceptions.
- Methods like `run`, `runBinary`, `runWithAnyNode`, `runWithRetries` all contain significant logic and calculations, not just getting or setting fields.

### 4. Encapsulation:
- The class hides its data behind meaningful services, as seen in the methods that perform operations and manage the cluster commands.
- There are no public fields, and methods are not merely getters and setters, indicating that the class encapsulates its data well.

### 5. Local Symptom Summary:
- This class looks more like a command handler class with a significant amount of business logic rather than a data holder.
- The presence of multiple methods that perform operations and handle exceptions, along with the lack of simple getters/setters, strongly indicates that this is not a Data Class.

**Conclusion:**
NO, I did not find Data Class.

**Evidence:**
The class contains multiple methods that perform substantive work and handle exceptions, indicating that it is not a simple data holder."
TestConnections.java,"NO, I did not find Data Class

### Step-by-Step Analysis:

1. **Fields**:  
   The `TestConnections` class does not define any fields. It only contains test methods and a static nested class (`StubDataSourceWithErrorSwitch`) and a static class (`OverrideHandler`).

2. **Accessors**:  
   There are no getter or setter methods in the `TestConnections` class. The class primarily interacts with other classes and objects via methods for setup, assertions, and test conditions.

3. **Methods and Behavior**:  
   The class is filled with test methods (`@Test` annotations). These methods do substantial work including setting up test configurations, executing database interactions, and asserting that the behavior of `HikariDataSource` and other related components matches expected outcomes.

4. **Encapsulation**:  
   The class maintains good encapsulation by not exposing any internal fields. All interactions are through method calls, which is typical in unit testing classes.

5. **Local Symptom Summary**:  
   The class is clearly focused on testing functionality and does not act as a simple data holder. There are no fields to hold data, and methods perform complex operations for setting up and validating tests.

### Conclusion:
The provided Java file does not exhibit signs of a Data Class. It is a test class focused on testing the behavior of the `HikariDataSource` and related components, not primarily on holding data or providing simple accessors."
OmsReceiverInfoParam.java,"Based on the provided Java file, let's analyze it step by step for symptoms of the ""Data Class"" code smell:

1. **Fields:**
   - The class `OmsReceiverInfoParam` defines several fields: `orderId`, `receiverName`, `receiverPhone`, `receiverPostCode`, `receiverDetailAddress`, `receiverProvince`, `receiverCity`, `receiverRegion`, and `status`.
   - Fields are defined as `private`, which is a good practice for encapsulation, but they are exposed through getters and setters.

2. **Accessors:**
   - The class uses `@Getter` and `@Setter` annotations from Lombok, which generate getters and setters for all fields.
   - There are numerous simple getter methods implemented, and they are returning `null`, which suggests incomplete implementation rather than meaningful behavior.

3. **Methods and Behavior:**
   - Apart from the getter methods that return `null`, there are no other methods that appear to do any substantive work such as calculations, business logic, etc.
   - The `getStatus` and `getStatus1` methods are redundant and incorrectly implemented, further indicating lack of meaningful behavior.

4. **Encapsulation:**
   - While the fields are `private` and accessors are provided through Lombok, the actual implementation of the getters suggests that the class does not hide its data behind meaningful services.
   - The getters are essentially just pass-throughs with no additional processing, aligning with a Data Class pattern.

5. **Local Symptom Summary:**
   - The class primarily holds data with little to no real behavior.
   - Most methods are getters that return `null`, and there are no apparent meaningful services or substantive business logic methods.

**Conclusion:**

YES, I found Data Class. The main sign is that almost all methods are getters that return `null`, and there is no substantial behavior implemented in the class."
ResizeController.java,"Let's analyze the provided Java file step by step based on the criteria for detecting the ""Data Class"" code smell.

### 1. Fields
The class `ResizeController` defines several fields:
- Public `Region` fields such as `tlResizer`, `trResizer`, etc.
- Private fields like `origX`, `origY`, `origW`, `origH`
- `settings` field of type `Settings`
- `window` field of type `Stage`
- `showResizingArrows` field of type `BooleanBinding`

Presence of many fields suggests it might be storing a lot of data.

### 2. Accessors
There are no explicit getter or setter methods provided in the class for the public `Region` fields. However, there is a `showResizingArrowsProperty` getter method, indicating at least some level of accessors. The absence of standard accessors for other fields is noteworthy.

### 3. Methods and Behavior
- `initialize()`: This method initializes the window with some logic.
- `neverTouched()`, `didDisplayConfigurationChange()`, and `getMonitorSizes()` are private utility methods that handle logic specifically related to the window settings handling.
- `startResize()`, `resizeTopLeft()`, `resizeTopRight()`, `resizeBottomLeft()`, `resizeBottomRight()`, `resizeTop()`, `resizeLeft()`, `resizeBottom()`, `resizeRight()`: These methods all pertain to the resizing functionality and do meaningful work.
- `savePositionalSettings()`: This method saves the current position and size of the window.
- `showResizingArrowsProperty()`, `isShowResizingArrows()`: These methods provide the state of whether resizing arrows should be displayed.

The class has several methods that perform substantive work, not just getting and setting fields.

### 4. Encapsulation
- The class's public fields (`tlResizer`, `trResizer`, etc.) are exposed directly, which is a sign of poor encapsulation.
- The other fields are private, but the public fields reduce encapsulation overall.

### 5. Local Symptom Summary
While the class has several data fields and a few accessors, it also contains multiple methods that perform meaningful operations. The primary role of the class is not merely to store data but to handle the window resizing and positioning logic.

**Conclusion:**
NO, I did not find Data Class. The presence of multiple methods that perform calculations and handle window behavior suggests that `ResizeController` has a significant amount of real behavior, not just being a data holder."
Lifecycle.java,"Let's analyze the provided Java file step by step according to the criteria for detecting a ""Data Class"" code smell:

1. **Fields:**
   - The class `Lifecycle` does define fields, such as the static field `INSTANCE` and the private static field `LOGGER`.
   - There are no public or package-private fields exposed directly. The only field that comes close is `INSTANCE`, but it is protected by a singleton pattern and is not directly accessible.

2. **Accessors:**
   - There are some accessor methods such as `get()` for the singleton instance and methods like `getHudsonWar()` and `canRewriteHudsonWar()` for accessing field的状态 or other data.
   - The methods are not predominantly simple getters and setters. They contain logic beyond just returning or setting fields.

3. **Methods and Behavior:**
   - The class contains several methods that do substantive work, including `getHudsonWar()`, `rewriteHudsonWar(File by)`, `canRewriteHudsonWar()`, `restart()`, `verifyRestartable()`, and `canRestart()`.
   - Each method has its own purpose, such as file operations, verification, and exceptions handling, indicating that the class encapsulates behavior relevant to its responsibility.

4. **Encapsulation:**
   - The class hides its data behind methods that perform operations. For example, `INSTANCE` is accessed and modified through the `get()` method. 
   - It also uses encapsulation techniques such as exception handling to protect against mismatches or invalid operations, indicating a level of behavior beyond simple data handling.

5. **Local Symptom Summary:**
   - The class does not primarily act as a data holder with minimal real behavior. It contains several methods that perform significant operations, such as file management, lifecycle verification, and system interactions, which go beyond simple data access.

Based on the analysis above:

**NO, I did not find Data Class.**

The `Lifecycle` class has a mix of fields and methods that go beyond simple data holding, with methods performing substantive operations relevant to system lifecycle management."
MarkdownWebServerPlugin.java,"Let's analyze the Java file step by step according to the guidelines provided:

1. **Fields:**
   - The class `MarkdownWebServerPlugin` has a single field: `private final PegDownProcessor processor;`.
   - This is not a large number of fields, and it is not public or package-private.

2. **Accessors:**
   - There are no explicit getter or setter methods for the `processor` field.

3. **Methods and Behavior:**
   - The class contains methods that do substantive work:
     - `canServeUri(String uri, File rootDir)`: Checks if a file exists.
     - `readSource(File file)`: Reads the content of a file into a string.
     - `serveFile(String uri, Map<String, String> headers, IHTTPSession session, File file, String mimeType)`: Converts Markdown content to HTML and creates an HTTP response.
   - Most methods are not just getters or setters; they perform actual computations and business logic.

4. **Encapsulation:**
   - The field `processor` is private, which follows good encapsulation practices.
   - The class uses meaningful methods (`serveFile`, `readSource`) to operate on its data rather than just exposing fields.

5. **Local Symptom Summary:**
   - The class primarily performs operations related to serving Markdown files, including reading files and converting Markdown to HTML.
   - There is minimal exposure of fields with no plain getters or setters, and the methods do more than just access the fields.

**Conclusion:**
NO, I did not find Data Class. The class `MarkdownWebServerPlugin` contains significant behavior and performs meaningful operations beyond simply storing data."
EsProductServiceImpl.java,"NO, I did not find Data Class.

### Analysis:
1. **Fields**: The class `EsProductServiceImpl` does not define any fields itself. It has fields but they are other dependencies (e.g., `EsProductDao`, `EsProductRepository`, `ElasticsearchRestTemplate`), not data fields.

2. **Accessors**: The class does not contain any getter or setter methods. All methods are related to business logic regarding Elasticsearch operations and data handling.

3. **Methods and Behavior**: The class contains several methods that perform substantive work such as importing data, deleting records, creating products, searching, and recommending products. These are not just simple setters/getters.

4. **Encapsulation**: The class hides its data behind higher-level functions that perform complex operations and does not expose internal fields or methods that only manipulate data.

5. **Local Symptom Summary**: The class does not appear to be a data holder with minimal real behavior. It is more of a service class handling search operations in Elasticsearch, which involves various business logic and data manipulations.

Based on the above analysis, there are no strong symptoms of a Data Class in the provided file."
ProjectExportWizard.java,"### Analysis:

Let's go through each of the criteria to determine if the `ProjectExportWizard` class exhibits symptoms of a Data Class code smell.

1. **Fields**:  
   - The class defines several fields, including `mainPage`, `log`, `COPY_BUFFER_SIZE`, `PROJECT_DESC_FILE`, and `IGNORED_RESOURCES`. Most fields are private and are not exposed directly, but they are used via methods.

2. **Accessors**:  
   - The only fields with getters/setters are part of other classes (`ProjectExportData`), not part of `ProjectExportWizard`. The class itself does not define many simple getter/setter methods for its own fields.

3. **Methods and Behavior**:  
   - The bulk of the methods do substantive work. Methods like `exportProjects`, `getChildCount`, `exportProject`, and `exportResourceTree` involve significant logic for exporting projects and handling resources.
   - There are no methods that only get or set fields of `ProjectExportWizard`.

4. **Encapsulation**:  
   - The class does not expose its data (fields) extensively. Most fields are private, and only used internally or passed to other methods within other objects.
   - The class hides its data behind methods that perform meaningful operations.

5. **Local Symptom Summary**:  
   - The class does not look like it is primarily a data holder with minimal real behavior. Instead, it is more of a wizard that handles complex operations involving project exports.

### Conclusion:

**NO, I did not find Data Class**. The class `ProjectExportWizard` performs significant operations and behaviors, particularly around exporting projects and handling resources. Most methods are substantial and not merely getters/setters, and the data it holds is encapsulated rather than exposed."
SentinelApacheHttpClientConfig.java,"Let's analyze the given Java file for signs indicating the ""Data Class"" code smell:

1. **Fields:**
   - The class defines three private fields: `prefix`, `extractor`, and `fallback`.
   - There are no public or package-private fields, which is a good sign for data encapsulation.

2. **Accessors:**
   - The class provides public getter and setter methods for each of its fields.
   - There are six methods total, five of which are for getting and setting the fields.

3. **Methods and Behavior:**
   - There are no significant methods that perform calculations, logic, or business operations beyond simple getters and setters.
   - The setters include basic validation (checking for `null`), but this is common in data classes to ensure data integrity.

4. **Encapsulation:**
   - The class uses private fields, which is a good practice for encapsulation.
   - However, the class does expose its data primarily through getter and setter methods, without providing higher-level behavior.

5. **Local Symptom Summary:**
   - The class primarily holds data and exposes it through public accessors. It does not contain any significant business logic or operations beyond basic validation in the setters.

**Conclusion:**
YES, I found Data Class. **Main sign:** almost all methods are getters/setters, with no substantial behavior."
CachingExecutor.java,"Let's analyze the provided code file `CachingExecutor.java` for symptoms that may indicate the ""Data Class"" code smell.

### Analysis:

1. **Fields:**
   - The class primarily contains fields such as `private final Executor delegate;` and `private final TransactionalCacheManager tcm = new TransactionalCacheManager();`.
   - These fields are not public and do not have many simple getter/setter methods. The `delegate` field is only accessible through its getter method inside other methods, and `tcm` is used internally.

2. **Accessors:**
   - The class methods are not primarily simple getters and setters. Most methods involve actual logic (like handling transactions, queries, and caching), not merely access to data.

3. **Methods and Behavior:**
   - The methods in the class perform a variety of tasks such as transaction management (`close`, `commit`, `rollback`), query handling (`query`, `queryCursor`, `update`), cache management (`flushCacheIfRequired`, `isCached`), and more.
   - There are methods like `flushStatements` and `deferLoad` which clearly perform specific tasks rather than just manipulating data.

4. **Encapsulation:**
   - The class encapsulates its data, as seen with fields `delegate` and `tcm`. The only exposed data is through method calls which involve complex operations, not simple data fetching or setting.

5. **Local Symptom Summary:**
   - The class does not exhibit behavior typical of a Data Class. It contains meaningful functionality and encapsulates its data well.

### Conclusion:
**NO, I did not find Data Class.** The `CachingExecutor` class appears to be a functional component designed to handle caching and execution tasks, rather than merely holding and exposing data."
RedisPriorityScheduler.java,"NO, I did not find Data Class

### Analysis:

1. **Fields:**
   - The class does define several private fields for keys and prefixes. However, these are constants and not necessarily data fields associated with instances of the class.
   
2. **Accessors:**
   - There are no getter and setter methods provided for the fields. The class does not expose the fields through simple accessors.
   
3. **Methods and Behavior:**
   - The class contains several methods that perform substantive work, including `pushWhenNoDuplicate`, `poll`, `getRequest`, `resetDuplicateCheck`, `getZsetPlusPriorityKey`, `getQueueNoPriorityKey`, `getZsetMinusPriorityKey`, `setExtrasInItem`, and `getExtrasInItem`. These methods deal with the scheduling and management of requests in Redis.
   
4. **Encapsulation:**
   - The fields are private and the class封装s its internal state by providing specific methods that operate on it rather than exposing the fields directly.
   
5. **Local Symptom Summary:**
   - The class has very few public methods and those it does have are not simple accessors. The methods that are present are complex and perform significant operations rather than just setting or getting field values."
EnablePluginCommand.java,"NO, I did not find Data Class

### Explanation:
1. **Fields**: The class has a couple of fields (`pluginNames` and `restart`), which is not a large number on its own, and they are private with appropriate annotations.

2. **Accessors**: There are no getter or setter methods defined for the fields. The fields are accessed directly within the methods defined in the class.

3. **Methods and Behavior**: The class contains methods (`run`, `enablePlugin`, `enableDependencies`) that perform substantive work, such as enabling plugins, checking permissions, and handling dependencies.

4. **Encapsulation**: The class encapsulates its data behind methods that perform meaningful operations and does not expose its fields directly beyond initialization points.

5. **Local Symptom Summary**: The class has more than just getters and setters; it has methods that carry out significant operations and logic. Therefore, it is not primarily a data holder with minimal real behavior."
PoolStats.java,"Let's analyze the Java file based on the criteria provided:

1. **Fields:**
   - The class `PoolStats` defines several fields (`totalConnections`, `idleConnections`, `activeConnections`, `pendingThreads`, `maxConnections`, `minConnections`), which are primarily related to the statistics of a connection pool.
   - These fields are declared as `protected volatile`, allowing subclasses to access and modify them, but they are not public (which is a good sign in terms of encapsulation).

2. **Accessors:**
   - There are multiple simple getter methods (`getTotalConnections`, `getIdleConnections`, `getActiveConnections`, `getPendingThreads`, `getMaxConnections`, `getMinConnections`) for each of the fields.
   - These methods include a check and potential update to the data before returning the field value, which adds some behavior beyond simple data access.

3. **Methods and Behavior:**
   - While there are getter methods that do more than just return a field value by checking and potentially updating the values, there are no methods that perform complex calculations or business logic.
   - The `update()` method is protected and abstract, indicating that subclasses should provide their implementation of how to update the values, but it is not a detailed implementation in the current class.

4. **Encapsulation:**
   - The class tends to encapsulate its data by keeping the fields protected and providing controlled access through getter methods.
   - However, the data is exposed more than it is hidden behind meaningful services since the main operations on the data (except for the `update`, which is done by subclasses) are accessed directly via the getters.

5. **Local Symptom Summary:**
   - Based on the patterns above, the class primarily holds data and provides controlled access to it through its getter methods. Most of the methods are either getters which include a conditional update or are abstract methods to be implemented by subclasses.
   - The class looks like it is mainly a data holder with minimal real behavior, as the bulk of the methods are getters that include a conditional update.

**Conclusion:**

While the class `PoolStats` does not exhibit the most blatant symptoms of a Data Class (such as all fields being public or having only simple getters/setters with no behavior), the presence of many getters that do little more than access and potentially refresh field values, along with very few methods performing behavior, is a strong indication.

**Answer:**  
YES, I found Data Class.  
**Clearest Evidence:**  
Almost all methods are (effectively) getters that perform a conditional update."
MinMaxPriorityQueue.java,"### Analysis:

1. **Fields:**
   - The class `MinMaxPriorityQueue` contains several fields:
     - `Heap minHeap`, `Heap maxHeap`
     - `int maximumSize`
     - `Object[] queue`
     - `int size`
     - `int modCount`
   - While these fields are private, they represent the core data structure of the class, indicating that the class primarily holds data. However, it's not all public or package-private.

2. **Accessors:**
   - The class does not have trivial getter and setter methods for its fields. Instead, it has methods like `size()`, `peek()`, `poll()`, `offer()` etc., which perform operations and are not trivial accessors.

3. **Methods and Behavior:**
   - The class contains a significant amount of logic related to maintaining the Min-Max heap data structure: methods like `offer`, `poll`, `add`, `addAll`, `removeAt`, `fillHole`, `isIntact`, `bubbleUp`, `crossOver`, and many others. These methods implement operations that are integral to the functioning of the data structure.
   - There is also logic to manage the queue's capacity, compare elements, and maintain the heap invariant.

4. **Encapsulation:**
   - The class encapsulates the data and operations required to maintain a min-max priority queue. Methods like `offer`, `poll`, `removeAt` are not trivial getters/setters; they manage the internal data structures and maintain the properties of a min-max heap.
   - The fields are private, with no public setters or getters, which suggests strong encapsulation with meaningful behavior.

5. **Local Symptom Summary:**
   - While the class does hold significant data in the form of its fields, it also provides substantial behavior to maintain the data structure and expose functionality through methods like `offer`, `poll`, `removeAt`, and more.
   - The class is not primarily a data holder with minimal real behavior. Instead, it encapsulates the data and provides a set of complex methods to operate on this data.

### Conclusion:

**NO, I did not find Data Class.**

The class `MinMaxPriorityQueue` is not primarily a data holder; it encapsulates the data and provides a substantial amount of behavior necessary for functioning as a priority queue."
MapDeserializer.java,"### Analysis of `MapDeserializer` for Data Class Code Smell

#### 1. Fields:
- **Observation:** The `MapDeserializer` class does not define any fields of its own other than a public static instance of itself, `instance`.
- **Conclusion:** There are no additional fields in the class.

#### 2. Accessors:
- **Observation:** There are no getter or setter methods defined for the fields (none other than `instance`).
- **Conclusion:** No pattern of simple getter and setter methods.

#### 3. Methods and Behavior:
- **Observation:** The class has several methods (`deserialze`, `createMap`, `parseMap`, `getFastMatchToken`) that perform substantial work. Methods involve parsing, error handling, map creation, and deserialization tasks.
- **Conclusion:** There are multiple methods that perform meaningful operations, not just getters/setters.

#### 4. Encapsulation:
- **Observation:** The class mainly interacts with other components through methods rather than exposing its data directly. It manipulates and uses parser contexts, maps, and other objects primarily through method calls.
- **Conclusion:** The class uses encapsulation effectively by hiding its operations behind method calls rather than exposing its data.

#### 5. Local Symptom Summary:
- **Observation:** The `MapDeserializer` class primarily involves parsing and deserializing map data structures with substantial business logic rather than just holding data.
- **Conclusion:** It does not exhibit the characteristics of a Data Class due to the presence of significant behavior, not minimal real behavior.

### Final Answer:
NO, I did not find Data Class.  
**Justification:** The class contains several methods that perform substantive logic such as parsing, error handling, and creating map types, indicating that it is not merely a data holder but also performs complex operations."
ConversionException.java,"NO, I did not find Data Class.

The provided class, `ConversionException`, is a subclass of `Exception`. It primarily serves to encapsulate exceptions related to conversion errors and provides constructors to set either a message, a cause, or both. There are no data fields and thus no getters or setters. The class does not exhibit the symptoms of a Data Class, as it is focused on exception handling rather than holding and managing data."
Profiler.java,"Let's analyze the provided Java file step by step to identify signs of the ""Data Class"" code smell.

### Step 1: Fields
The class `RequestInformation` defines several fields:
- `private final String method;`
- `private final String baseUrl;`
- `private final String relativePath;`
- `private final long contentLength;`
- `private final String contentType;`

These fields are encapsulated with private final access modifiers. However, this does not yet indicate a Data Class, as these could be part of a well-encapsulated class.

### Step 2: Accessors
The class `RequestInformation` provides getter methods for all of its fields:
- `getMethod()`
- `getBaseUrl()`
- `getRelativePath()`
- `getContentLength()`
- `getContentType()`

There are no setter methods provided, which contributes to the idea that this is not a mutable DTO but rather a data class focused on read-only access.

### Step 3: Methods and Behavior
The only methods in the `RequestInformation` class are the constructor and the aforementioned getters. There are no methods that perform substantive work such as calculations or business logic.

### Step 4: Encapsulation
The class hides its fields behind private access modifiers but exposes them through getter methods. This follows the principle of encapsulation and data hiding, which is generally considered a good practice. However, the lack of any real logic or behavior suggests this is more of a data carrier than a functional class.

### Step 5: Local Symptom Summary
Based on the patterns observed:
- The class `RequestInformation` primarily holds data.
- Exposes its data through getter methods.
- Contains no substantive methods doing substantial work.
- Fields are encapsulated but exposed via getters.

This class shows all the signs of a Data Class, primarily functioning as a container for data with minimal functionality.

### Final Answer
YES, I found Data Class
The clearest evidence is ""almost all methods are getters, and there are no substantive methods,"" indicating that the class is primarily a data holder."
ParentRunnerTest.java,"NO, I did not find Data Class. 

This file primarily consists of test methods and classes designed to test the behavior of JUnit's `ParentRunner` class and related functionality. It includes multiple test cases (`@Test` annotated methods), nested test classes, setup methods (`@BeforeClass`), and uses various JUnit features like `Request`, `Result`, and `RunListener` for test execution and reporting. 

The `ParentRunnerTest` class itself does not primarily serve as a data holder. It encapsulates the behavior of the tests rather than just holding data. While it does include a static field `log` and a nested `CountingRunListener` class with many fields, these are used within the context of testing and not merely to hold data without behavior. Overall, the primary focus is on testing the functionality of the JUnit framework components."
NumberTest.java,"NO, I did not find Data Class.

### Explanation:

1. **Fields:**
   - The file does define several fields, such as `RANDOMIZATION_QUALITY_RANGE_END`, `RANDOMIZATION_QUALITY_RANGE_START`, `RANDOMIZATION_QUALITY_RANGE_STEP`, `RANDOMIZATION_TESTS_MAX_NUMBERS_TO_GET`, `individualRunGtPercentUnique`, and `percentRunsGtUniquePercentage`. However, these fields are constants and not instance variables used to hold data for instances of the class. Most fields are static and final, indicating they are meant for configuration or constants rather than as data storage for instances.

2. **Accessors:**
   - The class does not have any getter or setter methods for its fields, as it is a test class. It does not hold any data that requires getters and setters.

3. **Methods and Behavior:**
   - The methods in the class are primarily test methods. They call various functions from the `Faker` library to generate random numbers and validate the outputs. There are no methods that perform substantive business logic or calculations beyond the context of the tests.

4. **Encapsulation:**
   - Since this is a test class, the primary usage of its fields and methods is for testing, not for holding and managing data. Therefore, the focus is not on encapsulating data but on validating functionality and quality of the `Faker` library's random number generation.

5. **Local Symptom Summary:**
   - The file does not exhibit signs of a Data Class because it does not hold data in a typical object-oriented sense. It is a test class with constants and methods that perform testing rather than holding and managing data.

Given these points, the file does not exhibit the symptoms of a Data Class. It is clearly a test class with the main purpose of testing the functionalities and behaviors of the `Faker` library related to number generation."
TextEditorUtils.java,"NO, I did not find Data Class.

**Explanation:**
- **Fields**: The file defines a class `TextEditorUtils` with a single static field `ACTION_TRANSLATE_MAP` and a static logger `log`. This is not indicative of a Data Class as it has a limited number of fields.
- **Accessors**: There is only one public method that acts as a getter for `ACTION_TRANSLATE_MAP`. There are no public fields and no excessive number of getter/setter methods.
- **Methods and Behavior**: The class contains several methods that perform substantive work, such as `enableHostEditorKeyBindings`, `enableHostEditorKeyBindingsSupport`, `createFindReplaceAction`, and `isDarkThemeEnabled`. These methods deal with UI manipulation, reflection, and theme management, which are not typical of a Data Class.
- **Encapsulation**: The class encapsulates its data by keeping the field `ACTION_TRANSLATE_MAP` private and providing a public getter method. It also hides its operations behind meaningful services.
- **Local Symptom Summary**: The class is more of a utility class with functions that perform specific operations rather than being primarily a data holder. There are no excessive getters/setters, and the fields are not excessively exposed."
PageResult.java,"Let's analyze the Java class `PageResult` for symptoms of the ""Data Class"" code smell step by step based on the provided criteria:

1. **Fields:**
   - The class defines several fields: `page`, `pageSize`, `totalPage`, and `total`. These fields are private.

2. **Accessors:**
   - There is a pattern where the class has many simple getter and setter methods for each of its fields. Most of its public methods are indeed accessors.

3. **Methods and Behavior:**
   - There are a few methods that do more than just get or set fields. However, the methods `isFirst()` and `isLast()` are fairly simple and only perform checks based on current field values.

4. **Encapsulation:**
   - While the fields themselves are private, the class exposes them through numerous getters and setters. This exposure is extensive, showing more data exposure than encapsulation.

5. **Local Symptom Summary:**
   - The class is primarily defined by its fields with an abundance of getters and setters. It contains only minimal real behavior, with the added methods (`isFirst()` and `isLast()`) not being very substantial.

Based on the above analysis:

**YES, I found Data Class.** The clearest evidence is that almost all methods are getters/setters, with very little behavioral logic beyond those methods."
HikariPool.java,"Let's analyze the provided Java file for symptoms of the ""Data Class"" code smell, as defined by your criteria.

1. **Fields:**
   - The class `HikariPool` has several fields that store configuration, connection handling, scheduling, and other operational state information like `connectionBag`, `suspendResumeLock`, `houseKeepingExecutorService`, and many others.
   - These fields are not public but are accessible or modifiable through various methods.

2. **Accessors:**
   - While there are getter methods like `getActiveConnections`, `getIdleConnections`, `getTotalConnections`, and `getThreadsAwaitingConnection`, these methods are not simple straightforward accessors; they involve internal logic to compute the values.
   - There are no direct public setter methods visible in the provided code.

3. **Methods and Behavior:**
   - The class contains many methods that perform significant work, such as managing connections, handling eviction, logging pool state, and dealing with thread management tasks.
   - Methods like `getConnection`, `shutdown`, `evictConnection`, and `fillPool` contain substantial logic beyond simply setting or getting a field's value.

4. **Encapsulation:**
   - The class encapsulates its data well, with the majority of fields being private or package-private.
   - It exposes a well-defined interface through methods for interacting with the pool, such as connection management and state retrieval, rather than directly exposing fields or simple getters.

5. **Local Symptom Summary:**
   - The class is not a data holder with minimal real behavior. It has numerous fields but uses them in complex operations to manage a connection pool. The methods provided are not primarily accessors but perform extensive logic and operations.

**Conclusion:**
NO, I did not find Data Class.
The `HikariPool` class is primarily focused on managing a connection pool with significant behavior and logic for handling connections, scheduling, and pool state management. It does not fit the profile of a Data Class as described, given the substantial and meaningful behavior in its methods."
SMSParsedResult.java,"Let's analyze the provided Java file step by step:

1. **Fields:**
   - The class defines several fields: `numbers`, `vias`, `subject`, and `body`.
   - These fields are private, which is a good sign for encapsulation, but they do have getter methods, which is indicate that they're accessible indirectly.

2. **Accessors:**
   - There are getter methods for each of the fields (`getNumbers`, `getVias`, `getSubject`, `getBody`).
   - The class has no setter methods for these fields, which suggests that the class is immutable or does not provide mechanisms to modify these fields after the object has been constructed.

3. **Methods and Behavior:**
   - The class has methods that do substantive work, like `getSMSURI` and `getDisplayResult`.
   - These methods include logic to construct URI strings based on internal state, which indicates a level of behavior beyond just holding and providing access to data.

4. **Encapsulation:**
   - The class encapsulates its data well by keeping the fields private and providing public methods to access them.
   - It provides meaningful methods (`getSMSURI`, `getDisplayResult`) that perform operations using the internal data, indicating more than just a simple data holder.

5. **Local Symptom Summary:**
   - While the class has multiple fields and getter methods, it also includes methods that perform meaningful behavior with its data.
   - The presence of methods like `getSMSURI` and `getDisplayResult` suggests that the class is as much about manipulating its data to produce useful results as it is about merely holding data.

Based on the provided code, there are signs of a Data Class (multiple fields and getters), but the substantial methods like `getSMSURI` and `getDisplayResult` indicate that the class does more than just hold data.

Therefore, **NO, I did not find Data Class**. Despite having multiple fields and getters, the class includes substantial methods that perform operations on the data it holds."
AnnotationScanner.java,"NO, I did not find Data Class.

The provided code is an interface named `AnnotationScanner`, not a class. Interfaces typically define a contract for behavior, not hold data. In this interface, there are no fields defined, and the methods `getScanAnnotation()`, `addListener()`, and `validate()` represent behavior rather than data accessors. Therefore, there are no symptoms of a Data Class present in this file."
easyexcel-2.2.11_ExcelDataConvertException.java,"### Analysis of `ExcelDataConvertException` for Data Class Code Smell:

1. **Fields:**
   - The class defines several fields (`rowIndex`, `columnIndex`, `cellData`, `excelContentProperty`).
   - The fields are private, not public or package-private, which is a good sign against the Data Class smell since it suggests some encapsulation.

2. **Accessors:**
   - The class has getter and setter methods for all its fields.
   - Most public methods are indeed simple getters and setters.

3. **Methods and Behavior:**
   - There are no methods that perform substantive work or business logic.
   - All public methods are related to getting or setting fields.

4. **Encapsulation:**
   - The class uses private fields with public getters and setters, which adheres to good encapsulation practices.
   - The data is not directly exposed; it is hidden behind accessors, which is contrary to the Data Class smell.

5. **Local Symptom Summary:**
   - The class is primarily a placeholder for data with getters and setters for its fields.
   - However, the usage of private fields and accessors suggests that it is attempting to follow encapsulation principles, which is a significant mitigating factor against the Data Class smell.

### Conclusion:
While the class does have patterns typical of a Data Class (many getters and setters, few to no substantive methods), it also employs private fields with public accessors, which is a healthy practice for encapsulation. Therefore, it is not a clear-cut Data Class.

**NO, I did not find Data Class.**  
*Reason:* Although the class has many getters and setters and no other methods, it uses encapsulation through private fields, which mitigates the Data Class smell."
Connection.java,"Let's analyze the provided Java file `Connection` step by step based on the criteria for the ""Data Class"" code smell.

### 1. Fields:
The class defines several fields, mostly private, which includes socket connections, streams, and configurations:
- `private static final byte[][] EMPTY_ARGS`
- `private boolean socketParamModified`
- `private JedisSocketFactory socketFactory`
- `private Socket socket`
- `private RedisOutputStream outputStream`
- `private RedisInputStream inputStream`
- `private int soTimeout`
- `private int infiniteSoTimeout`
- `private boolean broken`

### 2. Accessors:
The class has several getter and setter methods for accessing these fields, such as:
- `getSocket()`
- `getSoTimeout()`
- `setSoTimeout(int)`
- `setInfiniteSoTimeout(int)`
- `setHost(String)`
- `getPort()`

### 3. Methods and Behavior:
The class includes several methods that do substantive work, like connecting to a socket, sending commands, reading responses, and handling errors:
- `connect()`
- `disconnect()`
- `sendCommand(ProtocolCommand cmd, String... args)`
- `getStatusCodeReply()`
- `getBulkReply()`
- `getBinaryBulkReply()`
- `getIntegerReply()`
- `getMultiBulkReply()`
- `getBinaryMultiBulkReply()`
- `getStringReply()`
- `isBroken()`
- `flush()`
- `readProtocolWithCheckingBroken()`
- `getMany(int count)`

### 4. Encapsulation:
The class mostly keeps its data encapsulated and provides meaningful services. For example, instead of directly accessing the socket, the class provides methods like `getSoTimeout()`, `sendCommand()`, etc., to interact with the socket.

### 5. Local Symptom Summary:
While the class does have several fields and getter/setter methods, it also contains a significant number of methods that perform substantive operations on the data (like `sendCommand`, `getStatusCodeReply`, etc.), which indicates that it is not purely a data holder.

**Conclusion:**
Based on this analysis, the class does not exhibit strong symptoms of a Data Class as it includes a significant amount of behavior that goes beyond simple data manipulation.

**Answer:**
NO, I did not find Data Class. The class contains substantial methods that perform meaningful operations rather than just data manipulation through getters/setters."
CameraInputController.java,"### Step-by-Step Analysis

1. **Fields:**  
   The class `CameraInputController` defines numerous fields, including public ones (e.g., `rotateButton`, `rotateAngle`, `translateButton`, `translateUnits`, etc.) as well as protected ones (e.g., `activatePressed`).

2. **Accessors:**  
   The class does not explicitly define numerous getter and setter methods for its fields. Instead, fields are directly accessed and modified, which is another sign of exposing data directly.

3. **Methods and Behavior:**  
   While the class contains methods that perform substantive work, such as methods related to camera control (e.g., `update()`, `touchDragged()`, `zoom()`, `process()`), these methods are not numerous. The majority of the methods appear to handle input and update the camera state rather than being purely getters/setters.

4. **Encapsulation:**  
   The class exposes its data through direct field access (e.g., `rotateButton`, `rotateAngle`) and some protected fields, which can be accessed and modified from subclasses. The class also includes methods that perform significant functionality, suggesting it does more than just hold data.

5. **Local Symptom Summary:**  
   Although the class has many fields and includes direct access to them, the methods in the class do perform substantial work related to camera control, input processing, and state updates. This reduces the smell of being purely a data holder.

### Conclusion
**NO, I did not find Data Class.**  
While `CameraInputController` contains many fields and some direct field access, it also includes several methods that perform meaningful operations such as handling input, updating the camera, and managing state. These methods indicate that the class carries out significant behavior, reducing the likelihood of it being solely a data class."
WebLogAspect.java,"NO, I did not find Data Class.

**Explanation:**

1. **Fields:** The file does not define a class with several fields. Instead, it defines a class `WebLogAspect` that serves as an AOP (Aspect-Oriented Programming) aspect for logging HTTP requests and responses.

2. **Accessors:** There are no simple getter and/or setter methods in `WebLogAspect`. The methods are primarily related to logging and do not act as accessors for fields.

3. **Methods and Behavior:** The class includes methods that perform substantive work, such as logging HTTP request details, processing method parameters, and handling around advice for method execution.

4. **Encapsulation:** The class does not tend to expose its data much since it focuses on cross-cutting concerns like logging rather than managing data state.

5. **Local Symptom Summary:** The class is not a primary data holder with minimal real behavior. Instead, it is an aspect that encapsulates behavior relevant to logging HTTP interactions."
ComparisonCriteria.java,"No, I did not find Data Class.

While the `ComparisonCriteria` class does not have many fields, there are several methods that perform substantive work, such as comparing arrays and handling exceptions, which indicates that it contains meaningful behavior beyond just holding and exposing data. The class has a mix of public methods (`arrayEquals`) and private helper methods that perform important operations, and it also includes an abstract method (`assertElementsEqual`) that is intended to be implemented by subclasses to perform specific comparison logic. Thus, it does not primarily serve as a data holder with minimal behavior, which is contrary to the characteristics of a Data Class."
CodeCacheEventWalker.java,"### Step-by-Step Analysis:

1. **Fields:**
   - The class `CodeCacheEventWalker` defines the following fields: 
     - `CodeCacheWalkerResult result`: Private field.
     - `Logger logger`: Static final private field.
   - There are not several fields defined, and they are not exposed as public or package-private.

2. **Accessors:**
   - The class has one getter method: `getResult()`.
   - It does not have multiple simple getters or setters; only one.

3. **Methods and Behavior:**
   - The class has a constructor `CodeCacheEventWalker(IReadOnlyJITDataModel model)` and an overridden `reset()` method.
   - The main logic is in the overridden `visit(IMetaMember metaMember)` method, which involves parsing, error handling, and adding `CodeCacheEvent` to its result.
   - There are methods performing substantive work.

4. **Encapsulation:**
   - The class encapsulates its data by using a private field for `result` and providing a getter method for it.
   - It does not expose internal state or functionalities through many getters/setters.

5. **Local Symptom Summary:**
   - The class contains methods that perform significant logic (`visit(IMetaMember metaMember)` being the main one) rather than just being a shell for data.
   - There are no multiple accessors, and it doesn't exhibit the typical pattern of a Data Class.

### Conclusion:

**NO, I did not find Data Class**

The main sign that this is not a Data Class is the presence of meaningful methods that perform substance operations rather than simply getting or setting fields."
Dictionary.java,"Let's analyze the provided Java file for symptoms of the ""Data Class"" code smell:

1. **Fields**:  
   - The class `Dictionary` defines several fields such as `_MainDict`, `_QuantifierDict`, `_StopWords`, `configuration`, and others. These fields hold the state of the dictionary and its components. However, they are private, not public or package-private. There are no direct field accesses.

2. **Accessors**:  
   - There are no simple getter or setter methods for the fields. Instead, the class provides methods to load and manipulate its internal data structures.

3. **Methods and Behavior**:  
   - The class has several methods that perform substantive work, such as `initial`, `loadDictFile`, `loadMainDict`, `loadStopWordDict`, `loadQuantifierDict`, `matchInMainDict`, `matchInQuantifierDict`, `isStopWord`, and many more. These methods are involved in loading, managing, and querying the dictionary data.

4. **Encapsulation**:  
   - The fields of the class are private and encapsulated, with methods provided for loading the dictionary and querying it. The data is not exposed directly; only through methods that implement business logic.

5. **Local Symptom Summary**:  
   - The class does not look like a primary data holder with minimal real behavior. There are methods that perform significant tasks such as loading dictionaries, matching words, and more.

**Conclusion:**
NO, I did not find Data Class. Based on the analysis, the class contains methods that implement meaningful behavior, handles the loading and querying of dictionary data, and encapsulates its data fields properly."
SmartContentSelector.java,"NO, I did not find Data Class.

**Explanation:**

1. **Fields:** The file does define some fields (`blocksWidth`, `threshold`, `start`, `end`, `text`, `indexDistribution`), but they are all local to the `select` method and not class-level attributes.

2. **Accessors:** There are no getter or setter methods defined in the class.

3. **Methods and Behavior:** The class has only two methods: `select` and `selectList`. The `select` method contains substantive business logic, not just getting or setting fields.
   
4. **Encapsulation:** The class encapsulates its functionality within the `select` method. There are no public fields, and the class doesn't expose any unnecessary data or operations.

5. **Local Symptom Summary:** The class does not primarily serve as a data holder. It includes a method (`select`) that performs significant data processing and manipulation, which does not align with the characteristics of a Data Class."
Faker.java,"Let's analyze the provided Java file to determine if it exhibits symptoms of the ""Data Class"" code smell.

1. **Fields:**
   - The class `Faker` defines many fields, mostly objects of different types such as `Ancient`, `App`, `Artist`, etc. These fields are not exposed directly (they are private), but there are getter methods for each of them.

2. **Accessors:**
   - There is a significant number of methods that are simple getter methods, one for each field. For example, `ancient()`, `app()`, `artist()`, etc. These methods do nothing but return the corresponding field.

3. **Methods and Behavior:**
   - While there are many getter methods, there are also some methods that perform substantive work such as `numerify`, `letterify`, `bothify`, `regexify`, `resolve`, and `expression`. These methods are not just simple accessors and seem to be responsible for generating fake data.

4. **Encapsulation:**
   - The class encapsulates its data fields quite well by keeping them private. Public access to these fields is only through getter methods.

5. **Local Symptom Summary:**
   - Despite having many getter methods, the class also includes methods that perform meaningful tasks related to generating fake data, which is one of its main purposes.

**Conclusion:**
Based on the analysis, although the class has many getter methods, it also contains several methods that perform substantive tasks, which is not typical of a Data Class. Therefore, it does not clearly fit the profile of a Data Class solely based on these criteria.

**Answer:**
NO, I did not find Data Class. While the class has many getter methods, it also includes methods that perform significant operations related to generating fake data."
ConstructorConstructor.java,"NO, I did not find Data Class.

### Analysis:

1. **Fields**:
   - The class has fields such as `instanceCreators` and `accessor`. However, these fields are not exposed publicly or through simple getters/setters. They are safeguarded and used internally.

2. **Accessors**:
   - There are no getter or setter methods for the fields. The field `instanceCreators` is only accessed in the constructor and one method, `get`.

3. **Methods and Behavior**:
   - The class contains several methods that perform substantive work: `get`, `newDefaultConstructor`, `newDefaultImplementationConstructor`, and `newUnsafeAllocator`. These methods are not just simple accessors but implement significant logic for constructing objects.

4. **Encapsulation**:
   - The class encapsulates its data effectively, with fields being private and methods providing specific behaviors based on the type and raw type provided.

5. **Local Symptom Summary**:
   - The class is not primarily a data holder. It contains substantial behavior in the form of creating object constructors based on given types, which is not characteristic of a Data Class."
StatisticSlot.java,"**NO, I did not find Data Class.**

### Explanation:

1. **Fields:**  
   The `StatisticSlot` class does not define several fields. It primarily extends `AbstractLinkedProcessorSlot<DefaultNode>` and relies on fields from its parent class or other classes like `Node`, `Context`, etc. There are no fields defined specifically in this class that are public or package-private.

2. **Accessors:**  
   The class does not have many simple getter and/or setter methods. It consists mainly of method implementations for `entry`, `exit`, and `recordCompleteFor`. There are no accessor methods for fields within this class.

3. **Methods and Behavior:**  
   The class contains significant methods that perform substantive work such as handling entry and exit, calculating response time, updating statistics, and handling exceptions. The methods are not just simple accessors.

4. **Encapsulation:**  
   The class is well-encapsulated, hiding its internal data and operations behind meaningful methods like `entry` and `exit`. It uses helper methods like `recordCompleteFor` to manage statistics, indicating that it provides meaningful services.

5. **Local Symptom Summary:**  
   The `StatisticSlot` class does not serve as a data holder with minimal real behavior. It actively participates in processing logic, handling statistics, and managing exceptions, which are indicative of behavior rather than just data storage."
HttpConnection.java,"### Analysis of `HttpConnection` for Data Class Symptoms:

1. **Fields:**
   - The class defines several fields such as `private HttpConnection.Request req` and `private @Nullable Connection.Response res`. However, these fields are not exposed directly or through simple getters/setters. Instead, they are typically modified through method calls that perform additional operations or validation.

2. **Accessors:**
   - The class does have a number of methods that act as getters and setters (e.g., `timeout(int millis)`, `userAgent(String userAgent)`, `cookie(String name, String value)`). However, these methods often include validation or additional logic (e.g., `Validate.notNull` checks).

3. **Methods and Behavior:**
   - There are methods that perform significant work, such as `execute()`, `get()`, `post()`, and numerous other methods that handle HTTP requests, responses, and parsing. These methods implement important behavior that goes beyond simple data storage and retrieval.

4. **Encapsulation:**
   - The class encapsulates a significant amount of data within its fields and provides methods to manipulate and interact with this data. While it uses some getter/setter methods, they are typically part of a larger data manipulation and behavior layer.

5. **Local Symptom Summary:**
   - The class is not primarily a data holder with minimal real behavior. It includes significant behavior related to HTTP requests, responses, parsing, and validation, which go beyond simply managing fields.

**Conclusion:**

- **Answer:** `NO, I did not find Data Class`.
- **Main Evidence:** The class includes numerous methods that perform substantial behavior such as executing HTTP requests, handling responses, and parsing data, which are not simple getters or setters."
FireBirdMetaModel.java,"### Analysis of the Java File for ""Data Class"" Code Smell

**1. Fields:**
The `FireBirdMetaModel` class does not explicitly declare many fields. The only field it has is a private static final integer `OBJECT_NAME_LENGTH` and a private Pattern `ERROR_POSITION_PATTERN`. There are no public or package-private fields, nor a multitude of fields.

**2. Accessors:**
The file does not contain simple getter and setter methods. There aren't any methods whose primary purpose is merely to get or set field values.

**3. Methods and Behavior:**
The class contains several methods, most of which override methods from a superclass (`GenericMetaModel`) and implement specific behaviors related to handling Firebird database metadata. These methods perform substantive work such as database interactions, data loading, and SQL statement preparation. They are not merely accessors.

**4. Encapsulation:**
The class encapsulates its data by performing operations within its methods, and it does not expose its data directly. It relies on method overriding to extend the functionality of its superclass.

**5. Local Symptom Summary:**
Based on the observations above, the class does not look like a primary data holder with minimal real behavior. It performs several substantive operations related to the handling of database metadata operations. The presence of few fields and the absence of simple accessors further support the idea that this class is responsible for more than just holding data.

### Conclusion:
NO, I did not find Data Class.

The class `FireBirdMetaModel` has behaviors that go beyond merely holding data, including database operations and specific implementations related to Firebird databases."
PendingEntry.java,"### Analysis of `PendingEntry` Class

1. **Fields:**
   - The class defines several fields: `StreamMessageId id`, `String consumerName`, `long idleTime`, `long lastTimeDelivered`.
   - These fields are private, which is a good sign of encapsulation but not directly pointing to a Data Class.

2. **Accessors:**
   - The class has four public getter methods: `getId()`, `getConsumerName()`, `getIdleTime()`, `getLastTimeDelivered()`.
   - There are no setter methods, which is different from a typical Data Class that often has both getters and setters.

3. **Methods and Behavior:**
   - The class has a constructor and four getter methods.
   - No additional methods that perform substantive or meaningful work or business logic are present.

4. **Encapsulation:**
   - The fields are private, which means the class hides its internal state behind the provided getter methods.
   - There's no evidence of over-exposure of its data as most of it is hidden by the absence of setters and direct access.

5. **Local Symptom Summary:**
   - The class appears to be primarily a data holder with minimal real behavior, as most of its methods are simple getters.
   - However, the lack of setters and presence of a constructor reduce the strong indication of a Data Class.

### Conclusion
**NO, I did not find Data Class.**  
While the class has many simple getters, it is missing the typical presence of setters, and it includes a constructor, which weakens the indication of it being primarily a data holder without meaningful behavior."
Location.java,"Let's analyze the given Java file according to the specified criteria for the ""Data Class"" code smell:

1. **Fields:**  
The `Location` class and its subclasses contain multiple fields, such as `insnNode`, `whenComplete`, and `stackNeedSave`. Some fields are protected, private, or package-private, while others have getter and setter methods. However, not all fields are directly exposed or have both getter and setter methods.

2. **Accessors:**  
There are a few getter methods like `getInsnNode()`, `isWhenComplete()`, `isStackNeedSave()`, and `canChangeByReturn()`. There are also setter methods like `setCount()`. Most of the public methods are basic getters and setters, but they are not overwhelming in number compared to the overall methods.

3. **Methods and Behavior:**  
While there are some methods devoted to getting or setting fields, there are also methods that perform meaningful tasks, such as `canChangeByReturn()`, `getStackSaver()`, `getLocationType()`, and implementations in nested classes like `InvokeLocation`. These methods show that the class performs substantive work.

4. **Encapsulation:**  
The `Location` class and some nested classes use a mix of private, protected, and public fields and methods. Accessors are provided for some fields, promoting encapsulation. However, the `Generate` class still exposes some details through methods.

5. **Local Symptom Summary:**  
The class does contain several fields and many getter/setter methods, but it also has several methods that perform substantive work and provide meaningful behavior, which reduces the likelihood of it being a classic data class.

**Conclusion:**  
Based on the analysis, while the class has some symptoms of a Data Class (presence of multiple fields and getter/setter methods), it also exhibits behaviors that are not typical of a Data Class due to the presence of meaningful methods. Thus, the file does not strongly indicate a Data Class smell.

**Answer:**  
NO, I did not find Data Class. The class contains significant methods that perform substantive work, not just getters/setters."
Evaluator.java,"Let's analyze the provided Java file step by step based on the criteria for identifying a Data Class.

1. **Fields**:
   - The file defines several static nested classes (`Tag`, `TagEndsWith`, `Id`, `Class`, etc.), each holding a single private field. 

2. **Accessors**:
   - Each static nested class has a constructor to initialize its field(s) and a `matches` method which is not a simple getter/setter.
   - There are no separate getter or setter methods for these fields as they are being accessed directly within the `matches` methods.

3. **Methods and Behavior**:
   - The main methods in each class perform specific evaluations on `Element` objects, which involves business logic related to matching elements with specific criteria. 
   - There are very few methods (only constructors and `matches`) and these methods are not simple accessors but rather perform specific tasks.

4. **Encapsulation**:
   - The fields in each nested class are private, indicating good encapsulation. There are no public fields or excessive getters/setters that would suggest exposing internal data.

5. **Local Symptom Summary**:
   - The classes are primarily focused on implementing specific evaluation logic through the `matches` method rather than simply holding data.

Based on the above analysis:

**NO, I did not find Data Class.**

The classes defined in this file are not primarily data holders; they encapsulate behavior related to evaluating elements against specific criteria using the `matches` method."
JsonAdapterAnnotationTypeAdapterFactory.java,"NO, I did not find Data Class.

**Reasoning:**

1. **Fields:** The class `JsonAdapterAnnotationTypeAdapterFactory` has only one field, `constructorConstructor`, which is not public or package-private, and it is accessed and utilized in meaningful methods.

2. **Accessors:** There are no getter or setter methods for the field `constructorConstructor`. The constructor is the only way to set this field, and it is not exposed through any method.

3. **Methods and Behavior:** The class contains methods that do substantive work, such as creating a type adapter based on the `JsonAdapter` annotation, which involves checking the type of the adapter, instantiating it, and handling exceptions if the instance is not of the expected types. These are not simple accessor methods.

4. **Encapsulation:** The field `constructorConstructor` is properly encapsulated and is not directly accessible from outside the class. The class provides a method `create` that is a part of the `TypeAdapterFactory` interface, which is responsible for creating type adapters.

5. **Local Symptom Summary:** The class is focused on implementing the `TypeAdapterFactory` interface and is not primarily a data holder. It contains logic for determining and creating type adapters based on the `JsonAdapter` annotation, which is more than just holding and exposing data."
DriverDataSource.java,"Let's analyze the class `DriverDataSource` for symptoms of the Data Class code smell.

1. **Fields:**
   - The class defines several fields: `jdbcUrl`, `driverProperties`, and `driver`. These fields are all private, showing some level of encapsulation.

2. **Accessors:**
   - The class does not have any public getter or setter methods for its fields. Instead, it has methods like `getConnection()`, which perform actions using these fields.

3. **Methods and Behavior:**
   - The class has very few methods that are simply getters or setters. The main methods include `getConnection()` that returns a connection using the stored driver and properties. Other methods either throw `SQLFeatureNotSupportedException` or use the `DriverManager`, indicating substantive behavior related to database operations.

4. **Encapsulation:**
   - The class encapsulates its fields `jdbcUrl`, `driverProperties`, and `driver` and provides methods to interact with these fields in a meaningful way rather than directly exposing them.

5. **Local Symptom Summary:**
   - Based on the analysis, the class does not primarily serve as a data holder with minimal real behavior. It has meaningful methods that perform operations related to database connections, and it does not expose its data through simple getters/setters.

**Conclusion:**
NO, I did not find Data Class. The main sign is that the class has substantive methods related to database operations (`getConnection`) rather than being primarily a data holder with minimal real behavior."
AbstractMetaMember.java,"1. **Fields:**
   - The class `AbstractMetaMember` defines several fields such as `metaClass`, `compilations`, `selectedCompilationIndex`, `isCompiled`, `isVarArgs`, `isPolymorphicSignature`, `modifier`, `memberName`, `returnType`, and `paramTypes`. These fields are not public, but they do have corresponding getter and setter methods which suggest potential exposure of data.

2. **Accessors:**
   - There are numerous getter methods such as `getMemberName()`, `getFullyQualifiedMemberName()`, `getModifier()`, `getModifierString()`, `getReturnTypeName()`, `getParamTypeNames()`, `getMetaClass()`, `getQueuedAttribute(String key)`, `getCompiledAttribute(String key)`, `getCompilationByCompileID(String compileID)`, `getCompilationByAddress(AssemblyMethod asmMethod)`, `isCompiled()`, `getQueuedAttributes()`, `getCompiledAttributes()`, `toStringUnqualifiedMethodName(boolean visibilityAndReturnType, boolean fqParamTypes)`, `getSourceMethodSignatureRegEx()`, `isConstructor()`, `getLastCompilation()`, `getCompilation(int index)`, `getSelectedCompilation()`, and `compareTo(IMetaMember other)`. There are also setter methods like `setCompiled(boolean compiled)` and `setSelectedCompilation(int index)` among other methods which primarily deal with data retrieval and manipulation.

3. **Methods and Behavior:**
   - While there are methods like `checkPolymorphicSignature(Method method)`, `matchesSignature(MemberSignatureParts msp, boolean matchTypesExactly)`, `getClassesForParamTypes(MemberSignatureParts msp)`, `getMemberBytecode()`, `getInstructions()`, `storeCompilation(Compilation compilation)`, `addAssembly(AssemblyMethod asmMethod)`, `getCompilations()`, `expandParam(String inParamType, boolean fullyQualifiedType)`, `expandParamRegEx(String inParamType)`, `makeSafeIndex(int index)`, many of the methods are indeed acting as accessors for the class’s fields. They seem to perform some specific tasks related to the data they hold, but the majority of the methods simply manage and return data.

4. **Encapsulation:**
   - The class encapsulates its data behind methods for access and modification, but a significant portion of these methods are straightforward getters and setters. The class does provide some meaningful behavior through methods such as `matchesSignature(MemberSignatureParts msp, boolean matchTypesExactly)`, but these methods are relatively few compared to the total number of methods in the class.

5. **Local Symptom Summary:**
   - The class looks like it is primarily a data holder with minimal real behavior. Most of the methods are indeed getters and setters, and the methods that do perform calculations or business logic are limited in number and scope.

**Answer:**
YES, I found Data Class. The main sign is that almost all methods are getters/setters, with very little substantive behavior beyond data manipulation."
ParentRunner.java,"### Analysis of the `ParentRunner` Class

1. **Fields:**
   - The file defines a class with several fields such as `childrenLock`, `testClass`, `filteredChildren`, and `scheduler`.
   - These fields are not public, but some have getter methods (`getTestClass`, `scheduler` has a setter and getter).

2. **Accessors:**
   - The class has a number of accessor methods, including getters and setters. For example, `getTestClass` is a getter for `testClass`, and `setScheduler` is a setter for `scheduler`. However, these are not simple verbatim accessors; they include some additional logic, such as synchronization.
   - There are several protected methods intended to be overridden by subclasses, which indicate that these methods are not merely simple data accessors.

3. **Methods and Behavior:**
   - The class contains many methods that are not simple data manipulation methods. These methods perform meaningful operations such as filtering children based on a filter, running tests in a specified order, and handling exceptions.
   - Some of the methods are abstract, indicating that subclasses must provide implementations, hinting at the presence of a template design pattern for the test execution process.

4. **Encapsulation:**
   - The class does not expose all its data fields. While it provides access to some through accessors, it encapsulates others, particularly those that involve synchronization or complex logic.
   - The private and protected methods and fields suggest that the class internals are well-encapsulated, focusing on providing a framework rather than just being a data container.

5. **Local Symptom Summary:**
   - While the class defines several fields and includes accessor methods, it also contains a significant number of complex methods that perform substantial work, including test execution, validation, and resource management.
   - The class does not appear to be primarily a data holder as it has many methods that are not simple get/set operations and does meaningful work.

### Conclusion

NO, I did not find Data Class. The class `ParentRunner` includes more than just data storage and access; it has significant behavior and is part of a larger framework designed for test execution, which indicates it is not a data class."
OmsPortalOrderServiceImpl.java,"NO, I did not find Data Class.

### Explanation:
1. **Fields**: The file does not define any field (attribute) within the class `OmsPortalOrderServiceImpl`. Instead, it defines several dependencies through `@Autowired` and lists several methods for order handling.

2. **Accessors**: There are no simple getter or setter methods in this class. The class interacts with other services and DAOs rather than exposing its own fields through getters and setters.

3. **Methods and Behavior**: The class contains numerous methods (`generateConfirmOrder`, `generateOrder`, `paySuccess`, `cancelOrder`, etc.) that implement substantial business logic for managing orders, calculations, payments, and more.

4. **Encapsulation**: The class maintains encapsulation by interacting with other services and mappers rather than exposing its fields.

5. **Local Symptom Summary**: The class does not exhibit characteristics of a Data Class; it is a service implementation class that handles various business operations related to orders, thus it has both methods and interactions that perform meaningful services rather than merely holding and providing data through accessors."
JUnitCommandLineParseResult.java,"Let's analyze the given Java file step by step based on the criteria for the ""Data Class"" code smell.

1. **Fields:**
   - The class defines several fields: `filterSpecs`, `classes`, and `parserErrors`. These fields hold data and are private.

2. **Accessors:**
   - There are simple getters for the fields (`getFilterSpecs` and `getClasses`). No setters are provided. Most public methods are either constructors, parsing-related methods, or utility methods.

3. **Methods and Behavior:**
   - The class contains methods that do substantive work, such as `parse`, `parseOptions`, `copyArray`, `parseParameters`, `createRequest`, and `applyFilterSpecs`. These methods involve parsing logic, error handling, and request creation, which are not merely setting or getting data.

4. **Encapsulation:**
   - While the class exposes its data via getters, it also contains methods that perform significant operations, hiding the data behind meaningful services where necessary. The fields themselves are private, and direct access is restricted.

5. **Local Symptom Summary:**
   - Although the class has fields and getter methods, it has several methods that perform meaningful work. The presence of methods that handle parsing, error management, and request creation indicates that this class does more than just store data.

Based on the analysis, the class does not appear to be primarily a data holder with minimal real behavior. Instead, it contains multiple methods that manage parsing, error reporting, and request creation.

**Final Answer:**
NO, I did not find Data Class. The class contains several methods that perform substantive work beyond just getting or setting fields."
ClassReader.java,"Let's analyze the file step by step based on the criteria provided:

1. **Fields:**
   - The class `ClassReader` has several fields: 
     - `public final byte[] b`
     - `private final int[] items`
     - `private final String[] strings`
     - `private final int maxStringLength`
     - `public final int header`
     - `private boolean readAnnotations`
   - The fields are mostly private or private final except for `b` and `header` which are public. It uses both private fields and has some exposed fields.

2. **Accessors:**
   - The class does not have many simple getter and setter methods. There are no public getter or setter methods provided for any of the fields. This reduces the likelihood of the class being a Data Class based on accessors.

3. **Methods and Behavior:**
   - The class has several methods that perform substantive work, such as `accept`, `getAttributes`, `readMethod`, `readUnsignedShort`, `readInt`, `readUTF8`, and `readUTF`. These methods are not just getters/setters; they parse data, read streams, and manipulate byte arrays and indices.

4. **Encapsulation:**
   - The class is not overly exposed. While `b` and `header` fields are public, most fields are private or package-private, and the class provides substantial functionality to handle and interpret the data in these fields.

5. **Local Symptom Summary:**
   - The class contains significant behavior in the form of data parsing and manipulation. It's not a simple data container; instead, it performs various operations on the data it holds.

**Conclusion:**
After analyzing the file, it does not exhibit strong symptoms of a Data Class. The class has more than just fields and simple accessors; it includes substantial behavior and methods that process and interpret the data.

**Answer:**
NO, I did not find Data Class. The main sign is that the class contains several methods that perform substantive work (e.g., parsing data from byte arrays, reading streams) rather than just getters/setters."
XxlJobExecutor.java,"### Analysis of Symptoms for Data Class Code Smell

1. **Fields:**  
   The class `XxlJobExecutor` defines several fields (attributes) such as `adminAddresses`, `accessToken`, `appname`, `address`, `ip`, `port`, `logPath`, and `logRetentionDays`. These fields are mostly private, which is a good sign. However, there are several corresponding setters for these fields.

2. **Accessors:**  
   There is a pattern of simple setter methods for each field. The class has many setter methods (`setAdminAddresses`, `setAccessToken`, etc.). While there are fewer getter methods, the prevalence of setters indicates a focus on exposing fields.

3. **Methods and Behavior:**  
   The class contains several methods that do substantive work, such as `start()`, `destroy()`, `initAdminBizList()`, `initEmbedServer()`, `stopEmbedServer()`, and others that manage job handlers and threads. This gives the class meaningful behavior beyond just field management.

4. **Encapsulation:**  
   The class does not expose all its data directly. Fields are private, and data is accessed either through setter methods or specific methods designed to handle business operations. This suggests a good level of encapsulation.

5. **Local Symptom Summary:**  
   While the class does have several fields and corresponding setters, it also containsmethods that perform significant tasks related to job execution, administration, and management. The presence of these methods suggests that the class is not just a simple data holder.

### Conclusion:
NO, I did not find Data Class.  
The main sign here is that the class contains several methods that perform meaningful work, not just methods for setting and getting fields. These methods manage server startup and shutdown, handle job threads, and interact with job administration, which goes beyond the functionality of a typical data class."
InPacketHandler.java,"NO, I did not find Data Class.

### Explanation:
1. **Fields**: The class `InPacketHandler` has several private fields (`packetListener`, `decoder`, `namespacesHub`, `exceptionListener`), but these are not exposed through public fields.

2. **Accessors**: There are no getter or setter methods for the fields in this class. All fields are private and only used within the methods of the class.

3. **Methods and Behavior**: The class contains method `channelRead0` which handles incoming messages, and `exceptionCaught` for handling exceptions. These methods perform significant behavior, such as processing packets, handling namespaces, and managing client sessions, which indicates more than just data storage.

4. **Encapsulation**: The class encapsulates its fields and does not expose them through publicly accessible fields or unnecessary getters/setters. Instead, it processes and manipulates data within its methods.

5. **Local Symptom Summary**: The class has fields that it uses within its methods to perform substantive work. It does not have many simple getter/setter methods and does not appear to be primarily a data holder without real behavior."
ConstrainableInputStream.java,"### Analysis of the Java File for Data Class Symptoms

#### 1. Fields:
The class `ConstrainableInputStream` defines several fields:
- `capped`
- `maxSize`
- `startTime`
- `timeout`
- `remaining`
- `interrupted`

These fields include private fields, which indicates encapsulation efforts, but there are many fields being maintained.

#### 2. Accessors:
There are no public getter or setter methods for the class fields. This reduces the likelihood of the class being a straightforward data class through simple accessors.

#### 3. Methods and Behavior:
The class includes several methods that perform substantive work, particularly:
- `read(byte[] b, int off, int len)`
- `readToByteBuffer(int max)`
- `reset()`
- `timeout(long startTimeNanos, long timeoutMillis)`
- `expired()`

These methods handle input stream operations, timeouts, and data reading, which are not mere data management tasks.

#### 4. Encapsulation:
The class uses private fields and methods like `expired()` to manage its internal state, rather than exposing fields directly.

#### 5. Local Symptom Summary:
While the class does have multiple fields and does handle input stream operations and timeouts, the methods involved perform significant work rather than just serving as data getters/setters. The class shows encapsulation and behavior beyond simple data storage, which mitigates the likelihood of it being purely a Data Class.

### Final Answer:
NO, I did not find Data Class.
The primary evidence is that the class contains methods that perform substantive work, such as managing input streams, handling timeouts, and reading data, rather than just being a simple holder of data."
AndroidGL20.java,"### Analysis of the Provided Java File for Data Class Smell

#### Fields:
The class `AndroidGL20` has a few fields (`ints` and `buffer`) that are private. However, it does not define many fields, which is a characteristic of data classes.

#### Accessors:
There are no getter or setter methods defined for the private fields `ints` and `buffer`. Instead, methods interact directly with these fields, but there are no typical accessor patterns.

#### Methods and Behavior:
The class contains numerous methods (`glActiveTexture`, `glAttachShader`, etc.), but these methods are not merely getters and setters; they encapsulate OpenGL functionality. They perform substantive operations relevant to the GL20 interface, not just data manipulation.

#### Encapsulation:
While the class has some private fields, the overall design is encapsulated in terms of providing an interface (`GL20`) for OpenGL operations. The class hides most of its internal state and interacts with the native OpenGL API via `GLES20`.

#### Local Symptom Summary:
The class does not appear to be primarily a data holder with minimal real behavior. It primarily acts as a bridge to the OpenGL ES 2.0 API (`GLES20`), fulfilling the interface `GL20` with substantive methods rather than just data storage and access.

### Conclusion:
**NO, I did not find Data Class**
The class `AndroidGL20` is more of an adapter or facade for OpenGL operations rather than a data class. It contains significant behavioral methods that perform meaningful tasks and interact with external systems (OpenGL), unlike a data class which would mainly consist of data storage with minimal or no behavior."
SaJwtUtil.java,"Let's analyze the provided file step by step:

1. **Fields:**
   - The file does define constants (fields) such as `LOGIN_TYPE`, `LOGIN_ID`, `DEVICE`, `EFF`, and `NEVER_EXPIRE`. These are not fields in the traditional sense (instance variables) but rather static final constants used throughout the class.

2. **Accessors:**
   - There are no fields with simple getters and setters. The class only provides constants and methods for creating and parsing JWT tokens, as well as retrieving specific data from these tokens.

3. **Methods and Behavior:**
   - The class contains several methods that perform substantive work such as creating JWT tokens (`createToken`), parsing them (`parseToken`), and extracting specific information (`getPayloads`, `getLoginId`, etc.). These methods are not merely getting or setting fields but are engaging in token manipulation and validation processes.

4. **Encapsulation:**
   - The class does not expose its data through public fields. Instead, it provides methods that encapsulate operations on JWT tokens, keeping its data (in the form of JWT tokens) protected and accessible only through these methods.

5. **Local Symptom Summary:**
   - Based on the patterns above, the class does not look like a primary data holder with minimal real behavior. It performs a variety of operations related to JWTs, including creation, parsing, and data extraction, and it maintains encapsulation.

**Conclusion:**
- **NO, I did not find Data Class.** The class `SaJwtUtil` has methods that perform meaningful operations related to JWT handling and does not primarily act as a mere data holder with only getters and setters."
Code.java,"Let's analyze the provided `Code` class to determine if it exhibits symptoms of the ""Data Class"" code smell.

1. **Fields**:  
   - The class defines several private fields, but most notably does not expose these fields publicly or through simple getters. The only private field is `private final Faker faker`.

2. **Accessors**:  
   - The class has no simple getters or setters for its fields. The public methods in the class do not pertain to retrieving or setting the values of the fields directly.

3. **Methods and Behavior**:  
   - The class contains several methods that perform实质性 work, implementing logic to generate ISBN numbers, ASINs, IMEIs, and GTINs. These methods include detailed logic and calculations for generating the different codes.

4. **Encapsulation**:  
   - The class hides its data field `faker` by using `private final` access modifier and does not provide any methods for direct access to it. Instead, it uses the `faker` object to generate various codes through a series of methods.

5. **Local Symptom Summary**:  
   - The class primarily consists of methods that generate and return different types of codes, such as ISBNs, ASINs, etc. There are no simple getter/setter methods, and the class does not function as a mere data holder without behavior.

Based on the patterns above, the class does not look like a data holder with minimal real behavior. Instead, it contains multiple methods that perform substantial calculations and logic to generate specific types of codes.

**Answer**: NO, I did not find Data Class."
HomeController.java,"### Analysis of the Java File for ""Data Class"" Code Smell

Let's go through each question step by step:

1. **Fields:**
   - The class defines several fields (attributes): `LOGGER`, `SUCCESS`, `FAIL`, `USER_ID`, `COMMODITY_CODE`, `ORDER_COUNT`, `restTemplate`, `orderService`, and `storageService`.
   - The fields are either private and final (for dependencies and constants) or are private (for constants).
   - There are no public or package-private fields.

2. **Accessors:**
   - The class does not define any getter or setter methods for its fields.
   - It uses constructor injection to initialize its dependencies (`RestTemplate`, `OrderService`, `StorageService`).

3. **Methods and Behavior:**
   - The class has substantive methods: `rest()` and `feign()`.
   - These methods perform business operations involving HTTP requests and service calls, which go beyond simple data manipulation.

4. **Encapsulation:**
   - The class hides its data behind methods. The dependencies and constants are private, and interaction is done through the `rest()` and `feign()` methods, which represent meaningful services.

5. **Local Symptom Summary:**
   - The class does not appear to be a data holder with minimal real behavior.
   - It includes methods that perform business logic and service interactions, rather than acting as a simple container for data.

### Conclusion
**NO, I did not find Data Class.**
- The clearest evidence is that the class contains methods that perform meaningful operations (`rest()` and `feign()`), rather than consisting mostly of fields with simple getters/setters."
NacosWatch.java,"Let's analyze the file step by step to determine if it exhibits symptoms of a Data Class.

### 1. Fields:
The class `NacosWatch` defines several fields, including:
- `listenerMap`
- `running`
- `nacosWatchIndex`
- `publisher`
- `nacosServiceManager`
- `properties`

These fields are holding data crucial for the operation of the class.

### 2. Accessors:
The class has a couple of accessors, specifically:
- `setApplicationEventPublisher(ApplicationEventPublisher publisher)` is a setter method to set the `publisher` field.
- Other methods like `buildKey`, `resetIfNeeded`, and `selectCurrentInstance` are private and not simple getters/setters.

### 3. Methods and Behavior:
The class contains several meaningful methods that perform significant work:
- `start()`: Registers an event listener and subscribes to service changes.
- `stop()`: Unsubscribes from service changes.
- `resetIfNeeded(Instance instance)`: Compares and possibly updates metadata.
- `selectCurrentInstance(List<Instance> instances)`: Filters and retrieves a specific instance.

There are considerable methods that perform business logic, which deviates from being a simple data holder with simple getter/setters.

### 4. Encapsulation:
The class encapsulates its data and provides a higher-level interface (`start`, `stop`, `isRunning`, etc.) to interact with the data. It does not expose its internal data through simple getters/setters but rather through meaningful methods.

### 5. Local Symptom Summary:
Based on the above observations, the class does not appear to be a primary data holder with minimal real behavior. It has several fields that are essential for its functionality and includes numerous methods that implement meaningful services.

### Conclusion:
NO, I did not find Data Class.

The class `NacosWatch` has significant behavior and meaningful methods that perform important operations, thus it does not exhibit the symptoms of a Data Class."
DictSegment.java,"Let's analyze the provided Java file ""DictSegment.java"" for symptoms of the ""Data Class"" code smell step-by-step:

1. **Fields**:
   - The class defines several private fields: `childrenMap`, `childrenArray`, `nodeChar`, `storeSize`, and `nodeState`. There are no public or package-private fields.

2. **Accessors**:
   - The class includes a getter method `getNodeChar()` for the `nodeChar` field.
   - There is no setter method for `nodeChar` provided which is fine. However, this method is one of only a few methods in the class.

3. **Methods and Behavior**:
   - Most of the methods in the class (such as `match`, `fillSegment`, `disableSegment`, `lookforSegment`, `getChildrenArray`, `getChildrenMap`, `migrate`) perform substantive work such as complex logic, calculations, or state management.
   - The `compareTo` method implements necessary comparison logic.

4. **Encapsulation**:
   - The class encapsulates its data well by using private fields and providing only one getter method for accessing the character stored in the node.
   - The class's internal state is modified through private methods which help maintain the encapsulation.

5. **Local Symptom Summary**:
   - Although the class has several fields, and does include a getter method, a large portion of its behavior (more than just accessors) is involved in logic to manage the dictionary segments, including complex operations like matching text and filling segments.
   - The presence of meaningful methods performing significant work suggests that the class does more than simply hold data.

**Conclusion:**
NO, I did not find Data Class.
- The class has substantive behavior beyond simple getters and setters, implementing logic for matching text and filling segments in a dictionary tree, which indicates that it is not primarily a data holder."
RocketMQMessageHandler.java,"Let's analyze the given Java file based on the criteria for detecting the ""Data Class"" code smell:

1. **Fields:**
   - The file defines a class `RocketMQMessageHandler` with several fields: `errorMessageStrategy`, `sendFailureChannel`, `rocketMQTemplate`, `headerMapper`, `transactional`, `destination`, `groupName`, `instrumentationManager`, `sync`, `running`, `producerProperties`, and `partitioningInterceptor`.
   - These fields are not public but have getter and setter methods, which is a common way to expose internal state.

2. **Accessors:**
   - The class includes multiple getter and setter methods such as `setSendFailureChannel`, `setErrorMessageStrategy`, `getSendFailureChannel`, `setSync`, `getHeaderMapper`, and `setHeaderMapper`.
   - While some of these accessors are necessary due to the class implementing `AbstractMessageHandler` and `Lifecycle`, they do form a significant part of the class's interface.

3. **Methods and Behavior:**
   - The class contains non-trivial methods such as `start`, `stop`, `isRunning`, `handleMessageInternal`, and constructors.
   - These methods perform specific behaviors, including starting and stopping the handler, handling messages, and managing life cycle.

4. **Encapsulation:**
   - The class encapsulates its state through encapsulation with methods. For example, the `sync` field is accessed via `setSync` and `handleMessageInternal` logic.
   - While the class exposes some of its state through accessors, it also hides specific operations behind meaningful methods like `handleMessageInternal`.

5. **Local Symptom Summary:**
   - The class has several fields but meaningful behavior in its methods, such as message handling and lifecycle management.
   - The presence of significant behavior methods indicates that it is not purely a data holder.

**Conclusion:**
- **Answer:** NO, I did not find Data Class.
- **Rationale:** Although the class does include several fields and accessors, it also contains substantial methods that perform meaningful logic, such as handling messages and managing its lifecycle, which differentiates it from a simple data holder."
NacosDiscoveryProperties.java,"Based on the analysis of the provided file, let's step through the questions:

1. **Fields:**
   - The file defines a class with numerous fields (attributes), such as `serverAddr`, `username`, `password`, `endpoint`, `namespace`, `watchDelay`, `logName`, `service`, etc. None of these fields are explicitly marked as `public`, but they are accessed via getters and setters. This suggests a pattern where fields are meant to be accessed and modified indirectly.

2. **Accessors:**
   - There is a significant number of getter and setter methods corresponding to the fields defined. These methods are mechanical and do not include any complex logic. Public methods related to accessing and modifying the class's state are dominated by these accessors.

3. **Methods and Behavior:**
   - Apart from the millions of getters and setters, the class includes methods like `init()`, `overrideFromEnv(Environment env)`, `getNacosProperties()`, `enrichNacosDiscoveryProperties(Properties nacosDiscoveryProperties)`, and `resolveKey(String key)`. These methods do include some meaningful behavior, such as environment overrides and property creation, but they are not extensive and do not define core business logic.

4. **Encapsulation:**
   - While the class does provide getter and setter methods which are a form of encapsulation, it predominantly exposes its data through these methods rather than abstracting it behind services or operations that provide higher-level functionality.

5. **Local Symptom Summary:**
   - The class looks like it is primarily a data holder with minimal real behavior. The main symptoms include a high number of fields with corresponding getter and setter methods, and a few methods that deal with configuration and property management, indicating little substantive logic.

**Conclusion:**

YES, I found Data Class
- **Clearest Evidence:** ""almost all methods are getters/setters,"" ""fields are primarily managed through accessors with minimal other behavior."""
HtmlTreeBuilderStateTest.java,"NO, I did not find Data Class.

### Explanation:
1. **Fields**: The `HtmlTreeBuilderStateTest` class does not define any fields of its own. The fields mentioned in `Constants.class` are accessed via reflection but are not part of this class itself.

2. **Accessors**: There are no getter or setter methods in this class.

3. **Methods and Behavior**: The class has behavior in the form of test methods (`ensureArraysAreSorted`, `nestedAnchorElements01`, `nestedAnchorElements02`) that perform meaningful work such as asserting the state of parsed HTML documents and ensuring that constant arrays are sorted.

4. **Encapsulation**: There is no issue with exposure of data in this class since it is a test class and is not designed to encapsulate data. Instead, it accesses static arrays from `Constants.class` for testing purposes.

5. **Local Symptom Summary**: The class is primarily a test suite containing methods that perform actual work and checks, rather than just holding data or being a data holder with minimal behavior. This does not align with the characteristics of a Data Class."
QuotedStringTokenizer.java,"Let's analyze the provided Java file step-by-step according to the questions given:

1. **Fields:**
   - **Observation:** The file defines a class `QuotedStringTokenizer` which includes several fields like `_string`, `_delim`, `_returnQuotes`, `_returnDelimiters`, `_token`, `_hasToken`, `_i`, `_lastStart`, `_double`, `_single`.
   - **Conclusion:** The class does have multiple fields.

2. **Accessors:**
   - **Observation:** The file includes several getter and setter methods for private fields such as `getDouble()`, `setDouble(boolean d)`, `getSingle()`, and `setSingle(boolean single)`.
   - **Conclusion:** There are some getter and setter methods, but they are not overwhelming.

3. **Methods and Behavior:**
   - **Observation:** The class includes methods like `hasMoreTokens()`, `nextToken()`, `nextToken(String delim)`, `hasMoreElements()`, `nextElement()`, `countTokens()`, `quote()`, `quoted(StringBuffer buf, String s)`, `unquote(String s)`, and `convertHexDigit(byte b)`. These methods perform substantive work beyond just getting or setting fields.
   - **Conclusion:** The class contains multiple methods that perform various operations, suggesting functions beyond data holding.

4. **Encapsulation:**
   - **Observation:** The fields in the class are private, and access is provided via public methods.
   - **Conclusion:** The class does hide its data behind meaningful services.

5. **Local Symptom Summary:**
   - **Observation:** While the class does hold data and includes getter and setter methods for a couple of its fields, the majority of its methods perform meaningful operations rather than being just simple accessors.
   - **Conclusion:** The class does not primarily function as a data holder with minimal behavior.

**Final Answer:**  
NO, I did not find Data Class.  
**Main Reason:** The class contains several methods that perform substantive operations, not just being a container for data with simple accessors."
CodeCacheStage.java,"NO, I did not find Data Class.

**Explanation:**

1. **Fields:** The class has a few fields, but it does not expose them directly or through simple getter/setter methods. It has a private field `labelLeft` which is used in calculations and logic but does not have public accessors.

2. **Accessors:** The class does not have many simple getter and/or setter methods. There are no noticeable patterns where the class is primarily composed of accessor methods.

3. **Methods and Behavior:** The class contains methods that do substantive work, such as `redraw`, `addToGraph`, and `showLabel`. These methods involve significant logic, calculations, and interactions with other classes, which goes beyond just getting or setting fields.

4. **Encapsulation:** The class maintains good encapsulation by not exposing its fields directly. It uses non-public fields and provides meaningful methods that perform complex operations.

5. **Local Symptom Summary:** The class has a few fields but primarily consists of methods that perform meaningful operations and do not simply act as data holders. Thus, there are no strong indications of a Data Class."
HTTPSession.java,"Let's analyze the provided Java file step-by-step based on the criteria you've specified:

1. **Fields**:
   - The `HTTPSession` class defines multiple fields such as `httpd`, `tempFileManager`, `outputStream`, `inputStream`, `splitbyte`, `rlen`, `uri`, `method`, `parms`, `headers`, `cookies`, `queryParameterString`, `remoteIp`, and `protocolVersion`.
   - Most fields are private, which is a good sign of encapsulation. However, there are some static final fields like `POST_DATA`, `REQUEST_BUFFER_LEN`, `MEMORY_STORE_LIMIT`, `BUFSIZE`, and `MAX_HEADER_SIZE` that are public but final, indicating they are constants.

2. **Accessors**:
   - The class has several getter methods such as `getCookies()`, `getHeaders()`, `getInputStream()`, `getMethod()`, `getParms()`, `getParameters()`, `getQueryParameterString()`, `getUri()`, `getBodySize()`, and `getRemoteIpAddress()`.
   - It does not have many public setter methods, which is good for encapsulation.
   - Methods like `getCookies()`, `getHeaders()`, `getMethod()`, and `getUri()` are simple and only return the value of the corresponding fields.

3. **Methods and Behavior**:
   - The class has methods that perform substantive work, such as `decodeHeader()`, `decodeMultipartFormData()`, `decodeParms()`, `execute()`, `findHeaderEnd()`, `getBoundaryPositions()`, `parseBody()`, and `saveTmpFile()`. These methods are not just simple getters/setters. They handle parsing, decoding, and processing, which are core functionalities.
   - There are several complex methods that manipulate the input/output streams, cookies, headers, and parameters.

4. **Encapsulation**:
   - The class uses encapsulation by keeping most fields private and providing access to them only through methods.
   - It also handles complex logic related to HTTP request parsing, handling multipart data, and reading bodies, which is not typical for a pure data class.

5. **Local Symptom Summary**:
   - While the class does have several fields and simple accessors, it also includes significant logic for processing HTTP requests and handling data. This complexity and functionality suggest that it is not just a data class.

Based on these observations:

**NO, I did not find Data Class**.  
The evidence is that the class contains substantial logic and is involved in significant processing of HTTP requests, which goes beyond being a simple data holder class."
ParserConfig.java,"### Analysis Based on Provided Java File:

**Step-by-Step Analysis:**

1. **Fields:**
   - The class `ParserConfig` defines numerous fields, many of which store configuration and mapping information, such as `deserializers`, `symbolTable`, `propertyNamingStrategy`, `modules`, `propertyNamingStrategy`, and several arrays and collections.
   - No fields are public, but most could be made public or accessed directly through getters/setters.

2. **Accessors:**
   - The class contains many getter and setter methods. For example, `getDeserializer()`, `getDeserializers()`, `getSafeMode()`, `setSafeMode(boolean)`, `isAutoTypeSupport()`, `setAutoTypeSupport(boolean)`, etc.
   - Almost half of the methods are either getters or setters.

3. **Methods and Behavior:**
   - The class has a number of methods that perform significant tasks such as `initDeserializers()`, `getDeserializer(Class<?>, Type)`, `checkAutoType(String, Class<?>, int)`, `register(String, Class)`, etc.
   - These methods handle complex logic for various deserialization processes and configurations, which indicates substantial functionality.

4. **Encapsulation:**
   - Although the class contains numerous fields and accessor methods, it also includes several methods that encapsulate complex operations, such as `getDeserializer()` methods, `checkAutoType()`, and `initDeserializers()`.
   - The class is not just a plain container; it also contains logic for dynamic deserialization, configuration management, and handling type checks.

5. **Local Symptom Summary:**
   - While the class has a lot of fields and accessor methods, it also contains substantial business logic, such as deserialization handling, configuration management, and type checks.
   - This indicates more than just being a data holder; it has meaningful behavior.
   - Therefore, while there are some signs of a Data Class, the presence of significant behavior counteracts this.

**Conclusion:**

NO, I did not find Data Class. The class contains substantial behavior and logic, not just data storage and basic accessors. The methods perform complex deserialization, configuration management, and type checking tasks."
btActivatingCollisionAlgorithm.java,"NO, I did not find Data Class.

**Explanation:**

1. **Fields:**  
   The class `btActivatingCollisionAlgorithm` has only one field, `swigCPtr`, which is private.

2. **Accessors:**  
   The class does not define any getter or setter methods for its field.

3. **Methods and Behavior:**  
   The class has several methods, but they are not simple getters or setters. They include constructors, a `reset` method, a method returning a C pointer, a `finalize` method, and a `delete` method, which manage the object's lifecycle and interaction with native code. These methods perform substantive work related to memory management and object restoration.

4. **Encapsulation:**  
   The field `swigCPtr` is private, and there are no direct accessors to expose it publicly.

5. **Local Symptom Summary:**  
   The class has minimal fields and does not expose them through public accessors. The methods it contains are predominantly concerned with memory management and deal with native code interaction, indicating more than just data holding."
RedissonTransactionalBucket.java,"Let's analyze the provided Java file according to the criteria for the ""Data Class"" code smell:

1. **Fields:**
   - The file defines several fields: `timeout`, `executed`, `operations`, `state`, and `transactionId`.
   - These fields are not public; they are private, which is a good sign.

2. **Accessors:**
   - There are no explicit simple getters and setters for the private fields. The fields are directly manipulated within the class.

3. **Methods and Behavior:**
   - The class contains several methods like `expireAsync()`, `clearExpireAsync()`, `moveAsync()`, `deleteAsync()`, `getAsync()`, `compareAndSetAsync()`, among others.
   - These methods perform significant operations related to the transactional bucket operations, including adding operations to the `operations` list and manipulating the `state` field.
   - These methods involve asynchronous operations and manipulation of internal state, which indicates behavior beyond merely holding data.

4. **Encapsulation:**
   - The class hides the internal data behind methods that perform actions based on that data (e.g., `executeLocked()` for synchronizing operations).
   - The fields are encapsulated and not directly exposed (no public fields or trivial accessors).

5. **Local Symptom Summary:**
   - Although the class has multiple fields, it is primarily composed of methods that perform meaningful work such as asynchronous operations, state management, and synchronization.
   - These methods are not simple getters and setters, indicating that the class does more than just hold data.

**Conclusion:**
NO, I did not find Data Class. The class contains substantial methods that handle business logic and operations beyond mere data storage and retrieval."
HttpClientRequestContext.java,"Let's analyze the provided Java file according to the questions given:

1. **Fields:**
   - The class defines two private fields: `httpUriRequest` of type `HttpUriRequest` and `httpClientContext` of type `HttpClientContext`.
   
2. **Accessors:**
   - The class has four methods, all of which are simple getters and setters for the two fields.

3. **Methods and Behavior:**
   - There are no methods that perform any substantive work, calculations, or contain business logic. The methods only get or set the fields.

4. **Encapsulation:**
   - The fields are indeed encapsulated (private), but the class exposes them through public getter and setter methods.

5. **Local Symptom Summary:**
   - The class appears to be a holder for data (`httpUriRequest` and `httpClientContext`) with minimal real behavior, evident from the presence of only getter and setter methods.

Based on this analysis, we can conclude:

YES, I found Data Class. The main sign is “almost all methods are getters/setters” with no other significant behavior."
DefaultMQAdminExtImpl.java,"### Analysis of the Java Code for Data Class Smells

1. **Fields:**
   - The class `DefaultMQAdminExtImpl` defines several fields, including `log`, `defaultMQAdminExt`, `serviceState`, `mqClientInstance`, `rpcHook`, `timeoutMillis`, `random`, and a static set `SYSTEM_GROUP_SET`. These are used to hold state and configuration information.
   
2. **Accessors:**
   - There are no explicit getter/setter methods in this class for its fields. Methods like `getNameServerAddressList()` and `putKVConfig(String, String, String)` perform interactions related to the data, but they are not simple getter/setters.

3. **Methods and Behavior:**
   - The class contains numerous methods that perform substantive operations such as querying broker information, managing subscription groups, examining topics, managing offsets, and more. These methods involve complex interactions with the RocketMQ system and are not just getters or setters.

4. **Encapsulation:**
   - The class encapsulates its data well. Most of the fields are private, and most of the logic is hidden behind meaningful methods that interact with the RocketMQ messaging system.

5. **Local Symptom Summary:**
   - Given the analysis, the class does not fit the description of a Data Class because it contains a significant amount of substantive methods performing complex operations rather than merely holding and exposing data.

### Conclusion

NO, I did not find Data Class.

**Evidence:** The class `DefaultMQAdminExtImpl` includes numerous methods that perform complex operations, indicating it is not primarily a data holder with minimal real behavior."
Settings.java,"### Step-by-Step Analysis:

1. **Fields:**
   - The class defines a significant number of fields, each representing a configuration setting (e.g., `askedForUpdateCheck`, `checkForUpdates`, `startHidden`, etc.).
   - These fields are mostly of type `Property` (subclasses of `SimpleProperty`) used for JavaFX data binding.

2. **Accessors:**
   - The class has numerous getter methods (e.g., `askedForUpdateCheck()`, `checkForUpdates()`, `startHidden()`, etc.).
   - Since the fields are of type `Property`, they not only provide getters but also setters implicitly available through the JavaFX Property API.

3. **Methods and Behavior:**
   - The class contains minimal methods that perform substantial work. The primary methods are used for data binding or saving settings (`saveCmd` and `somethingChanged()`).
   - There is only one method that does something more than just get or set values: `save()`, which triggers a save operation if `saveCmd` is present.

4. **Encapsulation:**
   - The class encapsulates its data reasonably well using JavaFX `Property` types, which centralize state tracking (e.g., listeners).
   - While the data is accessible through many getters, the class does attempt to control modifications through the use of `Property`.

5. **Local Symptom Summary:**
   - The class looks like it is primarily a data holder because it contains numerous fields and a large number of getter methods.
   - The class has minimal real behavior (only a few methods that perform actual actions), and most of its methods are straightforwardly getters or part of the JavaFX property management.

### Conclusion:
YES, I found Data Class  
**Evidence:** almost all methods are getters/setters and the class contains numerous fields representing configuration data with minimal real behavior."
ConnectionPageShellCommands.java,"Let's analyze the provided Java file to determine if it exhibits the ""Data Class"" code smell:

1. **Fields:**  
   - The file defines several fields to maintain state, such as `dataSource`, `commandText`, `showProcessCheck`, `waitFinishCheck`, `waitFinishTimeoutMs`, `terminateCheck`, `pauseAfterExecute`, `workingDirectory`, `eventTypeTable`, and `eventsCache`.
   - Most fields are used to store UI components or data related to the state of the shell commands.

2. **Accessors:**  
   - There are no explicit getter and setter methods that expose the fields directly.
   - However, there are several methods that manipulate or retrieve the state of the fields, such as `getSelectedEventType()`, `getEventItem(DBPConnectionEventType eventType)`, `getActiveCommand()`, and the `selectEventType(DBPConnectionEventType eventType)` method.
   - These methods can be considered partial accessors as they provide controlled access to the fields rather than direct access.

3. **Methods and Behavior:**  
   - The class contains multiple methods (`updateEvent(boolean commandChange)`, `selectEventType(DBPConnectionEventType eventType)`, `saveSettings(DBPDataSourceContainer dataSourceDescriptor)`) that do more than just set or get fields.
   - These methods handle UI interactions, state management, and business logic related to how shell commands are configured and managed within the UI.

4. **Encapsulation:**  
   - The class encapsulates the data it holds and provides functionality to modify or read this data in a controlled manner.
   - The UI components are not exposed publicly; instead, the class provides methods to update and retrieve the state.

5. **Local Symptom Summary:**  
   - While the class does have several fields and methods that manipulate these fields, it also includes significant behavior and logic that operates on these fields.
   - These operations are more complex than simple getters and setters, indicating that the class is not merely a data holder.

**Conclusion:**

- **NO, I did not find Data Class.**  
  The class includes substantial methods that perform meaningful operations and maintain behavior beyond simple data storage and access, which suggests it is not primarily a data class."
MailUtil.java,"NO, I did not find Data Class.

### Explanation:
1. **Fields**: The class `MailUtil` does not define any fields. It consists primarily of static methods.

2. **Accessors**: Since there are no fields defined, there are also no getter or setter methods in this class.

3. **Methods and Behavior**: The class contains many static methods that perform substantive work, such as sending emails, handling email content, and managing email sessions. These methods are not just getters or setters.

4. **Encapsulation**: As mentioned, there are no fields to encapsulate. The class essentially operates through parameters and returns specific results rather than managing internal state.

5. **Local Symptom Summary**: The class is a utility class with a set of static methods for sending emails and managing email content. It does not act as a data holder as there are no fields and most methods provide significant functionality.

Thus, based on the absence of fields and the presence of substantive methods, `MailUtil` is not a Data Class."
HttpRequestMethodsMatcherTest.java,"NO, I did not find Data Class.

The provided Java file is a test class named `HttpRequestMethodsMatcherTest` that extends `AbstractHttpRequestMatcherTest`. It does not define any fields or simple getter/setter methods. Instead, it includes test methods (`testEqualsAndHashCode`, `testGetContent`, `testGetToStringInfix`) which are typical of a unit test, checking the behavior and properties of another class, `HttpRequestMethodsMatcher`. There is no sign of data exposure or encapsulation issues, and the class is clearly focused on testing rather than being a data holder."
SymbolInfo.java,"Let's analyze the file systematically based on the criteria you provided:

1. **Fields**:
   - The class `SymbolInfo` defines several fields such as `rectangular`, `dataCapacity`, `errorCodewords`, `matrixWidth`, `matrixHeight`, `dataRegions`, `rsBlockData`, and `rsBlockError`.

2. **Accessors**:
   - The class includes many simple getter methods such as `getDataCapacity()`, `getErrorCodewords()`, `getSymbolWidth()`, `getSymbolHeight()`, `getSymbolDataWidth()`, `getSymbolDataHeight()`, `getCodewordCount()`, `getInterleavedBlockCount()`, `getDataLengthForInterleavedBlock(int index)`, and `getErrorLengthForInterleavedBlock(int index)`.
   - It also includes setter functionality via its constructors.

3. **Methods and Behavior**:
   - While the class has some methods that correspond to calculating dimensions and properties of the symbol, these rely on the stored attributes.
   - Methods like `lookup(int dataCodewords, SymbolShapeHint shape, Dimension minSize, Dimension maxSize, boolean fail)`, `getHorizontalDataRegions()`, and `getVerticalDataRegions()` appear to perform substantive calculations, but they are primarily based on the data stored.

4. **Encapsulation**:
   - The fields `matrixWidth` and `matrixHeight` are public, which decreases encapsulation.
   - The other fields are private but expose via getters and setters, which is typical for data classes but can still signify a lack of control over the data.

5. **Local Symptom Summary**:
   - The class behaves primarily as a holder for data. While it does include some methods with substantive work, a significant portion of its methods are getters and setters or calculations based on its stored data. The prevalence of getters and setters combined with public fields is a clear sign.

**Final Assessment**:
YES, I found Data Class.
**Evidence**: Most of the methods are getters/setters or simple calculations based on the stored data, and two fields (`matrixWidth` and `matrixHeight`) are public."
TextureAtlas.java,"After analyzing the provided Java file, I will evaluate it against the criteria for a Data Class:

1. **Fields**:  
   The class `TextureAtlas` contains fields like `textures` and `regions`, which are not public but are exposed through methods. It also contains nested classes `TextureAtlasData`, `Page`, `Region`, `AtlasRegion`, and `AtlasSprite`, each with their own fields. Some fields in these nested classes (like `Page`, `Region`, `AtlasRegion`, `AtlasSprite`) are public.

2. **Accessors**:  
   The class and its nested classes define methods that primarily serve as getters (e.g., `getRegions()`, `getPages()`, `getRegions()`, `getAtlasRegion()`). There are a few setters and other methods, but the majority are accessors.

3. **Methods and Behavior**:  
   There are methods that perform real work, such as loading data from files (`load()`), managing regions (`addRegion()`), and creating sprites (`createSprite()`). These methods go beyond simple getters/setters and perform substantive tasks.

4. **Encapsulation**:  
   The `TextureAtlas` class and its support classes make efforts to encapsulate the data, providing methods for operations on the data rather than directly exposing the internal data structures. For example, `getRegions()` returns a copy or a managed list, and not the original collection directly.

5. **Local Symptom Summary**:  
   While the class contains many fields and accessor methods, it also has significant behavior that involves data manipulation and operations, such as loading, managing, and creating various graphics objects.

**Conclusion**:
NO, I did not find Data Class. Although the class has several fields and accessor methods, it also contains substantial behavior methods that perform operations on the data, adding value beyond just holding data."
ImmutableEnumMap.java,"NO, I did not find Data Class.

The provided Java file defines a class `ImmutableEnumMap` that primarily wraps an `EnumMap` to provide an immutable view of it. While it does have several fields and methods that get or set fields indirectly through the delegate `EnumMap`, the class also implements several methods that perform substantive operations, such as `equals`, `containsKey`, `get`, `keyIterator`, `entryIterator`, and `forEach`. These methods are not mere getters/setters—they encapsulate behavior specific to the functionality of an immutable map.

The class also follows good encapsulation principles by not exposing the `delegate` directly and instead providing an immutable interface to the underlying `EnumMap`. Therefore, it cannot be categorized as a Data Class based on the provided criteria."
CharacterReader.java,"Let's analyze the provided `CharacterReader` Java file step-by-step according to your instructions.

### Step 1: Fields
- The class defines several fields such as `charBuf`, `reader`, `bufLength`, `bufSplitPoint`, `bufPos`, `readerPos`, `bufMark`, `stringCacheSize`, and `stringCache`.
- These fields are mostly private and not exposed directly, which is a good sign, but they are used internally by several methods.
- There is one static final field `EOF` which is exposed.

### Step 2: Accessors
- While there are no direct public fields, there are getter methods for some fields. For example:
  - `public int pos() { return readerPos + bufPos; }`
  - `public boolean isEmpty() { bufferUp(); return bufPos >= bufLength; }`
- The class does not have simple getters and setters for most of the fields. The majority of its methods perform various operations rather than just retrieving or setting values.

### Step 3: Methods and Behavior
- The class contains methods that perform substantive work, such as:
  - `bufferUp()` which reads data from the buffer.
  - `consume()`, `unconsume()`, `advance()`, `mark()`, `unmark()`, `rewindToMark()`, and others which manipulate the buffer position.
  - Various `consumeTo()` and `nextIndexOf()` methods that perform specific actions based on the content of the buffer and search for specific sequences.
- These methods are not just simple accessors; they implement complex behaviors related to parsing and consuming characters.

### Step 4: Encapsulation
- The class encapsulates its data by using private fields and providing public methods to interact with the data.
- The class internal operations are not exposed directly, and it provides a higher-level interface for reading and manipulating the data.

### Step 5: Local Symptom Summary
- The class does not primarily look like a Data Class. While it has fields and provides some getter-like methods, the majority of its methods are involved in substantial processing and behavior related to reading from a `Reader` and parsing character sequences.

### Conclusion
- **NO, I did not find Data Class**.
- The `CharacterReader` class has more than just getters and setters. It has a significant number of methods that perform parsing and buffer management, rather than just holding data passively."
ArgumentTokenizer.java,"Let's analyze the provided Java file step by step for symptoms of the ""Data Class"" code smell:

1. **Fields**:
   - The class defines several constant fields (`NO_TOKEN_STATE`, `NORMAL_TOKEN_STATE`, `SINGLE_QUOTE_STATE`, `DOUBLE_QUOTE_STATE`). These are used to manage the state within the `tokenize` method. However, these are not instance fields that represent data held by an object instance. The class does not define any instance fields that serve as data storage.

2. **Accessors**:
   - There are no simple getter or setter methods in this class. Instead, it provides static utility methods (`tokenize` and `_escapeQuotesAndBackslashes`).

3. **Methods and Behavior**:
   - The class has two static methods that perform substantive operations: 
     - `tokenize`: This method takes a string and tokenizes it into a list of arguments, handling different states for quoted strings and escape characters.
     - `_escapeQuotesAndBackslashes`: This method escapes quotes, backslashes, and other special characters in a string.
   - These methods include complex logic, are not merely getters or setters, and handle meaningful tasks.

4. **Encapsulation**:
   - The class does not expose its internal state since it does not have any instance fields. It uses static methods, and the state management (as seen in the `state` variable) is local to the `tokenize` method.

5. **Local Symptom Summary**:
   - The class does not primarily hold data. It is an utility class providing static methods to perform specific tasks without exposing any data fields directly or indirectly.

Based on the analysis:

**NO, I did not find Data Class**.
The provided file does not indicate a Data Class because it consists of static utility methods that perform specific tasks and do not primarily serve as a container for data."
JobLogController.java,"**Analysis:**

1. **Fields:**
   The class `JobLogController` defines several fields, some of which are public (`xxlJobInfoDao`, `xxlJobLogDao`). However, these fields are dependencies injected through annotations, not direct data holders for the class itself.

2. **Accessors:**
   The class does not have many simple getter and/or setter methods. Most methods are request mappings that handle HTTP requests rather than accessors.

3. **Methods and Behavior:**
   The methods in the class are controller methods that handle requests and interact with other components. There are methods that perform tasks such as loading job information (`index`), getting job lists by group (`getJobsByGroup`), handling log requests (`logDetailPage`, `logDetailCat`), killing logs (`logKill`), and clearing logs (`clearLog`). These tasks are not simple data manipulation but involve logic for web operations.

4. **Encapsulation:**
   The class does not expose fields directly for manipulation; instead, it interacts with data through DAOs and other service components. It hides its data behind meaningful service methods.

5. **Local Symptom Summary:**
   The class does not appear to be a primary data holder with minimal real behavior. It contains business logic for handling requests related to job logs and interacts with various components rather than acting as a simple data container.

**Conclusion:**
NO, I did not find Data Class. The class is a controller and interacts with other components to handle web requests, showing more than just simple data operations."
Monitor.java,"**NO, I did not find Data Class**

### Explanation:
1. **Fields**: The class defines several fields (`last_modified`, `eTags`, `location`), but they are private, which suggests good encapsulation.
2. **Accessors**: There are no getter and setter methods provided for the fields, which means the class is not exposing its fields directly through many simple accessors.
3. **Methods and Behavior**: The class has only one significant method with business logic (`runUnprivileged`), which performs monitoring and updating tasks. It also has a `run` method, but this is part of the `Runnable` interface implementation. This indicates that the class has relevant behavior.
4. **Encapsulation**: The fields are private and are not exposed through public getters/setters, indicating good encapsulation.
5. **Local Symptom Summary**: The class does not exhibit a pattern typical of a Data Class. It has a clear purpose beyond data storage and includes meaningful business logic in its methods."
HistoryPageFilter.java,"### Step-by-Step Analysis:

1. **Fields:**
   - The class defines several fields such as `maxEntries`, `newerThan`, `olderThan`, `searchString`, `queueItems`, `runs`, `hasUpPage`, `hasDownPage`, `nextBuildNumber`, `widget`, `newestOnPage`, `oldestOnPage`.

2. **Accessors:**
   - There is one setter for `newerThan`, one setter for `olderThan`, and one setter for `searchString`.
   - There are multiple fields exposed directly (`queueItems`, `runs`, `hasUpPage`, `hasDownPage`, `nextBuildNumber`, `widget`, `newestOnPage`, `oldestOnPage`), with the majority being package-private.
   - Some fields (`queueItems`, `runs`) are public, which is highly indicative of poor encapsulation.

3. **Methods and Behavior:**
   - Apart from the setter methods, there are several methods that do substantive work such as `add`, `addInternal`, `sort`, `getNextBuildNumber`, `addQueueItem`, `addRun`, `updateNewestOldest`, `add`, `isFull`, `getFillCount`, `fitsSearchParams`, `fitsSearchString`, `fitsSearchBuildVariables`, `fitsSearchBuildParameters`.
   - These methods contain meaningful logic, including sorting, filtering, and data manipulation, and are not mere getters/setters.

4. **Encapsulation:**
   - The class exposes several fields directly, particularly `queueItems` and `runs`, which are public and thus violate encapsulation principles.
   - There is a mix of private fields with public accessors, indicating mixed encapsulation behavior, but the presence of exposed fields is a significant red flag.

5. **Local Symptom Summary:**
   - While the class does contain several fields and has some accessors, it also has many methods that perform substantial operations on the data.
   - The substantial behavior is more dominant than the simple getters and setters, and there are exposed fields, making it less of a pure data class.

### Conclusion:
NO, I did not find Data Class.
While the class contains multiple fields and has a few accessor methods, the presence of numerous methods performing substantial operations and data manipulations indicates that the class plays a role beyond just holding data. The exposure of some fields directly also reduces its classification as a Data Class."
HandshakeData.java,"### Step-by-Step Analysis:

1. **Fields:**
   - The class `HandshakeData` defines several fields: `headers`, `address`, `time`, `local`, `url`, `urlParams`, and `xdomain`.
   - None of the fields are declared as `public`, and all are private.

2. **Accessors:**
   - The class contains many simple getter methods for all of its fields, such as `getAddress()`, `getLocal()`, `getHttpHeaders()`, `getTime()`, `getUrl()`, `isXdomain()`, and `getUrlParams()`.
   - There is one method that is slightly more complex, `getSingleUrlParam(String name)`, which performs a small piece of logic.

3. **Methods and Behavior:**
   - There are very few methods that do substantive work. Primarily, the class contains constructors and accessor methods.
   - `getSingleUrlParam` is the only method that involves any sort of computation or business logic, but this is minimal compared to the number of simple getter methods.

4. **Encapsulation:**
   - The class encapsulates its data effectively by having all fields private and providing public getter methods to access them.
   - There are no setter methods provided, which suggests that once the object is created, its fields are immutable or not meant to be changed externally.

5. **Local Symptom Summary:**
   - The class looks like it is primarily a data holder with minimal real behavior. The main sign is the presence of many simple getters with no corresponding setters, and very little logic beyond accessing the stored data.

### Conclusion:
**YES, I found Data Class.** The clearest evidence is that ""almost all methods are getters with no setters and most of its public methods are accessors."""
Vault.java,"### Analysis of the `Vault` Class for Data Class Code Smell

Let's go through the provided `Vault` class according to the specified criteria:

1. **Fields:**
   - The class has several fields, including: `vaultSettings`, `volumeProvider`, `defaultMountFlags`, `cryptoFileSystem`, `state`, `lastKnownException`, `configCache`, `stats`, `displayName`, `displayablePath`, `locked`, `processing`, `unlocked`, `missing`, `needsMigration`, `unknownError`, `accessPoint`, `accessPointPresent`, `showingStats`, `volume`.
   - These fields are predominantly private, which is good for encapsulation, but the class does use many JavaFX properties that expose observable data, which might suggest a higher degree of data exposure.

2. **Accessors:**
   - The class provides a significant number of getter and setter methods. For example, `vaultSettings()`, `lastKnownExceptionProperty()`, `setLastKnownException()`, `isLocked()`, `isProcessing()`, `isUnlocked()`, `isMissing()`, `isNeedsMigration()`, `isUnknownError()`, `getDisplayName()`, `getAccessPoint()`, `isAccessPointPresent()`, `getDisplayablePath()`, `isShowingStats()`, `getStats()`, `getVaultSettings()`, `getPath()`, `isHavingCustomMountFlags()`, `getDefaultMountFlags()`, `getEffectiveMountFlags()`, `getVaultConfigCache()`, `setCustomMountFlags()`, `getId()`, `getVolume()`.
   - Most of the public methods are indeed accessors.

3. **Methods and Behavior:**
   - The class has a few methods that perform substantive work, such as `createCryptoFileSystem()`, `destroyCryptoFileSystem()`, `unlock()`, `lock()`, `lockOnVolumeExit()`, `reveal()`, `observables()`, `hashCode()`, `equals()`, `supportsForcedUnmount()`. While these are substantial, they represent a minority compared to the number of getter and setter methods.
   - The majority of the methods seem to be responsible for managing the state and retrieval of fields, rather than enforcing business rules or performing meaningful operations.

4. **Encapsulation:**
   - The use of JavaFX properties and bindings indicates that the class exposes its state through these properties, which might be seen as a form of encapsulation tailored for UI bindings. This is typical in data-centric applications.
   - The private fields are mostly exposed through methods, which can be viewed as good practice as long as these methods are not mere pass-throughs.

5. **Local Symptom Summary:**
   - The class primarily seems to hold a significant amount of data with many methods dedicated to getting and setting this data.
   - Although the class includes methods that do perform meaningful operations, the overwhelming presence of getters and setters combined with a significant use of observable properties for data binding creates a strong impression of being a data holder.

### Conclusion

**YES, I found Data Class**

**Evidence:** The class contains a vast number of fields and a large proportion of methods are simple getters and setters (or bindings), suggesting it primarily holds data rather than enforcing behavior or business logic."
CommandDecoder.java,"NO, I did not find Data Class

### Explanation:

1. **Fields**: The class `CommandDecoder` has several fields, but these are not primarily exposed or manipulated through public accessors. Fields like `log`, `scheme`, and `CR`, `LF`, `ZERO` are not public and serve specific purposes within the class.

2. **Accessors**: The class does not have many getter or setter methods for its fields. It does not expose its fields via property accessors, which is a key indicator of a Data Class.

3. **Methods and Behavior**: The class contains numerous methods that perform substantive work, such as decoding commands, handling exceptions, and processing byte buffers. Methods like `decode`, `skipDecode`, `readString`, `readLong`, etc., are not simply getters or setters but perform complex logic related to Redis protocol decoding.

4. **Encapsulation**: The class encapsulates its data and exposes behavior through meaningful methods rather than through public fields or simple accessors. It uses `ByteBuf` for efficient data handling and provides specific methods to handle different parts of the Redis communication protocol.

5. **Local Symptom Summary**: The class is not primarily a data holder with minimal real behavior. Instead, it is a complex handler class responsible for decoding data received from a Redis channel into meaningful commands and responses."
FxApplication.java,"Let's analyze the provided `FxApplication` class step by step according to the given criteria.

### 1. Fields
The class defines several fields, including:
- `private final Settings settings;`
- `private final Lazy<MainWindowComponent> mainWindow;`
- `private final Lazy<PreferencesComponent> preferencesWindow;`
- `private final Provider<UnlockComponent.Builder> unlockWorkflowBuilderProvider;`
- `private final Provider<LockComponent.Builder> lockWorkflowBuilderProvider;`
- `private final Lazy<QuitComponent> quitWindow;`
- `private final ErrorComponent.Builder errorWindowBuilder;`
- `private final Optional<TrayIntegrationProvider> trayIntegration;`
- `private final Optional<UiAppearanceProvider> appearanceProvider;`
- `private final VaultService vaultService;`
- `private final LicenseHolder licenseHolder;`
- `private final ObservableList<Window> visibleWindows;`
- `private final BooleanBinding hasVisibleWindows;`
- `private final UiAppearanceListener systemInterfaceThemeListener;`

The fields are private, which is good for encapsulation, and they are not exposed without getters or setters unless absolutely necessary.

### 2. Accessors
The class does not have many simple getter and setter methods. The only public getter method present is:
```java
public VaultService getVaultService() {
    return vaultService;
}
```
No setters are visible publicly, and the control of setting data is managed through other mechanisms, such as constructors and methods with parameters.

### 3. Methods and Behavior
The class has several methods, many of which perform substantive work beyond simple getters/setters:
- `public void start()`: Sets up the application, listens for window visibility changes, and listens for theme changes.
- `private void hasVisibleStagesChanged(...)`: Handles visibility changes of application windows.
- `public void showPreferencesWindow(...)`: Displays the preferences window.
- `public CompletionStage<Stage> showMainWindow()`: Displays the main window.
- `public void startUnlockWorkflow(...)`: Starts the unlock workflow for a vault.
- `public void startLockWorkflow(...)`: Starts the lock workflow for a vault.
- `public void showQuitWindow(...)`: Displays the quit window.
- `private void appThemeChanged(...)`: Handles changes in the application theme.
- `private void loadSelectedStyleSheet(...)`: Loads the CSS stylesheets based on the theme.
- `private void systemInterfaceThemeChanged(...)`: Applies the theme if the system theme changes.
- `private void applySystemTheme()`: Applies the system's default theme.
- `private void applyLightTheme()`: Applies the light theme.
- `private void applyDarkTheme()`: Applies the dark theme.

### 4. Encapsulation
The class uses private fields and provides limited public methods that are not just simple data access. It uses a constructor injection pattern with `@Inject`, implying that the fields are managed and controlled by the dependency injection framework, enhancing encapsulation.

### 5. Local Symptom Summary
The `FxApplication` class does not exhibit strong symptoms of a Data Class. It has multiple methods that perform significant work rather than just storing and retrieving data. Most of the fields are well-encapsulated, and the class has a clear behavior related to application management and UI operations.

**Conclusion:**
NO, I did not find Data Class. The class has substantial behavior that goes beyond just holding data, and it has good encapsulation practices."
HttpHeadRequestTest.java,"Let's analyze the provided Java file step-by-step to determine if it exhibits symptoms of the Data Class code smell.

### 1. Fields
The file `HttpHeadRequestTest` does not define its own class with fields (attributes); instead, it extends `HttpServerTest` and primarily uses the fields from the superclass. There are no fields defined within this class.

### 2. Accessors
The file does not explicitly define getter or setter methods within `HttpHeadRequestTest` for its fields. It uses a superclass's fields directly.

### 3. Methods and Behavior
The class is filled with test methods that perform various tests related to `HEAD` requests in an HTTP server context. These methods include:
- Invoking the server with different HTTP requests.
- Checking the parameters, headers, and other attributes received by the server.
- Ensuring responses meet expected criteria.

The methods are not just getters or setters; they perform substantive testing logic, involving assertions and verifications.

### 4. Encapsulation
The analysis of accessors and methods reveals that the class encapsulates behavior within test methods rather than exposing data through accessors directly.

### 5. Local Symptom Summary
The class `HttpHeadRequestTest` is clearly a test class. It inherits from `HttpServerTest` and does not serve as a data holder or expose its data primarily through accessors. Instead, it focuses on behavior—specifically, testing behavior—involving HTTP server requests and responses.

### Conclusion
Based on the analysis:

**NO, I did not find Data Class.**

The file `HttpHeadRequestTest` is a test class with substantive behavior related to testing HTTP server functionality rather than serving as a data holder with minimal or no real behavior."
BatchExecutor.java,"Let's analyze the provided Java file based on the criteria for the ""Data Class"" smell:

### 1. Fields
- **Fields:** The class `BatchExecutor` defines several fields (`statementList`, `batchResultList`, `currentSql`, `currentStatement`), but they are all private. There are no public or package-private fields.

### 2. Accessors
- **Accessors:** The class does not define explicit getter or setter methods for its fields. Therefore, there is no pattern of many simple getter and/or setter methods.

### 3. Methods and Behavior
- **Methods and Behavior:** The class overrides several methods from the `BaseExecutor` class and includes complex behaviors such as `doUpdate`, `doQuery`, `doQueryCursor`, and `doFlushStatements`. These methods perform substantive work, including database operations, batching, and handling of SQL statements.

### 4. Encapsulation
- **Encapsulation:** The class encapsulates its data well behind meaningful service methods. It does not expose its fields directly or through simple accessors.

### 5. Local Symptom Summary
- **Summary:** The class does not look like a primary data holder with minimal real behavior. It has several methods that perform complex and meaningful operations.

### Conclusion
NO, I did not find Data Class. The clearest evidence is that the class includes multiple methods that perform substantive operations, not just simple data access methods."
TokenQueue.java,"Let's analyze the `TokenQueue` class based on the criteria provided:

1. **Fields**:  
   - The class defines private fields: `queue` (a `String`), `pos` (an `int`), and `ESC` (a `char`). 
   - These fields are not public, and there are no package-private fields, so this criterion alone does not suggest a Data Class. However, it does start to paint a picture of data being held within the class.

2. **Accessors**:  
   - The class does not have many straightforward getters/setters. For example, there is no `getQueue()` or `getPos()` method. Instead, it has methods like `isEmpty()`, `remainingLength()`, and `addFirst(String seq)` that interact with the fields but do not merely act as getters/setters.
   - The absence of simple getter/setters might indicate that the class does not fit the typical appearance of a Data Class based on accessors alone.

3. **Methods and Behavior**:  
   - The class has numerous methods that do more than just get and set fields. It includes methods like `consume()`, `consumeTo(String seq)`, `matches(String seq)`, and other parsing and processing methods that perform substantive work.
   - This criterion leans against the class being a Data Class since it includes significant logic for parsing and manipulating the data held within the class.

4. **Encapsulation**:  
   - The class encapsulates its data quite well by keeping fields private and providing specific methods to manipulate and interact with the data.
   - The use of encapsulation is a sign that the class is more concerned with behavior than with just holding data.

5. **Local Symptom Summary**:  
   - The class primarily includes methods that manipulate and process the data within `queue` and `pos`. There are few simple accessors, and the class encapsulates its data.
   - It appears more as a utility class with a specific purpose of managing and parsing character sequences.

**Conclusion:**

No, I did not find Data Class. The `TokenQueue` class holds data but is not primarily a data holder with minimal real behavior. Instead, it contains a significant amount of methods that perform specific tasks, such as parsing and manipulating the data within the queue."
DubboServiceMetadataRepository.java,"### Analysis

Let's go through each question in relation to the provided Java class `DubboServiceMetadataRepository`:

1. **Fields:**
   - The class defines several fields that hold data, such as `allExportedURLs`, `serviceRestMetadata`, `subscribedServices`, `dubboRestServiceMetadataRepository`, `dubboCloudProperties`, `dubboMetadataConfigServiceProxy`, `discoveryClient`, `serviceInstanceSelector`, `jsonUtils`, `inetUtils`, `dubboMetadataUtils`, `currentApplicationName`, and `dubboMetadataServiceExporter`. These fields are primarily used to store data related to metadata and configuration.

2. **Accessors:**
   - The class has methods like `getServiceRestMetadata`, `getAllExportedUrls`, `getAllServiceKeys`, `getDubboProtocolPort`, `getExportedURLs`, `get`, `getSubscribedServices`, which retrieve or set data on the class fields. These methods are simple accessors.

3. **Methods and Behavior:**
   - While there are methods such as `initSubscribedServices`, `initializeMetadata`, `removeMetadataAndInitializedService`, `getDubboMetadataServiceMetadata`, `publishServiceRestMetadata`, `exportURL`, `unexportURL`, and `findSubscribedDubboMetadataServiceURLs`, which seem to perform substantive work (like initializing metadata or exporting URLs), many of the getter and setter-like methods exist primarily to manipulate the fields.
   
4. **Encapsulation:**
   - The class uses fields that are private, and provides public getter and setter-like methods to access and modify them. This is typical but not necessarily indicative of a Data Class. However, there are very few methods that represent more complex behaviors or encapsulated functionality.

5. **Local Symptom Summary:**
   - The class has a significant number of fields that store data and many methods that act as simple accessors for these fields. There are a few methods that perform more substantial work but they are fewer in number.

### Conclusion

Based on the analysis:
- The class has several fields that hold data.
- It has many simple getter and setter-like methods.
- There are several methods that perform more substantial work, but they are fewer in comparison to the fields and simple accessors.
- The class tends to expose its data through accessors rather than through complex methods that encapsulate significant behavior.

**Final Answer:** 
NO, I did not find Data Class. While the class contains many fields and accessors, it also has several methods that perform substantial work, which reduces the likelihood of it being a typical Data Class."
FakeValuesService.java,"Let's analyze the `FakeValuesService` class based on the criteria for detecting a Data Class.

1. **Fields**:
   - The class has several fields, but none of them are exposed directly. They include:
     - `private static final Pattern EXPRESSION_PATTERN`
     - `private static final Pattern EXPRESSION_ARGUMENTS_PATTERN`
     - `private final Logger log`
     - `private final List<FakeValuesInterface> fakeValuesList`
     - `private final RandomService randomService`
   These fields are not public or package-private, and they do not have simple getters and setters for every field.

2. **Accessors**:
   - The class does not have simple getters and setters that correspond to its fields. There are methods like `fetch`, `fetchString`, `safeFetch`, `fetchObject`, etc., which perform specific operations rather than simply exposing or modifying field values.

3. **Methods and Behavior**:
   - The class contains numerous methods that perform substantive work. Methods such as `fetch`, `safeFetch`, `fetchObject`, `numerify`, `letterify`, `regexify`, and `resolveExpression` carry out significant functionality. These methods are not merely getters or setters.

4. **Encapsulation**:
   - The class encapsulates its data well. The fields are private, and there are complex methods that utilize and manipulate these fields. The data is hidden behind meaningful methods that perform operations.

5. **Local Symptom Summary**:
   - The class does not look like a Data Class because it has meaningful methods that perform substantial operations. The class is designed to handle expressions and fetch values based on keys, and it includes logic for resolving expressions, fetching data from YAML files, and processing regular expressions.

**Conclusion:**

NO, I did not find Data Class. The class contains meaningful methods that perform complex operations, and its data is encapsulated well, with no simple getters and setters dominating the class."
PassphraseEntryController.java,"### Step-by-Step Analysis

1. **Fields:**
   - The class `PassphraseEntryController` indeed defines several fields, some of which are public (`passwordField`, `savePasswordCheckbox`, `unlockInProgressView`, `face`, `leftArm`, `rightArm`, `legs`, `body`, `unlockAnimation`) and some package-private fields (`window`, `vault`, `password`, `savePassword`, `savedPassword`, `passwordEntryLock`, `forgetPassword`, `keychain`, `unlockButtonContentDisplay`, `userInteractionDisabled`, `unlockButtonDisabled`, `vaultName`).

2. **Accessors:**
   - The class contains several getter methods such as `getVaultName`, `vaultNameProperty`, `unlockButtonContentDisplayProperty`, `getUnlockButtonContentDisplay`, `userInteractionDisabledProperty`, `isUserInteractionDisabled`, `unlockButtonDisabledProperty`, `isUnlockButtonDisabled`, and `isKeychainAccessAvailable`.
   - It provides some getter methods that return JavaFX properties to allow external binding and manipulation of these properties.

3. **Methods and Behavior:**
   - The class contains methods like `initialize`, `cancel`, `windowClosed`, `unlock`, `startUnlockAnimation`, `stopUnlockAnimation`, and `didClickSavePasswordCheckbox`. These methods perform more than just getting or setting fields, as they handle UI interactions, animations, and password management logic.
   - There is substantive work being done, especially in the `initialize` and `unlock` methods, which involve setting up UI components, manipulating JavaFX animations, and managing user input.

4. **Encapsulation:**
   - Despite having several fields exposed via the FXML annotations, the class still maintains encapsulation by using getters for many of its fields and properties. It does not expose everything directly.
   - For example, `passwordField` is public (which is typical for FXML-injected properties), but other fields are not directly exposed.

5. **Local Symptom Summary:**
   - While the class has fields and some getter methods, it is not merely a data holder. It contains significant logic for setting up and managing UI components, handling user interactions, and performing animations. This suggests that the class is more of a controller than a data class.

### Conclusion

**NO, I did not find Data Class**

**Reasoning:** The class contains substantial methods that perform important tasks (e.g., `initialize`, `unlock`, managing animations) and does more than just holding data and providing getters/setters. The majority of the methods are engaged in meaningful operations, not just field access."
LexemePath.java,"### Analysis of the Java File for Data Class Smell

Let's analyze the provided class `LexemePath` based on the criteria for a Data Class, which primarily focuses on how much the class is acting as a simple holder for data rather than performing real business logic.

#### 1. Fields:
The class `LexemePath` defines several fields:
- `pathBegin`
- `pathEnd`
- `payloadLength`

These fields are private, which is good for encapsulation.

#### 2. Accessors:
The class has getter methods for the fields:
- `getPathBegin()`
- `getPathEnd()`
- `getPayloadLength()`
- `getPathLength()`
- `getXWeight()`
- `getPWeight()`

#### 3. Methods and Behavior:
The class has methods that perform operations related to the lexical analysis path, such as:
- `addCrossLexeme(Lexeme lexeme)`
- `addNotCrossLexeme(Lexeme lexeme)`
- `removeTail()`
- `checkCross(Lexeme lexeme)`
- `copy()`
- `compareTo(LexemePath o)`
- `toString()`

These methods aren't just simple getters or setters; they include business logic related to managing the lexical path, such as adding or removing lexemes, calculating weights, and comparing paths.

#### 4. Encapsulation:
The class uses private fields and provides specific methods to manipulate and interact with the contained data, indicating a level of encapsulation and meaningful behavior rather than exposing raw data.

#### 5. Local Symptom Summary:
While the class does have some simple accessor methods and holds data, the majority of the methods perform significant operations rather than just get/set functionality.

### Conclusion:
**NO, I did not find Data Class**

### Clearest Evidence:
The class contains multiple methods that perform meaningful operations beyond just accessing or modifying its fields, indicating it has more than just data-holding responsibilities."
PullAPIWrapper.java,"**Answer:**  
NO, I did not find Data Class.

**Justification:**

1. **Fields:**
   - The file defines a class with several fields, but they are private, which indicates a level of encapsulation.

2. **Accessors:**
   - There are a few getter and setter methods (`isConnectBrokerByUser()`, `setConnectBrokerByUser()`, `getDefaultBrokerId()`, `setDefaultBrokerId()`), but these are not the majority of the methods.

3. **Methods and Behavior:**
   - The class contains multiple methods that perform substantial work, such as `processPullResult`, `pullKernelImpl`, `updatePullFromWhichNode`, and `recalculatePullFromWhichNode`. These methods are not just simple accessors and involve logic for pulling messages, updating data, and interacting with other components.

4. **Encapsulation:**
   - The data is not exposed directly; instead, it is managed through methods that perform meaningful operations, preserving encapsulation.

5. **Local Symptom Summary:**
   - The class is more of a service class than a data class, as it includes substantial behavior and does not primarily serve to hold data with simple accessors."
ParamFlowChecker.java,"NO, I did not find Data Class. 

**Explanation:**

1. **Fields:** The class `ParamFlowChecker` does not define any fields. It only contains static methods.

2. **Accessors:** There are no getter or setter methods. The class does not expose or manipulate fields directly or through accessor methods.

3. **Methods and Behavior:** The class contains several methods that perform substantive work. Methods like `passCheck`, `passLocalCheck`, `passSingleValueCheck`, `passDefaultLocalCheck`, `passThrottleLocalCheck`, and `passClusterCheck` involve complex logic and calculations related to parameter flow control.

4. **Encapsulation:** While the class does not expose instance fields, it does not need to as it is a utility class primarily concerned with behavioral methods.

5. **Local Symptom Summary:** The class is clearly a utility class that performs specific functionalities and contains business logic for parameter flow control, not merely holding data.

Based on the above observations, the class `ParamFlowChecker` does not exhibit symptoms of a Data Class."
SaTokenContextForThreadLocalStorage.java,"Let's analyze the provided Java file for symptoms of the ""Data Class"" code smell, following your step-by-step instructions:

1. **Fields:**
   The inner class `Box` defines three fields: `request`, `response`, and `storage`. These fields are declared as `public`, which is a direct exposure of the data.

2. **Accessors:**
   The `Box` class has getter and setter methods for each of its fields. These methods are simple and serve only to get or set the values of the fields.

3. **Methods and Behavior:**
   The `Box` class only contains methods that get or set its fields, along with an overridden `toString` method. There are no methods that perform substantive work or business logic.

4. **Encapsulation:**
   The `Box` class exposes its data fields directly due to their `public` access modifier, with accessors that provide no meaningful abstraction or behavior. The outer class `SaTokenContextForThreadLocalStorage` also has methods that primarily interact with these fields through the `Box` instance, but these methods are more operational and provide some specific behaviors related to the context handling.

5. **Local Symptom Summary:**
   The `Box` class looks like a pure data holder with minimal real behavior. Its main sign is that all fields are public and it contains almost all methods as getters/setters.

**Answer:**
- For the `Box` class: ""YES, I found Data Class"" because all fields are public and almost all methods are getters/setters.

For the outer class `SaTokenContextForThreadLocalStorage`, although it handles the context and involves some operations, the internal `Box` class exhibits the Data Class smell:

**Conclusion:**
YES, I found Data Class in the `Box` class."
AbortedTransactionException.java,"NO, I did not find Data Class.

**Explanation:**
The provided class, `AbortedTransactionException`, does not have multiple fields; it primarily extends another exception class and provides constructors for initializing its message and cause. There are no getter or setter methods, and it does not expose any data directly or have many accessors. Instead, it includes constructors which are common in exception classes to allow flexible exception creation, but it does not show signs of being a Data Class."
HttpRequest.java,"Let's analyze the given Java file step-by-step for the ""Data Class"" code smell:

1. **Fields**:
   - The class `HttpRequest` contains several fields, such as `url`, `urlHandler`, `method`, `form`, `isMultiPart`, `cookie`, `connectionTimeout`, `readTimeout`, `redirectCount`, `maxRedirectCount`, `blockSize`, `proxy`, `hostnameVerifier`, `ssf`, `isDisableCache`, and `isRest`. These fields aren't public or package-private; they're private, which is generally good for encapsulation.
   - It also contains a private final field `interceptors` from `HttpInterceptor.Chain` class, used for request interception.

2. **Accessors**:
   - The class has several getter and setter methods, such as `getUrl()`, `setUrl(String url)`, `setUrl(UrlBuilder urlBuilder)`, `getMethod()`, `setMethod(Method method)`, `body(String body)`, etc.
   - Most of these methods are simple accessors, primarily for getting and setting the fields of the class.

3. **Methods and Behavior**:
   - The class contains methods like `execute()`, `executeAsync()`, `then(Consumer<HttpResponse> consumer)`, `post(String url)`, `get(String url)`, and others that perform actual work beyond just setting or getting fields.
   - It includes detailed logic for handling different types of HTTP methods, sending HTTP requests, managing timeouts, handling redirects, and more.

4. **Encapsulation**:
   - The class primarily keeps its fields private, which enforces encapsulation.
   - It exposes a set of methods to manipulate and retrieve the internal state, which abstracts the complexity behind simple accessor and modifier methods.

5. **Local Symptom Summary**:
   - While the class does have many fields and corresponding getter/setter methods, it also contains a significant amount of non-trivial behavior related to HTTP request handling, including request creation, sending, and receiving responses.

**Conclusion**:
The class `HttpRequest` does not look like a Data Class even though it has several fields and many accessor methods (getters/setters). The primary role of the class is not just to hold data; it performs substantial operations related to HTTP communication. Therefore, based on the provided analysis, the answer is:

NO, I did not find Data Class.

**Main Clarity**: The class has a significant amount of behavior related to HTTP operations, not just data storage and retrieval."
ProxyDatabaseMetaData.java,"Let's analyze the provided Java file for signs of the ""Data Class"" code smell:

### 1. Fields:
- The class `ProxyDatabaseMetaData` has a few fields: `connection` and `delegate`. These fields are used throughout the class but do not seem to be the primary focus of the class.

### 2. Accessors:
- The class does not explicitly have many getter or setter methods for its fields. Instead, it implements methods defined in the `DatabaseMetaData` interface, which often return `ResultSet` objects.

### 3. Methods and Behavior:
- Most methods are overriding methods from the `DatabaseMetaData` interface, which perform database-related operations like retrieving information about tables, columns, and procedures.
- There are methods such as `getConnection()` and `unwrap(Class<T> iface)` that return fields directly or perform simple operations, but these are part of the interface implementation.
- The class has meaningful behavior in the form of database operations that involve interacting with the database and returning data in the form of `ResultSet` objects.

### 4. Encapsulation:
- The class encapsulates the `connection` and `delegate` fields reasonably well. It does not expose these fields directly but provides a method to retrieve the `connection`.
- The primary behavior involves using these fields to perform operations that are necessary for the database interactions, thus encapsulating the data and operations related to those fields.

### 5. Local Symptom Summary:
- The class primarily performs operations related to the database through the `DatabaseMetaData` interface. It does not store or manage a large number of fields or provide simple accessors for them.
- It contains several methods that perform substantive work, such as querying the database and manipulating `ResultSet` objects.

### Conclusion:
NO, I did not find Data Class. The main sign is that the class is not primarily a data holder but rather performs substantial work related to database interactions through the `DatabaseMetaData` interface."
MethodCallInliner.java,"Let's analyze the provided Java file step by step according to the guidelines:

1. **Fields:**
   - The class `MethodCallInliner` defines several fields: `toBeInlined`, `blocks`, `inlining`, and `afterInlining`.
   - The nested class `CatchBlock` defines private fields: `start`, `handler`, `type`, and `end`.
   - Both classes use private fields, and `CatchBlock` exposes these fields through a constructor and getters.

2. **Accessors:**
   - `CatchBlock` has getter methods for all its fields: `getStart()`, `getHandler()`, `getType()`, and `getEnd()`.
   - There is no pattern of simple setter methods in this class.

3. **Methods and Behavior:**
   - `MethodCallInliner` has meaningful method implementations (`visitMethodInsn`, `visitTryCatchBlock`, `visitMaxs`, `visitFrame`), which are not just simple getters/setters and perform substantive work.
   - `MethodCallInliner` also has an abstract method `shouldBeInlined`, which indicates some form of expected behavior from subclasses.

4. **Encapsulation:**
   - The `MethodCallInliner` class encapsulates its data (`inlining`, `afterInlining`, `toBeInlined`, `blocks`) behind meaningful methods.
   - The nested `CatchBlock` class encapsulates its data with a private constructor and public getters, which is a good practice for encapsulation.

5. **Local Symptom Summary:**
   - `MethodCallInliner` does not seem like primarily a data holder. It has significant behavior and meaningful methods beyond just encapsulating data.
   - `CatchBlock` behaves more like a data holder, but it's a nested class with proper encapsulation and is not the focus of the outer class.

Given the analysis, while `CatchBlock` can be considered a simple data class, the main class `MethodCallInliner` does not exhibit patterns of a Data Class smell.

**Conclusion:**
NO, I did not find Data Class. The main class `MethodCallInliner` contains meaningful methods that perform substantive work, and `CatchBlock` is a properly encapsulated nested class."
IKArbitrator.java,"NO, I did not find Data Class.

The provided class `IKArbitrator` does not exhibit strong symptoms of a Data Class for the following reasons:

1. **Fields**: The class does not define many fields. It only contains a no-argument constructor and does not declare any fields that are public, package-private, or have corresponding getters/setters.

2. **Accessors**: The class does not have many simple getter and/or setter methods. It has no visible public methods other than `process()` which is not an accessor.

3. **Methods and Behavior**: The class contains more than just simple getters/setters; it includes methods like `process()`, `judge()`, `forwardPath()`, and `backPath()` that perform substantive work.

4. **Encapsulation**: The class does not expose its data extensively. All fields are implicitly private as Java classes default to package-private if no access modifier is used, and they are not directly accessible or manipulated outside the class. The methods are designed to perform specific functions rather than just expose data.

5. **Local Symptom Summary**: Based on the analysis, the class does not look like a primary data holder with minimal real behavior. It contains significant logic for handling lexeme paths and resolving lexical ambiguities.

Therefore, the class does not strongly indicate the presence of a Data Class."
SingleRoomBroadcastOperations.java,"Let's analyze the provided Java file based on the criteria for detecting a ""Data Class"" code smell:

1. **Fields:**
   - The file defines a class `SingleRoomBroadcastOperations` with several fields: `namespace`, `room`, `clients`, and `storeFactory`.
   - These fields are all private, which is a good sign for encapsulation. There are no public or package-private fields.

2. **Accessors:**
   - The class includes a method `getClients()` which is an accessor method.
   - There are no other getter or setter methods provided for the fields.

3. **Methods and Behavior:**
   - The class contains several methods (`send`, `disconnect`, `sendEvent`, etc.) that perform substantive work, such as sending packets to clients, managing disconnections, and handling events.
   - These methods contain logic that goes beyond simple field manipulation, suggesting the class has meaningful behavior.

4. **Encapsulation:**
   - The class encapsulates its data behind methods. Only the field `clients` is exposed through the `getClients()` method, and even this is wrapped in an `IterableCollection`.

5. **Local Symptom Summary:**
   - The class is not primarily a data holder because it includes several methods that perform significant operations and contain business logic.
   - The presence of behaviors such as sending packets, disconnecting clients, and handling events indicates that this class has meaningful functionality.

Based on this analysis:

**NO, I did not find Data Class.**

The main reason is that the class contains several methods that perform substantive work and are not limited to simple operations for field manipulation."
Lorem.java,"Let's analyze the provided Java file, `Lorem.java`, based on the criteria for the ""Data Class"" code smell:

### 1. Fields:
- The class has no instance fields defined other than the private final field `faker`. It does, however, have two static final fields `letters` and `characters`.
- Since there are no instance fields (attributes), this is not a strong indicator of a Data Class.

### 2. Accessors:
- The class does not have many simple getter and/or setter methods for fields, as it primarily focuses on behavior methods that generate random text data.

### 3. Methods and Behavior:
- The class has many methods that perform substantive work, such as generating random characters, words, sentences, paragraphs, and fixed-length strings.
- These methods are performing business logic related to text generation, not just data manipulation or retrieval.

### 4. Encapsulation:
- The class does hide its data behind meaningful services. The only data (in terms of fields) it exposes is through the `faker` field which is used internally for generating data.
- There are no methods that expose the static fields `letters` or `characters` directly. Instead, they are used within the class to generate data.

### 5. Local Symptom Summary:
- The class has very few to no fields that it exposes directly or via getters/setters.
- The methods it contains are not simple accessors; instead, they perform complex data generation tasks.

Based on the analysis above:

**NO, I did not find Data Class.**

The main reason is that the class contains methods that perform substantive work and does not primarily hold data with minimal real behavior."
HostAndPort.java,"Let's analyze the given Java file step by step according to the provided instructions:

1. **Fields**:
   - The class `HostAndPort` defines several fields: `host`, `port`, and `hasBracketlessColons`. None of these fields are public; they are private. There are getter methods for these fields, which is a good sign of encapsulation. However, since they have corresponding getter methods, this could suggest that they are meant to be accessed.

2. **Accessors**:
   - The class includes several accessor methods: `getHost()`, `hasPort()`, `getPort()`, and `getPortOrDefault(int defaultPort)`. These methods are simple and primarily used to access the private fields. There are not a superfluous number of getters, but the presence of getters is notable.

3. **Methods and Behavior**:
   - Beyond the accessor methods, the class includes methods like `fromParts(String host, int port)`, `fromHost(String host)`, `fromString(String hostPortString)`, `withDefaultPort(int defaultPort)`, `requireBracketsForIPv6()`, `equals(@Nullable Object other)`, `hashCode()`, and `toString()`. Most of these methods do substantive work, such as parsing strings, validating input, and handling built-in Java methods (`equals`, `hashCode`, `toString`).

4. **Encapsulation**:
   - The fields are encapsulated as private, and access to them is mainly provided through getter methods. This is in line with good object-oriented practice and suggests that the class is not exposing its data directly. However, the class itself represents a simple structure that holds and validates host and port information.

5. **Local Symptom Summary**:
   - The class primarily holds and manages host and port information, providing methods to construct and validate these values. It includes meaningful behavior beyond simple data access, such as parsing strings and performing validation.

Based on the analysis:

- The presence of many fields with corresponding getters **could** suggest a Data Class, but the significant presence of methods doing meaningful work mitigates this possibility.
- The class includes enough methods that perform substantive tasks beyond simple data access, which indicates the presence of behavior.
- The fields are properly encapsulated, which is not a behavior one expects to see in a Simple Data Class where fields might be public or have trivial accessors.

**Final Answer**:
NO, I did not find Data Class. The class includes meaningful behavior such as string parsing, validation, and more substantial methods beyond just getters/setters, and the data is properly encapsulated."
DefaultJSONParser.java,"Let's analyze this Java file step by step based on the criteria provided for identifying the ""Data Class"" code smell.

1. **Fields:**
   - The class `DefaultJSONParser` has many fields such as `input`, `strategy`, `lexer`, `context`, `resolveTaskList`, `dateFormatPattern`, `dateFormat`, etc. Some fields like `lexer` and `config` are marked as `final` or `protected`, but many are package-private.

2. **Accessors:**
   - There are numerous getter and setter methods for the fields. For example:
     - Getters: `getDateFomartPattern()`, `getDateFormat()`, `getSymbolTable()`, `getInput()`, `getConfig()`, `getResolveStatus()`, `getContext()`, `getOwnerContext()`, `getResolveTaskList()`, `getExtraProcessors()`, `getExtraTypeProviders()`, `getFieldTypeResolver()`.
     - Setters: `setDateFormat(String dateFormat)`, `setDateFormat(DateFormat dateFormat)`, `setConfig(ParserConfig config)`, `setResolveStatus(int resolveStatus)`, `setFieldTypeResolver(FieldTypeResolver fieldTypeResolver)`, `setContext(ParseContext context)`.

3. **Methods and Behavior:**
   - There are methods that do substantive work such as `parseObject()`, `parseArray()`, `parseExtra()`, `parse()`, `parseArrayWithType()`, `acceptType()`, `provideType()`, `handleResovleTask()`, `parseProperty()`, `parseArray()`, etc. These methods contain significant logic and are not mere getters or setters.
   
4. **Encapsulation:**
   - The class does not fully expose its fields; they are primarily accessed through its methods. While there are many getters and some setters, they are not the only methods in the class. Additionally, fields like `lexer`, `context`, and `config` are marked as `final` or `protected`, indicating some level of encapsulation.

5. **Local Symptom Summary:**
   - Though there are many fields and accessors, there are also multiple methods that perform substantial logic. The class has a significant amount of behavior beyond just providing access to its fields, so it does not strictly fit the profile of a Data Class.

**Conclusion:**  
NO, I did not find Data Class. The evidence suggests the class is primarily focused on parsing JSON and contains substantial behavior beyond just holding data."
AutoLocker.java,"NO, I did not find Data Class.

Based on the provided file, the class `AutoLocker` does not exhibit the symptoms of a Data Class. Here's the breakdown of the analysis:

1. **Fields:** The class has a few fields (`scheduler` and `vaultList`), but they are neither public nor exposed through many simple getters/setters.
2. **Accessors:** There are no public getters/setters. The only public method is `init()`, which is not an accessor.
3. **Methods and Behavior:** The class contains methods that execute meaningful work, such as `init()`, `tick()`, `autolock()`, and `exceedsIdleTime()`. These methods perform calculations, handle business logic, and interact with resources.
4. **Encapsulation:** The fields are well-encapsulated and accessed through methods that perform operations rather than directly.
5. **Local Symptom Summary:** The class is not primarily a data holder with minimal real behavior. Instead, it encapsulates behavior related to auto-locking vaults based on idle time."
ReedSolomonDecoder.java,"Let's analyze the Java file step-by-step for symptoms of the ""Data Class"" code smell:

1. **Fields:**
   - The file defines a class `ReedSolomonDecoder` with only one field: `private final GenericGF field;`
   - The field is not public, and there's no indication that additional fields exist based on the provided code snippet. The single field is encapsulated and used within methods.

2. **Accessors:**
   - There are no explicit getter or setter methods for the field `field`. The constructor initializes it, and it is used within methods but not exposed externally.
   - The class does not have many simple getter and/or setter methods.

3. **Methods and Behavior:**
   - The class contains several methods (`decode`, `runEuclideanAlgorithm`, `findErrorLocations`, `findErrorMagnitudes`) that perform significant computational tasks related to Reed-Solomon decoding.
   - The methods are not merely getters/setters, but they contain complex logic for error detection and correction.

4. **Encapsulation:**
   - The class encapsulates its data (`field`) and provides a meaningful service (`decode`) that performs substantive work using the data.
   - The data is not exposed publicly or through simple accessors.

5. **Local Symptom Summary:**
   - The class primarily contains methods that perform complex operations (error decoding) rather than merely storing and providing access to data.
   - There are no excessive or redundant getters and setters.
   - The class maintains good encapsulation by hiding its internal state and exposing only a method that performs a specific task.

**Final Answer:**
NO, I did not find Data Class. The class demonstrates significant behavior through its computational methods rather than simply holding and exposing data."
ExecutionSequencer.java,"Let's analyze the provided Java file step by step according to the criteria for detecting the ""Data Class"" code smell:

1. **Fields:**
   - The class `ExecutionSequencer` has multiple fields, such as `ref`, `latestTaskQueue`, and nested classes like `ThreadConfinedTaskQueue` and `TaskNonReentrantExecutor`, which themselves have their own fields.
   - The fields are not widely exposed as public or package-private. Instead, they are private. However, `ThreadConfinedTaskQueue` and `TaskNonReentrantExecutor` are classes (not data holders) that are part of the logic.

2. **Accessors:**
   - There are no simple getter or setter methods for the fields `ref` or `latestTaskQueue`. Instead, the class has methods like `submit` and `submitAsync` that perform operations related to these fields.
   - The nested classes have some fields with no associated getters or setters, for example, `thread`, `nextTask`, and `nextExecutor` in `ThreadConfinedTaskQueue`.

3. **Methods and Behavior:**
   - The class contains several methods (`submit`, `submitAsync`, and others within nested classes) that perform substantive work, managing the serialization of tasks and the execution logic.
   - Methods do not only get or set fields; they handle complex logic related to task execution, queuing, and state management.

4. **Encapsulation:**
   - The class encapsulates its data behind meaningful services. The internal state is managed and manipulated through methods like `submit` and `submitAsync` that handle task serialization and execution.
   - The data fields are private, and nested classes like `ThreadConfinedTaskQueue` and `TaskNonReentrantExecutor` are designed to maintain state within the context of task execution logic.

5. **Local Symptom Summary:**
   - The class is not primarily a data holder with minimal real behavior. It contains substantial logic for managing task execution and serialization.
   - There are no simple getter/setter methods, and the methods perform complex operations rather than just manipulate fields.

**Conclusion:**
NO, I did not find Data Class.

The `ExecutionSequencer` class contains significant behavior and logic related to the serialization and execution of tasks, and does not fit the pattern of a Data Class which mainly contains data with simple getters/setters without substantive behavior."
DirectedGraphConnections.java,"Let's analyze the given `DirectedGraphConnections` class based on the criteria provided for the ""Data Class"" code smell.

1. **Fields:**
   - The class defines several fields such as `adjacentNodeValues`, `orderedNodeConnections`, `predecessorCount`, and `successorCount`. 
   - These fields are used to store the state of connections in a directed graph, which is a common structure that holds data.

2. **Accessors:**
   - The class does not provide explicit getter or setter methods for its fields.
   - However, methods like `predecessors()`, `successors()`, `adjacentNodes()`, `value(N node)`, `removePredecessor(N node)`, `removeSuccessor(Object node)`, `addPredecessor(N node, V unused)`, and `addSuccessor(N node, V value)` serve a similar purpose as accessors, providing access to and modifying the internal state.

3. **Methods and Behavior:**
   - The methods in this class largely operate on the internal state to manage connections in the graph.
   - Methods such as `predecessors()`, `successors()`, `adjacentNodes()`, `incidentEdgeIterator(N thisNode)`, and `value(N node)` retrieve data or provide views on the data.
   - Some methods like `removePredecessor(N node)`, `removeSuccessor(Object node)`, `addPredecessor(N node, V unused)`, and `addSuccessor(N node, V value)` modify the data.
   - While there are methods performing operations, they mostly involve data manipulation and retrieval, not complex business logic or calculations.

4. **Encapsulation:**
   - The class encapsulates its data to some extent by providing methods to interact with the state rather than exposing the fields directly.
   - However, given the complexity of the internal data structure and the way methods interact with it, it’s still somewhat exposed through the numerous methods designed to access or modify the data.

5. **Local Symptom Summary:**
   - The class has several fields representing its internal state and provides many methods that essentially serve as complex getters and setters for these fields.
   - The methods mostly revolve around data retrieval and manipulation, with little indication of complex behavior or business logic.

**Final Answer:**
YES, I found Data Class. The main sign is that almost all methods are focused on data manipulation and retrieval, with very little complex behavior."
HttpServerTest.java,"### Step-by-Step Analysis

1. **Fields:**
   - The `TestServer` class inside the `HttpServerTest` file has several fields such as `response`, `uri`, `method`, `header`, `parms`, `parameters`, `files`, `decodedParamters`, `decodedParamtersFromParameter`, and `queryParameterString`. These fields are defined, mostly with public access, which is a sign of potential data class behavior.

2. **Accessors:**
   - The `TestServer` class does not have many explicitly defined getter and setter methods for its fields. However, since many fields are public, direct access without encapsulation is possible. This might be an indicator, but it’s not very strong as there are methods like `serve` that use these fields internally.

3. **Methods and Behavior:**
   - The `TestServer` class contains two specific methods: `createSession()` (two overloaded versions) and `serve()`. These methods represent significant behavior and are not just selecting or setting values of private fields. The `serve()` method, in particular, performs several actions like parsing requests, setting fields, and returning a response. Therefore, this class has methods with substantive work.

4. **Encapsulation:**
   - Since many fields in `TestServer` are public, the class does not adhere to the principles of encapsulation. Exposing internal state directly is characteristic of a data class. However, the lack of getter and setter patterns and the presence of meaningful methods (`serve`, `createSession`) slightly counteract this concern.

5. **Local Symptom Summary:**
   - The `TestServer` class has multiple public fields, which is a strong indicator of a data class. However, it also includes methods that perform meaningful work, particularly the `serve` method, which processes server requests. This behavior suggests that `TestServer` is more than just a data holder, and therefore, likely doesn't meet the criteria for a Data Class.

### Conclusion

**NO, I did not find Data Class.** The `TestServer` class has several public fields, which is a sign of potential data class behavior. However, it includes methods that perform substantive work, particularly the `serve` method, which processes server requests. This behavior contributes to the class being more than just a data holder."
ServiceLoader.java,"NO, I did not find Data Class.

**Explanation:**

1. **Fields:** The class `ServiceLoader` has a few private fields, `PREFIX` and `loadedUrls`, which are not directly exposed.

2. **Accessors:** There are no getter or setter methods for the fields. The class does not expose its fields directly.

3. **Methods and Behavior:** The class has two methods, `load` (overloaded), which perform substantive work such as loading service classes from URLs and processing input streams. This indicates that the class is involved in more than just holding and providing access to data.

4. **Encapsulation:** The class hides its data behind methods that perform meaningful operations, such as loading services and reading from URLs.

5. **Local Symptom Summary:** The class is not primarily a data holder with minimal real behavior. It contains fields but also contains methods that perform significant operations, suggesting it is not a Data Class."
JedisSentinelPool.java,"Let's analyze the `JedisSentinelPool` class based on the provided code for symptoms of a ""Data Class"":

### 1. Fields:
The class does define several fields, including:
- `JedisFactory factory;`
- `JedisClientConfig sentinelClientConfig;`
- `Collection<MasterListener> masterListeners;`
- `HostAndPort currentHostMaster;`
- `Object initPoolLock;`
These fields are not public or package-private; they are private, which is a good sign of encapsulation. However, there are several instance variables.

### 2. Accessors:
There is one getter method: `getCurrentHostMaster()`. There are no setter methods. Given the number of the fields, the existence of many setters would be more indicative of a Data Class, but there is only one public method and it is not a setter.

### 3. Methods and Behavior:
The class has several methods, including:
- Constructors (many overloaded variants).
- `initMaster(HostAndPort master)`.
- `initSentinels(Set<HostAndPort> sentinels, final String masterName)`.
- `toHostAndPort(List<String> getMasterAddrByNameResult)`.
- Overridden methods like `getResource()`, `returnResource(Jedis resource)`, and `destroy()`.
- Nested class `MasterListener` with its own methods, including constructors, getters/setters, and the `run()` method.

The majority of the methods perform meaningful work, such as initializing sentinels, handling connection logic, and managing thread communication. This is not consistent with a Data Class, which should have minimal real behavior.

### 4. Encapsulation:
The class encapsulates its fields well. The fields are private, and the only public method is a getter that exposes one field. The class provides meaningful behavior through its methods rather than just exposing data.

### 5. Local Symptom Summary:
The class does not look like a Data Class since it contains a significant amount of behavior and methods performing meaningful tasks. The fields are well-encapsulated, and there is no excessive focus on getters and setters.

### Conclusion:
NO, I did not find Data Class. The class contains substantial behavior and maintains good encapsulation."
SimpleEchoSocket.java,"Let's analyze the file step-by-step:

1. **Fields:**
   - The class `SimpleEchoSocket` defines several fields: `receivedMessages`, `toSendMessages`, and `closeLatch`.
   - These fields are private, which is a good sign of encapsulation, and not public or package-private. However, it does have getter methods for `receivedMessages` and `toSendMessages`.

2. **Accessors:**
   - There are simple getter methods for `receivedMessages` and `toSendMessages`.
   - No setter methods are present.
   - Other methods in the class are not simple accessors; they define behavior related to WebSocket operations.

3. **Methods and Behavior:**
   - The class contains methods such as `awaitClose`, `onClose`, `onConnect`, and `onMessage`, which are not just trivial getters/setters.
   - These methods perform operations related to WebSocket management and message handling, indicating some real behavior.

4. **Encapsulation:**
   - The data fields are private, and the class uses getter methods to expose data, which is a good practice of encapsulation.
   - However, the business logic methods (e.g., `onConnect`, `onMessage`) are exposed via annotations and called by the WebSocket framework, which is a form of exposing behavior, not just data.

5. **Local Symptom Summary:**
   - The class does have some accessors, but also contains significant behavior related to handling WebSocket events.
   - The private fields and getter pattern suggest a level of encapsulation.
   - The presence of methods with real behavior (other than simple accessors) suggests that the class is not purely a data holder.

**Conclusion:**
NO, I did not find Data Class.  
While the class does have fields and accessors, it also contains methods that perform substantive work, handling WebSocket events and performing actions relevant to these events."
RestAdapter.java,"### Analysis for Data Class Code Smell

Let's analyze the provided Java file, `RestAdapter.java`, for symptoms that may indicate the ""Data Class"" code smell.

#### 1. Fields
The class defines several fields:
```java
final Endpoint server;
final Executor httpExecutor;
final Executor callbackExecutor;
final RequestInterceptor requestInterceptor;
final Converter converter;
final Log log;
final ErrorHandler errorHandler;
private final Client.Provider clientProvider;
private final Profiler profiler;
private RxSupport rxSupport;
volatile LogLevel logLevel;
```
- **Observation:** There are multiple fields holding data, which is one of the signs of a Data Class.

#### 2. Accessors
The class has getter and setter methods for some of the fields:
```java
public void setLogLevel(LogLevel loglevel) {
  if (logLevel == null) {
    throw new NullPointerException(""Log level may not be null."");
  }
  this.logLevel = loglevel;
}

public LogLevel getLogLevel() {
  return logLevel;
}
```
- **Observation:** While there are a few getter and setter methods, they are not overwhelming. The class also has other methods that are not simple accessors.

#### 3. Methods and Behavior
The class contains methods that do significant work, such as:
- `create(Class<T> service)`
- `getMethodInfoCache(Class<?> service)`
- Methods within the inner class `RestHandler` including `invoke` and `invokeRequest`
- `logAndReplaceRequest`
- `logAndReplaceResponse`
- `logException`
- `getRequestInfo`
- Methods within the nested `Builder` class such as `setEndpoint`, `build`, etc.
- **Observation:** There are many methods that perform substantial tasks, not just simple field operations, indicating non-trivial behavior.

#### 4. Encapsulation
The class encapsulates its data:
- Fields are mostly private or final.
- It provides a `Builder` class for construction, indicating controlled access and initialization.
- **Observation:** The class tries to encapsulate its state, which is contrary to the Data Class pattern where fields are usually public or accessible via simple getters/setters without much additional logic.

#### 5. Local Symptom Summary
- The class does hold data and does expose some data through accessors. However, it also contains substantial behavior in the form of methods that handle request invocation, logging, and error handling.
- The methods are not just getters and setters; they perform significant operations and interactions with other classes and systems.

#### Conclusion
**NO, I did not find Data Class.**  
While the class does have several fields and some getter/setter methods, it also contains many methods that perform significant operations, making it a full-fledged service class rather than a simple data holder."
