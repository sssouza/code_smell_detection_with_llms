file_path,analysis
AccessControlLogEntry.java,"1. Inheritance Pattern:
- This class does not extend any explicit parent class; it implements the Serializable interface. (Implicit parent is java.lang.Object.)

2. Use of Inherited Functionality:
- The only inherited method overridden is toString() from Object. It does not call super.toString() or access any inherited protected/stateful members. There are no uses of super. or other parent-state interactions.

3. New/Independent Functionality:
- Yes. The class defines many own fields (count, reason, context, object, username, ageSeconds, clientInfo, logEntry), constants, a constructor that parses a Map, getters, and a private parsing helper getMapFromRawClientInfo(String). These represent its own data/behavior for ACL log entries.

4. Breadth of Subclass:
- The class is non-trivial: several fields, constants, getters, a parsing method, and a custom toString() — not a light extension.

5. Local Symptom Summary:
- Because this class does not extend a non-trivial parent (only Object) and implements its own full data/behavior, there is no evidence here of a subclass refusing a meaningful parent contract. The single override (toString) is self-contained and not a weak passthrough.

Final verdict:
NO, I did not find Refused Bequest. Evidence: the class does not extend another concrete superclass (only implements Serializable/implicitly extends Object) and implements its own fields/methods; only overrides toString()."
Preconditions.java,"1. Inheritance Pattern:  
   This file defines ""public final class Preconditions"" and it does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:  
   Not applicable — there is no superclass to inherit from in this file, so there are no overrides, no super. calls, and no interaction with inherited state.

3. New/Independent Functionality:  
   The class introduces many static utility methods (checkArgument, checkState, checkNotNull, index/position checks, etc.) and a static initialization block. Those are independent utility responsibilities, but they are not subclass-specific since this is not a subclass.

4. Breadth of Subclass:  
   Not applicable — the class is non-trivial (lots of methods/overloads) but it is not a subclass.

5. Local Symptom Summary:  
   There are no symptoms of Refused Bequest in this file because no inheritance is used; the clearest sign is simply the absence of a superclass.

NO, I did not find Refused Bequest."
FileRefreshableDataSource.java,"1. Inheritance Pattern:
- Yes. The class FileRefreshableDataSource<T> extends AutoRefreshDataSource<String, T>.

2. Use of Inherited Functionality:
- It meaningfully uses and overrides inherited behavior:
  - Overrides readSource(), isModified(), and close(). These are substantive overrides (readSource implements file reading logic; isModified checks file.lastModified; close clears buffer and calls super.close()).
  - Calls super.close() in close().
  - Uses inherited getProperty().updateValue(...) in firstLoad() to push loaded config into the parent-managed property.
- None of the overrides are trivial one-liners delegating only to super; they implement core, file-specific behavior.

3. New/Independent Functionality:
- Introduces several file-specific fields: buf, charset, file, lastModified (and constants for buffer/charset/refresh).
- Adds constructors and firstLoad(), plus file-reading logic in readSource(). These are specific responsibilities for reading and parsing a file source.

4. Breadth of Subclass:
- The subclass is non-trivial: multiple fields, multiple constructors, and several non-trivial methods. It is more than a light extension.

5. Local Symptom Summary:
- The subclass does not show strong symptoms of Refused Bequest. It implements required methods from the parent, interacts with inherited state (getProperty, super.close), and provides file-specific implementations for core behaviors (reading source, detecting modification). This looks like a proper specialization rather than a refusal to honor the parent’s contract.

Final verdict:
NO, I did not find Refused Bequest."
SaSecureUtil.java,"1. Inheritance Pattern:  
- This file defines class SaSecureUtil. It does not declare ""extends"" — it implicitly extends java.lang.Object.

2. Use of Inherited Functionality:  
- Not applicable: there are no instance methods, no overrides, and no calls to super.*. All functionality is provided via static methods and private static fields.

3. New/Independent Functionality:  
- Yes. The class introduces many cryptography-related fields and methods (Base64 encoder/decoder, MD5/SHA/AES/RSA utilities, key generation and helper byte/hex routines). These are self-contained utility responsibilities.

4. Breadth of Subclass:  
- The class is non-trivial (many fields and many methods covering multiple crypto domains). However it is not a subclass at all.

5. Local Symptom Summary:  
- Because SaSecureUtil does not extend any user-defined parent (only Object) there is no subclass-parent relationship to refuse. The class is a large, independent utility rather than a subclass misusing inherited behavior.

NO, I did not find Refused Bequest. (Reason: no inheritance beyond Object, so no subclass that could ""refuse"" a parent's bequest.)"
ClassLoaderCommand.java,"1. Inheritance Pattern:
- Yes. This file defines ""ClassLoaderCommand"" which extends the parent class AnnotatedCommand.

2. Use of Inherited Functionality:
- The class overrides the core lifecycle method: @Override public void process(CommandProcess process). That override is substantial (contains the main command logic) rather than a trivial one-liner. 
- There are no calls to super.process(...) or other super.* usages visible. No direct use of protected fields/members from AnnotatedCommand can be observed in this file (but we only have this file).

3. New/Independent Functionality:
- The subclass introduces many fields (isTree, hashCode, classLoaderClass, all, resource, includeReflectionClassLoader, listClassLoader, loadClass, isInterrupted, logger) and many helper methods (processClassLoaderStats, processClassLoaders, processResources, getAllClasses, getAllClassLoaderInfo, etc.) implementing classloader-specific behaviors (listing classloaders, resources, stats, building trees, filters, etc.). These are significant and specific responsibilities, but they are appropriate for a concrete command implementation.

4. Breadth of Subclass:
- Yes — the class is non-trivial: many fields, many private/static inner classes, and many helper methods. It is a full-featured command implementation rather than a simple marker.

5. Local Symptom Summary:
- The class does not show the classic symptom of Refused Bequest. It overrides the parent’s core abstract/contractual method (process) with substantial behavior appropriate to a command. While it adds a lot of new functionality, that is expected for a concrete command subclass and the override is meaningful rather than trivial.

Final verdict:
NO, I did not find Refused Bequest. Main reason: the subclass provides a substantial, meaningful override of the parent’s core method (process) and implements command-specific behavior expected from an AnnotatedCommand subclass."
AclException.java,"1. Inheritance Pattern:
- Yes. The file defines class AclException that extends RuntimeException.

2. Use of Inherited Functionality:
- It does not override any RuntimeException methods. The only interaction with the parent is via constructors that call super(...) to set the exception message/throwable. No use of super.method(...) beyond that, and no direct interaction with inherited protected state or behavior.

3. New/Independent Functionality:
- The subclass adds two fields (status, code) with corresponding getters/setters and constructors that initialize them. Those members represent extra metadata attached to the exception.

4. Breadth of Subclass:
- The class is small but non-trivial: a couple of fields, multiple constructors, and simple accessors. It is not a large class, but it does introduce its own state and API.

5. Local Symptom Summary:
- This subclass mostly relies on RuntimeException for exception behavior and only adds contextual fields (status, code). It does not ignore or contradict the parent's contract; the added functionality is typical for domain-specific exceptions.

NO, I did not find Refused Bequest — the class simply extends RuntimeException and adds contextual fields/constructors (typical for custom exceptions); it does not show the pattern of extending a class while ignoring or contradicting its responsibilities."
GeneralAppIdDecoder.java,"1. Inheritance Pattern:
- This file defines final class GeneralAppIdDecoder.
- It does not explicitly extend any other class (it only implicitly extends java.lang.Object).

2. Use of Inherited Functionality:
- There are no method overrides, no uses of super., and no interactions with inherited protected state — because the class does not subclass a non-Object type.

3. New/Independent Functionality:
- The class declares its own fields (information, current, buffer) and implements many decoding responsibilities: decodeAllCodes, decodeGeneralPurposeField, parseBlocks, parseNumericBlock, parseIsoIec646Block, parseAlphaBlock, many helper decode/isStill/... methods, etc. These are substantial, self-contained responsibilities for parsing/decoding bit arrays.

4. Breadth of Subclass:
- The class is non-trivial: dozens of methods and internal logic. It is a full-featured decoder, not a thin wrapper or marker.

5. Local Symptom Summary:
- Because this class does not extend a parent other than Object, it cannot exhibit Refused Bequest in this file. The code shows a standalone decoder with many proprietary fields and methods rather than a subclass ignoring a parent's contract.

NO, I did not find Refused Bequest — the class does not extend another class (no inherited API to refuse) and implements its own full decoding logic."
DuplicateRemovedScheduler.java,"NO, I did not find Refused Bequest

1. Inheritance Pattern:  
- This file defines an abstract class DuplicateRemovedScheduler that implements the Scheduler interface (it does not extend another concrete class). Parent type: Scheduler.

2. Use of Inherited Functionality:  
- It overrides the Scheduler.push(Request, Task) method (annotated with @Override) and provides non-trivial logic for duplicate filtering.  
- It does not call super. anywhere (there is no superclass implementation to delegate to).  
- The override is substantive (checks shouldReserved, noNeedToRemoveDuplicate, and duplicatedRemover.isDuplicate) rather than a trivial one-liner delegating to super.

3. New/Independent Functionality:  
- The class introduces its own state and behavior relevant to duplicate removal: a Logger, a DuplicateRemover field with getter/setter, and helper methods shouldReserved(Request), noNeedToRemoveDuplicate(Request), and pushWhenNoDuplicate(Request, Task). These represent specialization for duplicate-filtering scheduling, which aligns with the Scheduler role rather than being unrelated functionality.

4. Breadth of Subclass:  
- The class is non-trivial: it defines fields, multiple helper methods, and core push logic. It’s an abstract base intended to be extended (pushWhenNoDuplicate is empty/protected for subclasses to implement), so it provides shared behavior rather than being a tiny marker.

5. Local Symptom Summary:  
- The class specializes the Scheduler contract by implementing meaningful push behavior focused on duplicate removal, provides configuration (DuplicateRemover), and exposes hooks for subclasses. These are consistent uses of the inherited interface, not signs of refusing the parent's responsibilities.

Main evidence: meaningful override of push with duplicate-removal logic and added helper/state aligned with the Scheduler role — therefore not Refused Bequest."
SaTokenException.java,"1. Inheritance Pattern:
- Yes. The class SaTokenException extends RuntimeException.

2. Use of Inherited Functionality:
- It does not override any RuntimeException behavior (no overridden methods like getMessage(), etc.).  
- The only interactions with the parent are constructor delegations (super(message), super(cause), super(message, cause)), which are trivial and expected for an exception subclass. No use of super. fields or protected parent state is present.

3. New/Independent Functionality:
- It introduces a serialVersionUID and two static convenience methods: throwBy(boolean, String) and throwByNull(Object, String). These methods are small helpers that construct/throw SaTokenException under conditions. They are related to creating/throwing this exception, not a separate domain.

4. Breadth of Subclass:
- The class is small: three constructors, two static helpers, and one serialVersionUID field. This is a light extension rather than a large, unrelated feature set.

5. Local Symptom Summary:
- I do not see symptoms of Refused Bequest. The class provides trivial constructor delegation to the parent and a couple of exception-related helper methods; it does not introduce a broad, unrelated responsibility nor ignore the parent's contract.

Final verdict:
NO, I did not find Refused Bequest — only trivial constructor delegation to RuntimeException and small, exception-related helper methods are present."
LinkedTreeMap.java,"1. Inheritance Pattern:  
Yes. The file defines class LinkedTreeMap<K,V> extends AbstractMap<K,V> (and implements Serializable). The parent class is AbstractMap.

2. Use of Inherited Functionality:  
The subclass overrides many core AbstractMap methods (size(), get(), containsKey(), put(), clear(), remove(), entrySet(), keySet()). These overrides are substantial full implementations (not trivial one-liners or mere super.method() calls). It implements the Map contract rather than delegating to the parent.

3. New/Independent Functionality:  
Yes — it declares its own fields (comparator, root, size, modCount, header), a Node inner class, many tree-manipulation methods (find, removeInternal, rebalance, rotateLeft/rotateRight, etc.), iterators, EntrySet and KeySet classes, and serialization helper. However, this functionality is directly related to providing a tree-backed Map implementation (i.e., related to the parent's domain).

4. Breadth of Subclass:  
The subclass is non-trivial: numerous fields, internal classes, and many methods implementing AVL-tree+linked-list behavior and iteration support.

5. Local Symptom Summary:  
No symptom of Refused Bequest: the class provides many meaningful overrides and a full, coherent implementation of map behavior rather than ignoring or lightly overriding inherited functionality. The clearest sign that this is not Refused Bequest is the large number of substantive method overrides and domain-specific internal machinery implementing the Map contract.

NO, I did not find Refused Bequest"
SocketIOChannelInitializer.java,"1. Inheritance Pattern:
- Yes. The class extends ChannelInitializer<Channel>. The parent class is ChannelInitializer (io.netty.channel.ChannelInitializer).

2. Use of Inherited Functionality:
- The subclass overrides the key abstract method initChannel(Channel) — a substantial override that implements the pipeline setup logic. It also overrides handlerAdded(ChannelHandlerContext) to call scheduler.update(ctx). It does not call super.* in these overrides, but the initChannel override meaningfully implements the parent’s required contract (initializing the ChannelPipeline).

3. New/Independent Functionality:
- The class introduces many fields (ackManager, clientsBox, authorizeHandler, xhrPollingTransport, webSocketTransport, scheduler, packetHandler, sslContext, configuration, etc.) and methods (start(...), addSslHandler(...), addSocketioHandlers(...), createSSLContext(...), onDisconnect(...), stop(), etc.). These represent substantial socket.io-specific initialization, SSL setup, transport/handler wiring, lifecycle and disconnect handling.

4. Breadth of Subclass:
- The subclass is non-trivial: it contains multiple fields and many methods. It’s clearly more than a light extension or marker class.

5. Local Symptom Summary:
- Although the class adds a lot of its own responsibilities, it does meaningfully implement the parent’s core contract by providing a substantive initChannel implementation (setting up the pipeline). The added functionality supports channel initialization and connection lifecycle, so it appears aligned with the parent role rather than refusing it.

NO, I did not find Refused Bequest. The class provides a substantial, appropriate override of initChannel and uses the parent’s intended responsibility (channel initialization), even though it adds many related fields/methods."
JobGroupController.java,"1. Inheritance Pattern:
- This file defines class JobGroupController, and it does NOT extend any other class (no ""extends"" clause). Parent class: none.

2. Use of Inherited Functionality:
- Not applicable: there is no superclass, so there are no inherited methods/fields to override, call via super., or use.

3. New/Independent Functionality:
- The class declares DAO fields and many controller methods (index, pageList, save, update, remove, loadById, findRegistryByAppName) implementing validation, persistence calls, and request handling — all self-contained responsibilities.

4. Breadth of Subclass:
- Not applicable as a subclass, but the class is non-trivial (multiple fields and substantial methods).

5. Local Symptom Summary:
- Because there is no inheritance here, there are no symptoms of Refused Bequest in this file.

Final verdict:
NO, I did not find Refused Bequest. Reason: JobGroupController does not extend a parent class, so the refused-bequest pattern cannot apply."
ApiException.java,"1. Inheritance Pattern:  
Yes. The class ApiException extends RuntimeException.

2. Use of Inherited Functionality:  
No meaningful overrides of inherited behavior. The class only calls super(...) from its constructors to set message/cause; it does not override methods like getMessage(), nor does it access or modify inherited state beyond those constructor calls. Those uses are minor and standard.

3. New/Independent Functionality:  
It introduces one new field (IErrorCode errorCode), a constructor that accepts an IErrorCode and sets the message from it, and a getter getErrorCode(). This is focused on carrying an error-code payload for the exception (closely related to exception responsibilities).

4. Breadth of Subclass:  
The subclass is small and focused: one extra field, one getter, and a specialized constructor (plus standard exception constructors). It is not a large unrelated class.

5. Local Symptom Summary:  
NO, I did not find Refused Bequest — evidence: only minor, appropriate use of the parent (constructor super calls), with a small, cohesive extension (one errorCode field and getter) that augments exception semantics rather than refusing the parent's contract."
SaOAuth2Template.java,"1. Inheritance Pattern:
- This file defines public class SaOAuth2Template and it does NOT extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:
- Not applicable: there is no parent class, so there are no overrides, no calls to super., and no interaction with inherited state or protected members.

3. New/Independent Functionality:
- The class introduces a large set of OAuth2-related methods (generate/check/save/get/delete/revoke/convert/random/splicingKey, etc.). These are substantial, domain-specific responsibilities implemented locally.

4. Breadth of Subclass:
- The class is non-trivial: it contains many methods covering many aspects of OAuth2 token lifecycle. (It defines no new fields, but the method surface is large.)

5. Local Symptom Summary:
- Because the class does not extend any parent, there are no inheritance relationships to refuse. The code shows substantial independent functionality but no inherited members to ignore.

Final verdict:
NO, I did not find Refused Bequest. Evidence: the class does not extend a parent (no overrides or super usage), so the Refused Bequest pattern cannot apply here."
ReplyMessageProcessorTest.java,"1. Inheritance Pattern:
- This file defines class ReplyMessageProcessorTest with no explicit ""extends"" clause. It therefore does not extend any user-defined parent class (only implicitly extends java.lang.Object).

2. Use of Inherited Functionality:
- Not applicable: there are no method overrides, no calls to super., and no direct interaction with inherited/protected members (since there is no declared parent class other than Object).

3. New/Independent Functionality:
- The class declares multiple fields (mocks/spies, topic/group strings, client info) and several test/helper methods (init, testProcessRequest_Success, createSendMessageRequestHeaderCommand, createSendMessageRequestHeader, createResponse). These are independent test behaviors unrelated to any inherited contract.

4. Breadth of Subclass:
- Not applicable as it is not a subclass. The class is non-trivial (multiple fields and methods) but it is a test class, not an extension of another domain class.

5. Local Symptom Summary:
- There are no signs of Refused Bequest because no inheritance from a meaningful parent class is present; thus the key symptom (a subclass ignoring or misusing a parent’s members) cannot occur here.

Final conclusion:
NO, I did not find Refused Bequest. Evidence: ReplyMessageProcessorTest does not extend any parent class (no overrides or super.calls), so there is no subclass/parent relationship to refuse."
NodeTraversor.java,"1. Inheritance Pattern:  
- This file defines ""public class NodeTraversor"". It does not explicitly extend any class, so it only implicitly extends java.lang.Object.

2. Use of Inherited Functionality:  
- There are no overrides of parent methods, no calls to super., and no direct interaction with inherited state. All methods are static utility methods; nothing here customizes inherited behavior.

3. New/Independent Functionality:  
- The class introduces several static traversal/filter methods (traverse and filter overloads) and implements substantial traversal logic dealing with Node, Element, NodeVisitor, and NodeFilter. This is self-contained functionality unrelated to any parent contract.

4. Breadth of Subclass:  
- Not applicable as a subclass. The class is non-trivial (multiple methods with non-trivial logic), but it is a standalone utility class rather than a light extension of a parent.

5. Local Symptom Summary:  
- No signs of Refused Bequest: the class does not extend another concrete class nor override or ignore inherited behavior; it is a standalone utility class with its own responsibilities.

NO, I did not find Refused Bequest."
DirectoryBrowserSupport.java,"1. Inheritance Pattern:  
- Yes. The file defines an inner class BuildChildPaths that extends MasterToSlaveCallable<List<List<Path>>, IOException>. (No other top-level class in this file extends another class; DirectoryBrowserSupport implements HttpResponse but does not extend a class.)

2. Use of Inherited Functionality:  
- BuildChildPaths overrides call(). The override is short and simply delegates to the static buildChildPaths(cur, locale) method. It does not call super.call() or otherwise interact with inherited state or additional inherited methods. The override is therefore small/trivial (a single-purpose implementation of the callable contract).

3. New/Independent Functionality:  
- BuildChildPaths introduces fields (root, cur, locale) and a constructor to capture state for remote execution, and its call() implements the task of building child paths. This is a focused, new responsibility (packaging work to run remotely), but it’s narrowly scoped and tied to DirectoryBrowserSupport’s needs rather than representing a large unrelated domain.

4. Breadth of Subclass:  
- The subclass is minimal: one constructor, three fields, and one overridden method. It is not a large class with many unrelated fields/methods.

5. Local Symptom Summary:  
- No strong symptoms of Refused Bequest. The only extending class (BuildChildPaths) provides a concise implementation of the callable contract to run a DirectoryBrowserSupport-specific task remotely. Although the override is simple (delegation), this is the expected use of MasterToSlaveCallable. There are not many new fields/methods, and the functionality is coherent with the parent’s purpose (being a callable).

NO, I did not find Refused Bequest. Evidence: the single subclass is a small, focused callable override (single call() implementation) used to run a DirectoryBrowserSupport task remotely rather than a large subclass that ignores or refuses its parent’s contract."
ExcelWriter.java,"1. Inheritance Pattern:
- The file defines class ExcelWriter which does not explicitly extend any user-defined class. It therefore implicitly extends java.lang.Object.

2. Use of Inherited Functionality:
- The only inherited method overridden is finalize() from Object. finalize() calls finish() and logs exceptions; it does not invoke super.finalize().
- There are no uses of super.* elsewhere and no interaction with inherited state beyond that single finalize override. The override is small and lifecycle-related (not a deep specialization of a parent contract).

3. New/Independent Functionality:
- The class introduces its own field (excelBuilder) and many constructors and methods (write, fill, merge, finish, writeContext, etc.) implementing Excel-writing behavior. These represent substantial, independent responsibilities unrelated to Object.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields, many overloaded constructors, many public API methods — clearly more than a light extension.

5. Local Symptom Summary:
- Because the class only inherits from Object (no meaningful parent contract to refuse) and only overrides a small lifecycle method, there is no sign of Refused Bequest. The class implements its own functionality rather than ignoring a meaningful parent's members.

NO, I did not find Refused Bequest. (Main evidence: no non-trivial parent class is extended—only Object; only a small finalize() override exists while the class defines its own substantial behavior.)"
MethodInfo.java,"1. Inheritance Pattern:
- This file defines class MethodInfo which does not explicitly extend any other class. Its implicit parent is java.lang.Object.

2. Use of Inherited Functionality:
- There are no overrides of Object methods (no toString, equals, hashCode, finalize, etc.), no calls to super., and no direct interaction with inherited state. So it does not use or override parent functionality.

3. New/Independent Functionality:
- The class introduces its own fields (owner, access, name, desc) and simple getter/setter methods. These are self-contained data-holder responsibilities.

4. Breadth of Subclass:
- The class is small and trivial (a plain DTO with four fields and accessors), not a wide, complex subclass.

5. Local Symptom Summary:
- There are no symptoms of Refused Bequest: the class does not meaningfully inherit or refuse a parent contract (it only extends Object implicitly) and simply defines its own small, expected data-related behavior.

NO, I did not find Refused Bequest."
ApolloDataSourceFactoryBean.java,"1. Inheritance Pattern:
- The file defines class ApolloDataSourceFactoryBean which implements the interface FactoryBean<ApolloDataSource>. It does not extend another class.

2. Use of Inherited Functionality:
- As an implementer of FactoryBean it provides the required methods getObject() and getObjectType(). These methods are meaningful: getObject() constructs and returns a new ApolloDataSource using the class's fields; getObjectType() returns the target type. There is no use of super.* (and interfaces have no inherited state), so there is no ignored parent state — the class correctly implements the interface contract.

3. New/Independent Functionality:
- The class introduces fields (namespaceName, flowRulesKey, defaultFlowRuleValue, converter) and corresponding getters/setters. These are configuration properties used to create the ApolloDataSource; they represent the factory’s responsibilities rather than unrelated functionality.

4. Breadth of Subclass:
- The class is small but non-trivial: several fields plus multiple accessor methods and two core FactoryBean methods. The added members are cohesive and tied to the bean-creation role.

5. Local Symptom Summary:
- There are no signs of Refused Bequest. The class implements the FactoryBean contract and actively uses its own fields to create the target object rather than ignoring inherited behavior.

NO, I did not find Refused Bequest. Evidence: implements FactoryBean and implements its methods meaningfully (creates ApolloDataSource from its own configuration fields)."
UmsMemberService.java,"1. Inheritance Pattern:  
   This file defines an interface (UmsMemberService), not a class that extends another class. It does not extend any other interface here.

2. Use of Inherited Functionality:  
   Not applicable — there is no subclass in this file, so there are no overrides, uses of super., or interactions with inherited fields to inspect.

3. New/Independent Functionality:  
   The interface declares multiple member-management and authentication methods (register, generateAuthCode, updatePassword, loadUserByUsername, login, refreshToken, etc.), but these are API method signatures rather than a subclass introducing new fields or unrelated responsibilities.

4. Breadth of Subclass:  
   Not applicable — there is no subclass. The interface is non-trivial (many methods) but that does not indicate a refused bequest pattern.

5. Local Symptom Summary:  
   No evidence of Refused Bequest in this file: it does not contain a subclass that could refuse a parent's members.

NO, I did not find Refused Bequest. (File is an interface, not a subclass extending/ignoring a parent.)"
BillboardParticleBatch.java,"1. Inheritance Pattern:
- Yes. The class is declared as ""public class BillboardParticleBatch extends BufferedParticleBatch<BillboardControllerRenderData>"".
- Parent class name: BufferedParticleBatch.

2. Use of Inherited Functionality:
- The subclass overrides several parent methods: allocParticlesData, begin, flush, getRenderables, save, load. The constructor calls super(BillboardControllerRenderData.class) and begin() calls super.begin().
- It accesses inherited state/contract: it uses renderData, bufferedParticlesCount, and camera (presumably provided by the parent), and obeys the parent’s lifecycle contract (allocParticlesData/flush/getRenderables).
- Many overrides are substantial (flush implements the core vertex building and mesh submission, allocParticlesData allocates per-particle arrays, several fill* methods use renderData). Only begin() is a small override but still calls super.begin() and does additional clearing.

3. New/Independent Functionality:
- Yes. The class introduces many new fields (TMP_* vectors and matrix, GPU/CPU vertex attribute constants, vertices[], indices[], renderablePool, renderables, currentVertexSize/currentAttributes, texture, blendingAttribute, depthTestAttribute, shader, mode/useGPU flags, etc.) and many specialized methods (allocIndices, allocRenderable, allocShader, initRenderData, setVertexData, setUseGpu/setAlignMode, setTexture, many fillVertices* methods).
- These members implement detailed billboard rendering behavior (vertex formats, GPU vs CPU paths, alignment modes, mesh and shader allocation) that is specific to billboard particle rendering.

4. Breadth of Subclass:
- The subclass is non-trivial: dozens of fields, many helper methods, and complex logic for building vertices for multiple alignment/mode paths. It is a full-featured renderer implementation, not a light extension or marker.

5. Local Symptom Summary:
- The subclass does not appear to refuse the parent’s responsibilities: it actively uses inherited state (renderData, bufferedParticlesCount, camera), overrides core lifecycle methods to implement rendering behavior, and calls super appropriately. The large amount of new rendering-specific code is a specialization of particle-batch responsibilities rather than an unrelated domain.

NO, I did not find Refused Bequest — evidence: many substantial overrides (especially flush) and direct use of inherited fields like renderData, bufferedParticlesCount and camera, while adding rendering-specific functionality."
BrokerController.java,"1. Inheritance Pattern:  
- This file defines ""public class BrokerController"" and it does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:  
- Not applicable: there are no overridden methods, no uses of super., and no direct interaction with inherited state because no parent class is declared in this file.

3. New/Independent Functionality:  
- The class defines many fields (configs, managers, executors, services, queues, messageStore, remoting servers, hooks, etc.) and many methods that implement broker lifecycle, registration, scheduling, RPC processor registration, transaction and ACL initialization, etc. These represent substantial, independent responsibilities.

4. Breadth of Subclass:  
- The class is large and non-trivial with many fields and methods; however, since it is not a subclass there is no subclass-specific breadth to evaluate against a parent.

5. Local Symptom Summary:  
- There are many new fields and lots of unrelated logic, but because BrokerController does not extend any parent class in this file, there is no evidence of Refused Bequest (which requires an inheritance relationship where the subclass refuses inherited behavior).

NO, I did not find Refused Bequest."
StringUtils.java,"1. Inheritance Pattern:
- This file defines an abstract class StringUtils. It does not explicitly extend any other class; it therefore extends java.lang.Object implicitly.

2. Use of Inherited Functionality:
- There are no method overrides of any parent methods, no calls to super.*, and no interaction with inherited state beyond the implicit Object behavior. The only constructor is a trivial default constructor (public StringUtils() {}).

3. New/Independent Functionality:
- The class defines many static utility fields (PAD_LIMIT, INDEX_NOT_FOUND) and a large number of static methods for string manipulation, tokenization, formatting, etc. These represent substantial, independent functionality specific to string utilities.

4. Breadth of Subclass:
- The class is non-trivial: it contains dozens of methods and some constants—clearly more than a light extension or marker class.

5. Local Symptom Summary:
- The class does not extend or reuse any meaningful superclass API (only Object implicitly), so there is no evidence of a subclass refusing a parent’s bequest in the usual sense. The class is a standalone utility holder, not a subclass that ignores an inherited contract.

Conclusion:
NO, I did not find Refused Bequest. Evidence: No explicit superclass (only Object), no overrides or super usage, and the class is a large, independent utility provider."
PacketEncoder.java,"1. Inheritance Pattern:
- The file defines class PacketEncoder with signature ""public class PacketEncoder"" — it does not extend any other class explicitly (only implicitly extends java.lang.Object).

2. Use of Inherited Functionality:
- There are no method overrides and no calls to super.* in this class. It does not interact with inherited state or override Object methods in any meaningful way.

3. New/Independent Functionality:
- The class defines many fields and methods for packet encoding (buffer allocation, JSONP encoding, base64 handling, numeric-to-bytes utilities, etc.). These are self-contained responsibilities specific to encoding.

4. Breadth of Subclass:
- PacketEncoder is non-trivial: many constants, utility methods, and complex encoding logic. However, this breadth is not an extension of some parent type here (no parent other than Object).

5. Local Symptom Summary:
- Refused Bequest is not applicable because the class does not extend a domain parent class whose behavior it would be expected to use or override. The clearest sign is simply the absence of inheritance beyond Object (no overrides, no super usage), so there is no evidence of a subclass refusing a parent's bequest.

NO, I did not find Refused Bequest."
FastByteArrayOutputStream.java,"1. Inheritance Pattern:  
Yes — the class FastByteArrayOutputStream extends java.io.OutputStream.

2. Use of Inherited Functionality:  
The subclass overrides core OutputStream methods: write(byte[], int, int) and write(int), providing concrete implementations that append to an internal buffer. It also overrides close() to be a no-op. It does not call super.* or access any inherited fields (OutputStream has no relevant protected state to use). The write overrides are substantive (they implement the stream behavior); close() is a small/trivial override.

3. New/Independent Functionality:  
The class introduces a FastByteBuffer field and several buffer-related methods: size(), reset(), writeTo(OutputStream), toByteArray(), and multiple toString(...) overloads. These methods provide buffering and conversion utilities — functionality that complements the OutputStream role rather than being an unrelated responsibility.

4. Breadth of Subclass:  
The subclass is non-trivial: it has a private final buffer field and multiple helper methods (size, reset, writeTo, toByteArray, toString variants). This is more than a marker or a tiny extension.

5. Local Symptom Summary:  
The subclass implements the core responsibilities expected of an OutputStream (concrete write behavior, buffering, writeTo, conversions). While close() is overridden to no-op (a minor change), the class otherwise meaningfully implements inherited behavior and uses its own buffer to fulfill the stream contract.

Final verdict:  
NO, I did not find Refused Bequest. Evidence: meaningful overrides of write(...) implementing the OutputStream contract and added buffer-related methods that align with the stream’s responsibilities (only a trivial close() override)."
BinaryRedisPipeline.java,"1. Inheritance Pattern:
- This file defines an interface (public interface BinaryRedisPipeline). It does not extend any other interface or class in this file, so there is no parent class name here.

2. Use of Inherited Functionality:
- Not applicable: since this is an interface that does not extend another interface, there are no inherited methods or fields being overridden, called, or specialized (no use of super.*, no overrides).

3. New/Independent Functionality:
- The interface declares a large number of methods (Redis binary command responses). These are the interface's own API members, not additional independent fields or methods added by a subclass. There is no evidence of a subclass introducing unrelated state or responsibilities.

4. Breadth of Subclass:
- Not applicable: there is no subclass in this file. The interface is extensive (many methods), but that reflects a broad contract rather than a subclass adding unrelated functionality.

5. Local Symptom Summary:
- Because this file contains an interface with no parent and no subclass behavior, there are no local symptoms of Refused Bequest (no subclass extends and then refuses inherited responsibilities).

NO, I did not find Refused Bequest."
LineTransformationOutputStream.java,"1. Inheritance Pattern:  
   Yes — this file defines an abstract class LineTransformationOutputStream that extends java.io.OutputStream. It also declares an abstract static nested class Delegating that extends LineTransformationOutputStream.

2. Use of Inherited Functionality:  
   The subclass meaningfully overrides core OutputStream methods: write(int), write(byte[],int,int) and close(). The implementations provide non-trivial behavior (line buffering, detecting LF, delegating multi-byte writes to write(int), handling end-of-line). The Delegating subclass calls super.close() and delegates flush/close to its underlying out stream. There are no purely trivial overrides that ignore the parent contract (only Delegating.flush is a one-liner delegate, which is appropriate).

3. New/Independent Functionality:  
   The class introduces its own buffer field (ByteArrayOutputStream2), an abstract eol(byte[],int) callback, helper methods (forceEol, trimEOL), and internal logic to buffer and process lines. These are new responsibilities but clearly focused on transforming output stream data by line, i.e., consistent with OutputStream behavior.

4. Breadth of Subclass:  
   The class is non-trivial: multiple methods and a field, plus a nested Delegating subclass. It’s a substantial extension rather than a trivial marker.

5. Local Symptom Summary:  
   The subclass specializes OutputStream with substantial, cohesive line-buffering and transformation logic, overrides core methods meaningfully, and the Delegating subclass properly composes an underlying stream. There is no indication that it ignores or refuses the parent’s responsibilities.

Final verdict: NO, I did not find Refused Bequest. Evidence: the class meaningfully overrides and implements OutputStream behavior (line buffering/eol handling) and Delegating properly delegates to the underlying OutputStream."
RedissonObject.java,"1. Inheritance Pattern:
- This file defines ""public abstract class RedissonObject implements RObject"". It does not extend any explicit parent class (only implicitly java.lang.Object). It implements the RObject interface.

2. Use of Inherited Functionality:
- Because it does not extend a concrete superclass, there are no calls to super.* or overrides of superclass behavior. It does implement many interface methods from RObject (getName, rename/renameAsync, sizeInMemory/sizeInMemoryAsync, migrate/copy, delete/unlink/touch/isExists, dump/restore, addListener/removeListener, etc.) and uses its own fields (commandExecutor, codec, name) to provide non-trivial implementations (not trivial one-line super calls).

3. New/Independent Functionality:
- The class declares fields (commandExecutor, name, codec) and many helper/util methods (encode, encodeMapKey/Value, encodeMapKeys/Values, getLockByMapKey/getLockByValue, toStream, toSeconds, get helper for futures, various Async wrappers and Lua eval helper). Those represent substantial functionality and responsibilities related to command execution, encoding and Redis-specific operations — but they appear to be the core responsibilities expected for an RObject implementation rather than unrelated features.

4. Breadth of Subclass:
- The class is non-trivial: many fields and many methods (synchronous and asynchronous operations, encoding helpers, listener management). It's more than a light extension or marker.

5. Local Symptom Summary:
- Refused Bequest is not applicable here: the class does not extend a parent class and it provides concrete implementations for many interface methods rather than ignoring inherited behavior. The methods are substantial and focused on the expected responsibilities (command execution, encoding, Redis operations).

Final verdict:
NO, I did not find Refused Bequest. Evidence: the class does not extend another class (implements RObject), implements many interface methods with substantial logic (no trivial super-only overrides), and its added fields/methods align with the RObject responsibilities."
DokanyVolume.java,"1. Inheritance Pattern:  
Yes. The class DokanyVolume extends AbstractVolume.

2. Use of Inherited Functionality:  
Yes. DokanyVolume calls super(choosers) in its constructor, assigns to the inherited mountPoint field (this.mountPoint = determineMountPoint()), and calls inherited helper methods determineMountPoint() and cleanupMountPoint(). It overrides several lifecycle methods (mount, unmount, unmountForced, reveal, isSupported, supportsForcedUnmount, getImplementationType) with non-trivial implementations (not mere one-liners delegating to super).

3. New/Independent Functionality:  
It introduces fields and behavior specific to Dokany mounting: vaultSettings, mount, FS_TYPE_NAME, and logic around MountFactory, DokanyMountFailedException handling, and reveal/unmount calls to the Mount object. These are specialized but clearly concern mounting behavior, i.e., specialization of volume mounting for Dokany.

4. Breadth of Subclass:  
The subclass is non-trivial: several new fields and multiple overridden methods implementing the mount/unmount/reveal lifecycle and mount-point requirement. This is more than a light extension.

5. Local Symptom Summary:  
No strong symptom of Refused Bequest. The clearest sign against the smell is that the subclass both overrides core lifecycle methods with concrete implementations and uses inherited state/methods (determineMountPoint, cleanupMountPoint, mountPoint) rather than ignoring them.

NO, I did not find Refused Bequest. Evidence: many meaningful overrides and direct use of inherited state/methods (determineMountPoint, cleanupMountPoint, mountPoint), not just unrelated new logic."
AnalysisContext.java,"1. Inheritance Pattern:
- This file defines an interface (AnalysisContext). It does not declare a class that extends another class, nor does it extend any other interface.

2. Use of Inherited Functionality:
- Not applicable: there is no subclass present, so there are no overrides, no calls to super., and no use of inherited fields or methods in this file.

3. New/Independent Functionality:
- The interface declares many methods (holders, deprecated accessors, etc.), but these are part of the API contract, not a subclass introducing independent fields or responsibilities.

4. Breadth of Subclass:
- Not applicable: there is no subclass. The interface itself is non-trivial (many methods), but that does not indicate a subclass refusing a parent's bequest.

5. Local Symptom Summary:
- No symptoms of Refused Bequest in this file because it does not define a subclass that could refuse an inherited contract. The clearest sign is simply that this is an interface (no ""extends"" class, no overrides or super usage).

NO, I did not find Refused Bequest."
ClassLoaderModel.java,"YES, I found Refused Bequest — many new fields/methods; only a trivial override (getType()); no use of super or inherited state.

Step-by-step:

1. Inheritance Pattern:
- Yes. The class is ""ClassLoaderModel"" and it extends ""ResultModel"".

2. Use of Inherited Functionality:
- Minimal. The only visible interaction with the parent is an override of getType() that returns the string ""classloader"".
- No calls to super.*, no apparent use of inherited fields or methods beyond that trivial override.

3. New/Independent Functionality:
- Yes. The subclass defines many classloader-specific fields (classSet, resources, loadClass, urls, classLoaders, tree, classLoaderStats, matchedClassLoaders, classLoaderClass) and corresponding getters/setters (fluent setters).
- These members represent a distinct responsibility (classloader reporting/modeling) not indicated as reusing parent behavior.

4. Breadth of Subclass:
- Non-trivial. Multiple fields and many accessor/mutator methods indicate substantive added functionality rather than a light extension.

5. Local Symptom Summary:
- The file shows symptoms of Refused Bequest: it extends ResultModel but barely uses or customizes inherited behavior (only a trivial getType override) while introducing substantial, unrelated state and methods (classloader-specific model data)."
MethodRoadie.java,"1. Inheritance Pattern:
- This file defines class MethodRoadie but it does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:
- Not applicable: there is no superclass, so there are no overrides, no use of super., and no interaction with inherited members.

3. New/Independent Functionality:
- Yes. MethodRoadie declares its own fields (test, notifier, description, testMethod) and many methods (run, runWithTimeout, runTest, runBeforesThenTestThenAfters, runTestMethod, runBefores, runAfters, addFailure) implementing test execution, timeout handling, and before/after invocation logic — substantial, self-contained responsibilities.

4. Breadth of Subclass:
- The class is non-trivial: multiple methods and logic, not a light wrapper or marker.

5. Local Symptom Summary:
- There are no symptoms of Refused Bequest in this file because the class does not extend a parent to inherit from. The class contains substantial independent functionality but no inherited members to refuse.

NO, I did not find Refused Bequest — the class does not extend any superclass, so refused bequest cannot occur here."
StubConnection.java,"1. Inheritance Pattern:
- Yes. The class is StubConnection and it extends StubBaseConnection.

2. Use of Inherited Functionality:
- It references an inherited member named throwException repeatedly (used to decide whether to throw SQLException in many overrides). There are no calls to super.method(...) in this file, but the class does use inherited state (throwException). Many methods are overridden to implement/alter behavior; a few overrides are trivial (return null or empty implementation), but several provide non-trivial behavior (e.g., unwrap, prepareStatement returning StubPreparedStatement, isValid calling refreshConnectionWaitTimeout).

3. New/Independent Functionality:
- The subclass introduces several fields and behaviors: count, slowCreate, oldDriver, isClosed, foo, autoCommit, isolation, catalog, waitTimeout, a scheduled executor and timeout task, and a refreshConnectionWaitTimeout mechanism. It also constructs StubPreparedStatement instances and implements connection lifecycle semantics (autoCommit, transaction isolation, wait-timeout scheduling). These are substantial and specific to connection behavior.

4. Breadth of Subclass:
- The class is non-trivial: many fields and many overridden methods (most of the java.sql.Connection API methods are implemented here), plus scheduling logic and state management. It is more than a light extension or marker.

5. Local Symptom Summary:
- The subclass does not appear to be refusing the parent's bequest. It uses an inherited field (throwException) and purposefully overrides many connection methods to implement stubbed connection behavior. While some overrides are trivial, the class contains substantial, connection-related functionality rather than unrelated responsibilities.

Conclusion:
NO, I did not find Refused Bequest. Evidence: the subclass uses inherited state (throwException) and implements many connection-related behaviors (timeout scheduling, auto-commit, prepareStatement), so it is extending and specializing connection behavior rather than ignoring the parent’s contract."
ExpandedProductParsedResult.java,"1. Inheritance Pattern:
- Yes. The class is ExpandedProductParsedResult which extends ParsedResult.

2. Use of Inherited Functionality:
- It calls super(ParsedResultType.PRODUCT) in the constructor.
- It overrides getDisplayResult(), equals(Object) and hashCode(). There are no other uses of super. or direct interaction with inherited protected state in this file. The overrides are meaningful (getDisplayResult provides product-specific display; equals/hashCode implement logical equality for this subclass).

3. New/Independent Functionality:
- Yes. The class introduces many product-specific fields (rawText, productID, sscc, lotNumber, productionDate, packagingDate, bestBeforeDate, expirationDate, weight, weightType, weightIncrement, price, priceIncrement, priceCurrency, uncommonAIs) and corresponding getters, plus constructor and equality/hash methods — clearly product-specific responsibilities.

4. Breadth of Subclass:
- Non-trivial: many fields and accessor methods plus constructor and equality/hash implementations. It is more than a light extension.

5. Local Symptom Summary:
- This subclass primarily provides a concrete specialization for product parsed results: it sets the parsed-result type, implements getDisplayResult, and encapsulates lots of product-specific state and behavior. Although it only lightly interacts with parent members (constructor call and overrides), that is consistent with intentionally specializing an abstract/base ParsedResult.

Conclusion:
NO, I did not find Refused Bequest — the class appears to be a focused specialization of ParsedResult for product data (many new fields/methods but purposeful overrides like getDisplayResult and proper use of the parent type), not a subclass that refuses the parent's contract."
SaFoxUtil.java,"1. Inheritance Pattern:
- The file defines a class `SaFoxUtil`. It does not declare an `extends` clause, so it does not explicitly extend any user-defined class; it inherits from `java.lang.Object` implicitly.

2. Use of Inherited Functionality:
- There are no method overrides, no uses of `super.`, and no interaction with inherited/protected state from a superclass. All members are static utility methods and a static constant; no inherited behavior is customized.

3. New/Independent Functionality:
- The class introduces many static utility methods (string/URL helpers, list/array conversions, random/string/date utilities, encoding/decoding) and a constant `URL_REGEX`. These represent independent, general-purpose utilities rather than specialization of a parent class’s responsibilities.

4. Breadth of Subclass:
- The class is non-trivial: it contains many methods (search, joinParam, encode/decode, conversions, random generators, etc.). However, it is a standalone utility class rather than a lightweight extension of a parent.

5. Local Symptom Summary:
- There is no subclassing here, so the Refused Bequest smell cannot apply. The clearest sign is that the class is a large collection of static utilities and does not extend or override any superclass behavior.

NO, I did not find Refused Bequest."
Stage.java,"1. Inheritance Pattern:
- Yes. The class Stage extends InputAdapter (and implements Disposable). Parent class name: InputAdapter.

2. Use of Inherited Functionality:
- Stage overrides many input methods inherited via InputAdapter (touchDown, touchDragged, touchUp, mouseMoved, scrolled, keyDown, keyUp, keyTyped). The overrides are full implementations that route events into the stage/actor system (not trivial one-liners nor just calls to super). There are no calls to super.method(), but the subclass clearly uses the input-processing contract provided by InputAdapter.

3. New/Independent Functionality:
- Yes. Stage introduces many fields and methods for viewport and camera management, batching/drawing, a root Group, touch/pointer state arrays, touch-focus management, debug drawing, coordinate transforms, actor hit testing, etc. These represent substantial stage/scene-graph and rendering responsibilities.

4. Breadth of Subclass:
- The class is large and non-trivial, with many fields and methods — far more than a light extension or marker subclass.

5. Local Symptom Summary:
- No strong symptoms of Refused Bequest. Although Stage defines a lot of its own functionality, it meaningfully uses the inherited input-processing role by overriding many input methods to implement event distribution to actors. The clearest sign against the smell: many substantial overrides of the parent's input methods rather than ignoring them.

Final verdict:
NO, I did not find Refused Bequest. Evidence: Stage provides substantial, non-trivial overrides of InputAdapter's input methods to implement the class's core behavior, so it is making appropriate use of the parent contract."
Finance.java,"1. Inheritance Pattern:  
   - This file defines ""public class Finance"" and it does not explicitly extend any other class. It therefore only inherits implicitly from java.lang.Object.

2. Use of Inherited Functionality:  
   - There are no overrides of parent methods (no toString/equals/hashCode/etc.), no calls to super.*, and no direct interaction with inherited state beyond the default Object behaviour. So there is no meaningful use of inherited functionality.

3. New/Independent Functionality:  
   - The class introduces its own state and responsibilities: a private final Faker faker field, a large static Map of IBAN patterns, and many finance-related methods (creditCard, bic, iban, calculateIbanChecksum, etc.). These are self-contained finance utilities and not related to any parent contract.

4. Breadth of Subclass:  
   - The class is non-trivial: multiple methods, helper utilities, and a large data map (countryCodeToBasicBankAccountNumberPattern). It is a substantial, independent component.

5. Local Symptom Summary:  
   - Because this class does not extend a non-trivial parent (only Object) there is no evidence of a subclass refusing a parent's bequest. The class contains many independent members and no overridden/inherited usage to suggest Refused Bequest.

Final verdict: NO, I did not find Refused Bequest."
AdminBrokerProcessor.java,"1. Inheritance Pattern:
- Yes. The class AdminBrokerProcessor extends AsyncNettyRequestProcessor (and also implements NettyRequestProcessor).

2. Use of Inherited Functionality:
- It overrides processRequest(...) and rejectRequest().
- processRequest contains a large switch and delegates to many private methods; it does not call super.processRequest(...) and there are no obvious uses of super.* anywhere else in the file.
- rejectRequest() is trivial (returns false) — a one-liner override.
- No protected fields/methods from the parent are referenced in this file (based on the available source).

3. New/Independent Functionality:
- The class introduces a single field brokerController and many private methods implementing a wide range of broker admin behaviors (topic config, subscription group management, offsets, stats, ACL config, consumer calls, message manipulation, runtime info, etc.). These methods interact heavily with BrokerController, MessageStore, ConsumerManager, etc., representing substantial broker-admin responsibilities not apparent from the parent class name.

4. Breadth of Subclass:
- The subclass is large and non-trivial: dozens of private methods and significant logic, handling many RequestCode cases and complex interactions with broker subsystems. It is far more than a light extension.

5. Local Symptom Summary:
- The subclass shows symptoms consistent with Refused Bequest: it extends AsyncNettyRequestProcessor but does not meaningfully leverage or call parent functionality (no super calls, trivial rejectRequest override), while introducing a large amount of independent broker-admin logic and fields.

Final verdict:
YES, I found Refused Bequest — evidence: many new broker-specific fields/methods and complex logic while overriding parent methods without calling or using parent behavior (no super.* usage; trivial rejectRequest)."
PreparedStatementHandler.java,"1. Inheritance Pattern:  
- Yes. The class is PreparedStatementHandler and it extends BaseStatementHandler.

2. Use of Inherited Functionality:  
- The subclass overrides multiple methods from the parent (update, batch, query, queryCursor, instantiateStatement, parameterize).  
- It makes substantial use of inherited protected fields and collaborators (boundSql, mappedStatement, executor, parameterHandler, resultSetHandler, etc.).  
- Overrides are not trivial one-liners or mere calls to super; they provide concrete behavior (casting to PreparedStatement, calling execute/addBatch, handling generated keys, setting parameters, returning results).

3. New/Independent Functionality:  
- The class declares no new fields.  
- Its methods implement behavior specific to PreparedStatement usage (instantiating PreparedStatement with correct options, executing, handling keys/results), which is a clear specialization of statement handling rather than an unrelated responsibility.

4. Breadth of Subclass:  
- The class is non-trivial (several method overrides) but those methods are cohesive and focused on prepared-statement responsibilities.

5. Local Symptom Summary:  
- The subclass does not show symptoms of Refused Bequest: it implements multiple meaningful overrides and heavily uses inherited state to fulfill the parent's contract; it adds no unrelated fields or domains.

Final decision:
NO, I did not find Refused Bequest — the class meaningfully specializes BaseStatementHandler (multiple concrete overrides and heavy use of inherited fields) rather than refusing the parent's responsibilities."
SmsFlashPromotionProductRelationServiceImpl.java,"NO, I did not find Refused Bequest

1. Inheritance Pattern:
- This class does not extend another class. It implements the interface SmsFlashPromotionProductRelationService (so its compile-time parent is Object, not a concrete superclass).

2. Use of Inherited Functionality:
- There are no superclass methods or fields being overridden or referenced (no super. calls). The file only implements interface methods; no inherited behavior is present to be used or refused.

3. New/Independent Functionality:
- The class declares two injected fields (relationMapper, relationDao) and implements CRUD/list/count methods that use those collaborators. These are the expected responsibilities of a service implementation rather than unrelated functionality.

4. Breadth of Subclass:
- The class is non-trivial in the sense it has several methods, but they are straightforward service operations (create, update, delete, getItem, list, getCount) and not an unrelated domain.

5. Local Symptom Summary:
- No symptoms of Refused Bequest: the class does not extend a parent to refuse inherited behavior. Clear sign: it implements an interface and contains expected service logic using DAOs/mappers, with no superclass overrides or ignored protected members."
PrefixPluginLogger.java,"1. Inheritance Pattern:
- Yes. The class PrefixPluginLogger extends org.apache.logging.log4j.spi.ExtendedLoggerWrapper.

2. Use of Inherited Functionality:
- It calls the superclass constructor (super(...)) and overrides logMessage(...). The override asserts the incoming marker is null and forwards to super.logMessage(...) but substitutes its own Marker. There is no use of protected parent fields or other inherited state; the class primarily delegates to the parent for the actual logging.

3. New/Independent Functionality:
- The class introduces its own static WeakHashMap<String, Marker> markers, an instance Marker field, a constructor that manages/creates markers, a prefix() accessor, and a markersSize() helper. Those are significant and implement marker-prefix management logic.

4. Breadth of Subclass:
- Non-trivial: several fields and methods (static marker map, instance marker, constructor logic, two helper methods, and the logMessage override).

5. Local Symptom Summary:
- Although the class adds several new fields/methods, the added functionality is directly about logging (managing and injecting a prefix Marker). It overrides and delegates to the parent to perform logging. This is an adaptation/wrapper of the parent behavior, not a refusal to use the parent’s responsibility.

Final verdict:
NO, I did not find Refused Bequest. Evidence: the subclass overrides and delegates to super.logMessage and its new members implement a logging-specific concern (marker prefixing) rather than an unrelated domain."
BitMatrix.java,"1. Inheritance Pattern:
- The file defines ""public final class BitMatrix implements Cloneable"". It does not extend any application-specific parent class (implicitly extends java.lang.Object). It implements the Cloneable marker interface.

2. Use of Inherited Functionality:
- There is no custom superclass whose protected members would be inherited/unused. The class overrides standard Object methods: equals(Object), hashCode(), toString(), and clone(). These are normal, small overrides related to object identity/representation and cloning; there are no calls to super.* except the lack of use is expected because the superclass is Object. No inherited non-Object functionality is being used.

3. New/Independent Functionality:
- The class introduces its own fields (width, height, rowSize, bits) and many methods implementing bit-matrix functionality (get/set/unset/flip, parse, xor, clear, setRegion, getRow/setRow, rotate180, getEnclosingRectangle, etc.). These are self-contained responsibilities for managing a 2D bit matrix.

4. Breadth of Subclass:
- The class is non-trivial: many fields and many methods (parsing, manipulation, queries, I/O-related toString builders, cloning). It's a full-featured utility class.

5. Local Symptom Summary:
- Because BitMatrix does not extend a domain superclass (only Object) and only implements a marker interface, there are no signs of a subclass inheriting behavior and then refusing it. The class defines and uses its own state and functionality.

Conclusion:
NO, I did not find Refused Bequest — the class does not extend a meaningful parent (only Object), so the Refused Bequest smell cannot apply here."
JobTriggerPoolHelper.java,"1. Inheritance Pattern:  
   - The file defines ""public class JobTriggerPoolHelper"" with no explicit ""extends"" clause. Its only parent is the implicit java.lang.Object.

2. Use of Inherited Functionality:  
   - There are no method overrides, no calls to super., and no use of protected/inherited state from a non-Object parent. Only default Object behavior would be inherited and is not used specially.

3. New/Independent Functionality:  
   - The class introduces its own thread pools (fastTriggerPool, slowTriggerPool), timing/timeout state (minTim, jobTimeoutCountMap), and many methods (start, stop, addTrigger, static helper and facade methods). These are substantial, self-contained responsibilities (thread-pool and trigger management).

4. Breadth of Subclass:  
   - The class is non-trivial: multiple fields, several methods, and internal logic for choosing pools, tracking timeouts, and executing triggers. It is more than a light extension.

5. Local Symptom Summary:  
   - Because this class does not extend any meaningful parent (only Object), there is no opportunity here for a subclass to refuse a parent's bequest. The class contains substantial independent functionality.

Final verdict:
NO, I did not find Refused Bequest."
MigrationRunController.java,"1. Inheritance Pattern:
- This file declares ""public class MigrationRunController implements FxController"". It implements the FxController interface; it does not extend any other class. Therefore there is no parent class to inspect here.

2. Use of Inherited Functionality:
- Because MigrationRunController does not extend a superclass, there are no inherited methods/fields from a parent class to override or call via super. It likely implements an interface method (initialize()), but there are no super.method() calls and no evidence of interacting with inherited state from a superclass.

3. New/Independent Functionality:
- The class introduces many fields (Stage window; Vault vault; ExecutorService executor; ScheduledExecutorService scheduler; KeychainManager keychain; various Scene Lazies; bindings and properties; an ErrorComponent.Builder; a NiceSecurePasswordField) and many methods (initialize, back, migrate, migrationProgressChanged, migrationRequiresInput, loadStoredPassword, several property getters). These represent substantial migration-UI and task-handling responsibilities local to this class.

4. Breadth of Subclass:
- The class is non-trivial: numerous fields, scheduled tasks, error-handling branches, background task wiring, FXML interaction, and state transitions. It is a full-featured controller, not a light extension or marker.

5. Local Symptom Summary:
- Refused Bequest is not applicable here because the class does not extend a parent class. All functionality appears self-contained, and there are no superclass members that are being ignored or weakly used.

Final verdict:
NO, I did not find Refused Bequest."
Internet.java,"1. Inheritance Pattern:
- This file defines class Internet but it does not declare ""extends ..."". It implicitly extends java.lang.Object only.

2. Use of Inherited Functionality:
- There are no overrides of parent methods (no toString/equals/hashCode or other overrides), and no uses of super. The class does not call or customize any inherited behavior beyond Object's defaults.

3. New/Independent Functionality:
- The class declares one field (private final Faker faker) and many methods providing Internet-related functionality (email, domain, url, avatar, image, password, MAC/IP generation, slug, uuid, user agent, etc.). These are substantial, self-contained behaviors unrelated to any parent contract (since there is no parent beyond Object).

4. Breadth of Subclass:
- The class is non-trivial: many methods and behaviors are implemented, so it is a large, standalone utility-like component.

5. Local Symptom Summary:
- Because the class does not extend any other user-defined parent (only Object), there is no evidence of a subclass refusing a parent's bequest. The clearest fact: no ""extends"" clause, no overrides, no super.* usage; the class simply implements many independent responsibilities.

NO, I did not find Refused Bequest."
AllMembersSupplier.java,"1. Inheritance Pattern:  
Yes. The file defines class AllMembersSupplier which extends ParameterSupplier.

2. Use of Inherited Functionality:  
AllMembersSupplier overrides the abstract method getValueSources(ParameterSignature) (annotated @Override) and provides a non-trivial implementation that builds a list of PotentialAssignment values. It does not call super.* anywhere, nor access any inherited fields visible in this file. The override is substantive (it orchestrates many helper methods) and not a trivial one-liner calling super.

3. New/Independent Functionality:  
Yes. The class introduces a private final TestClass clazz field, an inner static MethodParameterValue class, and many helper methods (addSinglePointFields, addMultiPointFields, addSinglePointMethods, addMultiPointMethods, addDataPointsValues, addArrayValues, addIterableValues, getStaticFieldValue, isAssignableToAnyOf, and several protected getter-style methods). These methods implement reflection-based discovery/processing of data points and are specific behavior for supplying parameters.

4. Breadth of Subclass:  
The subclass is non-trivial: it contains several helper methods, an inner class, and state (clazz). It is a substantial concrete implementation rather than a light wrapper.

5. Local Symptom Summary:  
No clear symptoms of Refused Bequest. The class implements the expected ParameterSupplier contract by providing a meaningful override of getValueSources and contains logic directly related to supplying parameter values (reflection over data points). Although it does not call super, that is typical for implementing an abstract supplier method rather than refusing inherited responsibilities.

Conclusion: NO, I did not find Refused Bequest. Evidence: substantive override of the abstract getValueSources and many methods implementing the supplier role (many new methods but they implement the parent's intended responsibility)."
AwtCodec.java,"1. Inheritance Pattern:  
- This file defines class AwtCodec which implements two interfaces: ObjectSerializer and ObjectDeserializer. It does not extend any other class (only implicit java.lang.Object).

2. Use of Inherited Functionality:  
- There is no superclass, so there are no inherited protected members or fields being overridden/used. The class implements interface methods (write, deserialze, getFastMatchToken) and does not call super.* anywhere. The implemented methods are substantive, not trivial one-line super-calls.

3. New/Independent Functionality:  
- Yes. AwtCodec introduces many methods and logic specific to serializing/deserializing AWT types: writeClassName, parseFont, parseColor, parseRectangle, parsePoint, parseRef, support, plus a public static instance field. These represent self-contained responsibilities for AWT object handling.

4. Breadth of Subclass:  
- The class is non-trivial: several parsing methods, branching logic for different AWT classes, and detailed token handling — clearly more than a light extension or marker.

5. Local Symptom Summary:  
- Because AwtCodec does not extend a concrete parent class, the Refused Bequest smell (subclass inheriting but refusing the parent’s behavior) cannot be observed here. The class implements interfaces and provides its own comprehensive functionality.

Final verdict: NO, I did not find Refused Bequest."
OrderController.java,"1. Inheritance Pattern:
- This file defines class OrderController, which does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:
- Not applicable: there is no superclass, so there are no inherited methods or fields to override, call via super., or use.

3. New/Independent Functionality:
- Yes. OrderController declares several constants and fields (jdbcTemplate, restTemplate, random) and implements multiple methods: order(...), calculate(...), invokerAccountService(...). These perform DB inserts, remote HTTP calls, and business logic.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields, a constructor, a main endpoint method with SQL PreparedStatementCreator and KeyHolder usage, helper methods, and HTTP client code.

5. Local Symptom Summary:
- Because OrderController does not extend another class, there is no inheritance relationship to evaluate for Refused Bequest. Although the class contains substantial independent functionality, that is not evidence of Refused Bequest in this file.

NO, I did not find Refused Bequest"
XxlJobInfoDao.java,"1. Inheritance Pattern:  
- This file defines a public interface XxlJobInfoDao. It does not declare ""extends"" and therefore does not extend any other class or interface.

2. Use of Inherited Functionality:  
- Not applicable: there is no subclass here, so there are no overrides, no use of super., and no interaction with inherited fields or methods in this file.

3. New/Independent Functionality:  
- The interface declares DAO methods (pageList, save, loadById, update, delete, etc.) related to job info persistence and scheduling. These are its own API contract rather than added unrelated responsibilities.

4. Breadth of Subclass:  
- Not applicable (no subclass). The interface is non-trivial in number of methods, but they are cohesive DAO responsibilities.

5. Local Symptom Summary:  
- There is no subclass that inherits and refuses a parent's behavior in this file. The file merely declares a DAO interface with related methods.

Final verdict:
NO, I did not find Refused Bequest. Evidence: the file defines an interface (no inheritance/extends) and contains DAO methods only — there is no subclass extending a parent to inspect for refused bequest symptoms."
ConnectionPool.java,"1. Inheritance Pattern:  
- This file defines an abstract class ConnectionPool<T extends RedisConnection>. It does not extend any other class (implicitly extends java.lang.Object). No parent class name is present.

2. Use of Inherited Functionality:  
- Not applicable: since ConnectionPool does not extend a concrete parent class, there are no inherited (protected) members from a superclass being ignored or used. The only “inheritance-like” constructs are an inner abstract static AcquireCallback that implements Runnable and BiConsumer, and an anonymous subclass of that inner class, which properly implements run() and accept() — but that's interface implementation, not subclassing a parent class with a contract to be honored.

3. New/Independent Functionality:  
- The class introduces many fields (entries, connectionManager, config, masterSlaveEntry) and many methods for connection lifecycle, initialization, acquiring/releasing, reconnection logic, scheduling checks, etc. These are substantial, but they are the intended responsibilities of this pool class rather than evidence of refusing a parent’s contract.

4. Breadth of Subclass:  
- The class is non-trivial (many methods and interactions). However, again it is not a subclass of any custom parent in this file.

5. Local Symptom Summary:  
- There is no evidence of Refused Bequest in this file because ConnectionPool does not extend another concrete class with inherited members to be refused. The class defines and implements its own responsibilities and does not show the symptom ""extends but ignores parent"" here.

NO, I did not find Refused Bequest."
LinkedHashMultimap.java,"1. Inheritance Pattern:  
Yes — the class is declared as
  public final class LinkedHashMultimap<K, V> extends LinkedHashMultimapGwtSerializationDependencies<K, V>
so the parent class name is LinkedHashMultimapGwtSerializationDependencies.

2. Use of Inherited Functionality:  
The subclass calls the parent constructor (super(...)) and invokes a number of inherited methods (e.g., super.replaceValues(...), super.entries(), super.keySet(), super.values(), super.clear()). Some overrides are trivial/pass-through (entries(), keySet(), values(), replaceValues() simply call super). However, several overrides provide substantial new behavior (createCollection(), createCollection(K), entryIterator(), valueIterator(), spliterators, clear combined with multimap-specific cleanup). It also calls inherited helper setMap(map) during deserialization — so it does use parent functionality alongside its own.

3. New/Independent Functionality:  
Yes — the class introduces many new fields and responsibilities: valueSetCapacity, multimapHeaderEntry, inner static ValueEntry class, inner ValueSet class (with its own hash table, linked-list logic, iterators, modCount, rehashing, etc.), serialization logic, and helper static methods to maintain linked lists. These represent significant new, independent behavior (maintaining insertion order of entries and per-key value-sets).

4. Breadth of Subclass:  
Yes — the subclass is non-trivial. It contains multiple fields, two substantial inner classes, custom iterators and spliterators, hashing/rehash logic, and custom serialization code — clearly more than a light extension.

5. Local Symptom Summary:  
Although there are a few trivial overrides that merely delegate to super, the class implements a large amount of specialized functionality (ValueEntry/ValueSet, linked-list maintenance, custom iterators/serialization) and also makes legitimate use of inherited methods and hooks. This looks like a proper specialization rather than a class that refuses its parent's bequest.

Final verdict:
NO, I did not find Refused Bequest."
PropertyElf.java,"1. Inheritance Pattern:
- This file defines ""public final class PropertyElf"" and does not declare ""extends"". It only implicitly extends java.lang.Object.

2. Use of Inherited Functionality:
- There is no subclassing relationship to inspect, so there are no overrides or explicit uses of a parent's protected members. The class only declares static utility methods and a private constructor; it does not override or call super.* methods.

3. New/Independent Functionality:
- The class is a utility for reflectively setting/getting bean properties: it defines several static methods (setTargetFromProperties, getPropertyNames, getProperty, copyProperties, setProperty), a Pattern constant, and uses logging. All functionality is self-contained and independent.

4. Breadth of Subclass:
- Not applicable as a subclass, but the class itself is non-trivial: multiple methods and logic for property handling and type conversion.

5. Local Symptom Summary:
- There are no symptoms of Refused Bequest because there is no subclassing relationship in this file. The clearest sign is that PropertyElf is a standalone final utility class (static methods, private constructor) rather than a subclass that inherits and ignores a parent contract.

NO, I did not find Refused Bequest."
PendingTransactionsDialog.java,"1. Inheritance Pattern:  
- Yes. The class is PendingTransactionsDialog which extends TransactionInfoDialog.

2. Use of Inherited Functionality:  
- The subclass overrides several parent hooks:
  - isResizable() (trivial override returning true).
  - getCurrentContext() — meaningful override returning the dialog's selectedContext.
  - getDialogBoundsSettings() — simple override returning dialog-specific settings.
  - createDialogArea(...) — calls super.createDialogArea(parent) and super.createTransactionLogPanel(composite) and then extends the UI.
- The subclass directly uses inherited members/methods: e.g. logViewer (not declared here) is accessed and refreshed, createContextFilter(...) is called, closeOnFocusLost(...) is used (likely provided by parent), and it relies on the parent transaction log panel. So it both calls super.* and interacts with inherited state and behavior; a couple of overrides are minor/trivial, but others are meaningful.

3. New/Independent Functionality:  
- Yes. The class introduces its own fields (contextTree, selectedContext, commitButton, rollbackButton) and methods (endTransaction, loadContexts, showDialog) and builds a significant UI for listing contexts and committing/rolling back transactions. This is new functionality, but it is related to transaction management / viewing.

4. Breadth of Subclass:  
- The subclass is non-trivial: several fields, custom UI construction, event listeners, and helper methods — not a thin wrapper.

5. Local Symptom Summary:  
- The subclass adds substantial new UI and controls but also meaningfully uses inherited transaction log functionality (logViewer, createTransactionLogPanel, createContextFilter) and overrides getCurrentContext to integrate with the parent. Some overrides are trivial (isResizable, dialog settings), but overall it extends and composes parent behavior rather than ignoring it.

Final verdict:  
NO, I did not find Refused Bequest — the subclass actively uses inherited transaction-log features (calls super methods, accesses inherited logViewer and filters, and overrides getCurrentContext) while adding related UI responsibilities."
JedisClusterTest.java,"1. Inheritance Pattern:  
No — this file defines class JedisClusterTest which does not declare ""extends"". It therefore only (implicitly) extends java.lang.Object.

2. Use of Inherited Functionality:  
Not applicable — there is no explicit parent class to inherit from beyond Object. The class does not override Object methods (toString/equals/hashCode) nor use super. No signs of calling or specializing inherited behavior.

3. New/Independent Functionality:  
Yes — the class introduces many fields (Jedis node references, configs, HostAndPort fields, Logger) and a large number of test methods and helpers focused on cluster testing logic (setUp/tearDown, many @Test methods, helper methods like getNodeServingSlotRange, assertNodeHandshakeEnded, isAnyNodeHandshaking).

4. Breadth of Subclass:  
The class is non-trivial: many fields and dozens of methods — it’s a full test suite, not a light extension.

5. Local Symptom Summary:  
Because JedisClusterTest does not extend any other class (beyond Object), it cannot exhibit the Refused Bequest smell in the usual sense. The class is large and self-contained but not a subclass refusing inherited behavior.

NO, I did not find Refused Bequest."
RandomGenerator.java,"1. Inheritance Pattern:  
Yes. The class RandomGenerator extends AbstractGenerator.

2. Use of Inherited Functionality:  
Yes. The subclass calls super(...) in constructors and directly uses inherited fields this.baseStr and this.length in generate(). It overrides generate() with a substantive implementation (uses RandomUtil to build a string from the inherited baseStr/length). It also overrides verify(), which is a small but meaningful specialization (checks blank and compares ignoring case).

3. New/Independent Functionality:  
No significant new fields or unrelated responsibilities are introduced. The class only provides constructors and overrides expected generator methods; it does not add independent domain logic or new state.

4. Breadth of Subclass:  
The subclass is small and focused: two constructors and two overridden methods. It is not a large class with many extra fields/methods.

5. Local Symptom Summary:  
The class makes direct use of inherited state and provides meaningful overrides for core behavior; it does not introduce many unrelated fields or responsibilities.

NO, I did not find Refused Bequest. Evidence: uses inherited fields and meaningful overrides (generate/verify); no substantial unrelated fields or new responsibilities."
RouterNanoHTTPD.java,"1. Inheritance Pattern:  
Yes. The class RouterNanoHTTPD extends NanoHTTPD.

2. Use of Inherited Functionality:  
Very minimal. The file overrides serve(IHTTPSession) but the override just delegates to router.process(session) (no call to super.serve(...) and no other use of inherited protected state). The only other interaction with the parent is calling super(...) in the constructors. There are no substantial method overrides or direct manipulations of parent fields.

3. New/Independent Functionality:  
Yes. The class declares many new inner types and responsibilities: UriResponder, DefaultStreamHandler, DefaultHandler, multiple concrete handlers (GeneralHandler, StaticPageHandler, Error404UriHandler, IndexHandler, NotImplementedHandler), UriResource (with pattern matching and handler instantiation), several route prioritizers, UriRouter, and public methods to register routes. These implement a full routing/handler system largely independent of NanoHTTPD internals.

4. Breadth of Subclass:  
Non-trivial. Many fields, methods, and nested classes — a sizable routing framework rather than a light extension.

5. Local Symptom Summary:  
The subclass shows symptoms of Refused Bequest: it introduces extensive, independent routing and handler logic (many new fields/classes) while barely using or specializing the parent (only trivial constructor super calls and a serve override that simply delegates to its own router).

Verdict:
YES, I found Refused Bequest — evidence: many new fields/methods and nested classes implementing a routing system, but only a trivial override of serve (no meaningful use of inherited behavior)."
JavassistProxyFactory.java,"1. Inheritance Pattern:
- This file defines the class JavassistProxyFactory (public final class JavassistProxyFactory). It does not extend any other class (no ""extends"" clause).  
- Note: the file contains code that *generates* proxy classes which will extend other classes (via Javassist), but JavassistProxyFactory itself is not a subclass.

2. Use of Inherited Functionality:
- Not applicable for JavassistProxyFactory because it does not extend a parent class. There are no overrides, no calls to super.*, and no inherited fields/methods being used within this class.

3. New/Independent Functionality:
- The class introduces its own static fields (classPool, genDirectory) and many static methods (main, modifyProxyFactory, generateProxyClass, isThrowsSqlException, isDefaultMethod, getAllInterfaces, toJavaClass overloads). These implement code-generation logic via Javassist and are independent responsibilities.

4. Breadth of Subclass:
- JavassistProxyFactory is non-trivial (many helper methods and significant logic), but again it is not a subclass; it is a utility/generator class.

5. Local Symptom Summary:
- Because this file does not declare a subclass of any parent class, it cannot exhibit Refused Bequest locally. It programs generation of subclasses elsewhere, but that meta-level behavior is not evidence of a subclass refusing a bequest in this file.

Final verdict:
NO, I did not find Refused Bequest."
ClusterConnectionManager.java,"1. Inheritance Pattern:
- Yes. The file defines a class ClusterConnectionManager that extends MasterSlaveConnectionManager.

2. Use of Inherited Functionality:
- The subclass makes substantial use of inherited methods/fields. Examples:
  - Calls super.changeMaster(...) inside its override of changeMaster.
  - Calls super.createRedisConfig(...) and then adjusts the returned config.
  - Calls super.shutdown() from its shutdown override.
  - Uses inherited utilities/members such as connectToNode(...), create(...), initTimer(...), stopThreads(), closeNodeConnections(), getShutdownLatch(), group/resolverGroup (for scheduling/resolving), and subscribeService (to reattach pub/sub). Many method overrides do more than trivial forwarding — they extend or wrap parent behavior.

3. New/Independent Functionality:
- Yes. The subclass introduces many cluster-specific fields and logic: lastPartitions, monitorFuture, lastClusterNode, clusterNodesCommand, configEndpointHostName, natMapper, slot2entry, client2entry, and many methods for parsing cluster node info, scheduling cluster checks, adding/removing masters/slaves, slot migration, slot calculation, etc. This represents substantial new responsibilities specific to Redis Cluster management.

4. Breadth of Subclass:
- The subclass is non-trivial: it contains many additional fields, many complex methods, scheduling and async logic, and extensive state management. It is clearly much more than a lightweight extension.

5. Local Symptom Summary:
- Although ClusterConnectionManager introduces many new responsibilities and fields (cluster-specific logic), it also meaningfully uses and overrides inherited behavior (calls to super and numerous inherited helper methods/fields). The subclass is a specialization that builds on the parent rather than refusing its bequest.

Conclusion per instructions:
NO, I did not find Refused Bequest — the subclass both heavily extends with its own cluster-specific logic and makes substantive use of inherited methods/fields (e.g., super.changeMaster, connectToNode, group/resolverGroup, subscribeService)."
RequestLimiter.java,"1. Inheritance Pattern:
- This file defines ""public class RequestLimiter"" and it does NOT extend any other class (implicitly extends java.lang.Object). No parent class name is present.

2. Use of Inherited Functionality:
- Not applicable: there are no method overrides, no calls to super., and no explicit use of inherited protected members. The class only composes a LeapArray<LongAdder> and uses its API.

3. New/Independent Functionality:
- Yes. The class introduces its own fields (qpsAllowed, data) and several methods related to rate limiting: increment(), add(int), getSum(), getQps(), getQpsAllowed(), canPass(), setQpsAllowed(...), tryPass(). These implement independent rate-limiting behavior via composition.

4. Breadth of Subclass:
- The class is non-trivial (multiple fields and methods) but that breadth is internal — it is not an extension of any parent type.

5. Local Symptom Summary:
- There is no inheritance to be refused. The clearest sign: no extends clause, no overrides, no super usage — all logic is self-contained and uses composition.

NO, I did not find Refused Bequest."
MockNamingService.java,"1. Inheritance Pattern:  
- This file defines ""public class MockNamingService implements NamingService"". It does not extend another class; it implements the NamingService interface.

2. Use of Inherited Functionality:  
- The class provides implementations for all interface methods, but nearly all methods are empty (no-op) or return null. There are no calls to super. There are no meaningful overrides or uses of inherited state (not applicable for an interface).

3. New/Independent Functionality:  
- The class declares no new fields and defines no additional helper methods beyond the interface methods. It does not introduce significant new responsibilities; it is essentially a stub/mock of the interface.

4. Breadth of Subclass:  
- The class is large only because it implements many interface methods, but each implementation is trivial. It is not a broad subclass adding new unrelated behavior or state.

5. Local Symptom Summary:  
- The file shows trivial/mocked implementations of the interface methods (many no-ops/return null) but does not add unrelated fields or novel functionality. This looks like a test/mock implementation rather than a subclass refusing a parent's responsibilities.

Final verdict: NO, I did not find Refused Bequest. Evidence: implements NamingService with empty/no-op method bodies and no added fields or unrelated logic, indicating a mock/stub rather than a subclass that refuses a parent's contract."
MethodVisitor.java,"1. Inheritance Pattern:
- This file defines an interface (MethodVisitor). It does not define a class that extends another class, and the interface does not extend any other interface. Therefore there is no parent class.

2. Use of Inherited Functionality:
- Not applicable: there is no subclass here. No overrides, no use of super., and no inherited fields to interact with in this file.

3. New/Independent Functionality:
- The interface declares many methods (visitInsn, visitVarInsn, visitTypeInsn, visitFieldInsn, visitMethodInsn, visitJumpInsn, visitLabel, visitLdcInsn, visitIincInsn, visitMaxs, visitEnd, etc.) representing bytecode-visiting responsibilities. These are the interface’s own API, not additions to an inherited class.

4. Breadth of Subclass:
- Not applicable (no subclass). The interface itself is non-trivial, with many methods.

5. Local Symptom Summary:
- Because this file contains an interface (no subclass extending a parent class), there is no evidence of a subclass refusing a bequest here.

Final verdict:
NO, I did not find Refused Bequest."
FlowControllerV1.java,"1. Inheritance Pattern:  
- This file defines class FlowControllerV1. It does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:  
- Not applicable: there is no superclass, so there are no overrides, no use of super., and no inherited fields/methods to call.

3. New/Independent Functionality:  
- The class introduces its own fields (logger, repository, sentinelApiClient) and many methods handling REST endpoints (apiQueryMachineRules, apiAddFlowRule, apiUpdateFlowRule, apiDeleteFlowRule, plus helpers checkEntityInternal and publishRules). These are specific controller responsibilities.

4. Breadth of Subclass:  
- Not applicable as this class is not a subclass. The class is non-trivial: multiple fields and many methods.

5. Local Symptom Summary:  
- Because the class does not extend any parent, there are no symptoms of Refused Bequest in this file (no inherited contract to refuse).

NO, I did not find Refused Bequest."
DiagnosedStreamCorruptionException.java,"NO, I did not find Refused Bequest — the subclass meaningfully specializes an exception (adds diagnostic state and a non-trivial toString) and uses inherited behavior (initCause, super.toString()).

Step-by-step:

1. Inheritance Pattern:
   - Yes. The file defines class DiagnosedStreamCorruptionException that extends StreamCorruptedException.

2. Use of Inherited Functionality:
   - The subclass calls inherited initCause(cause) and overrides toString(), calling super.toString() and then appending diagnostic information. These are meaningful uses/overrides (not trivial one-liners that just delegate).

3. New/Independent Functionality:
   - The class introduces new fields (diagnoseFailure, readBack, readAhead), getters for them, and logic in toString() to render diagnostic hex dumps and stack traces. These are new responsibilities, but they are directly related to enriching the parent exception with diagnostics.

4. Breadth of Subclass:
   - The subclass is small but non-trivial: three final fields, three getters, a constructor, and an overridden toString(). It is not merely a marker, but a focused extension to add diagnostic details.

5. Local Symptom Summary:
   - No strong symptom of Refused Bequest. The clearest sign against the smell is that the added functionality is clearly an extension of the parent’s role (an exception carrying extra diagnostic data) and the override uses parent behavior (initCause and super.toString()) rather than ignoring it."
XMLConfigBuilder.java,"1. Inheritance Pattern:
- Yes. The class is declared as ""public class XMLConfigBuilder extends BaseBuilder"". The parent class is BaseBuilder.

2. Use of Inherited Functionality:
- The subclass makes substantial use of inherited members and helper methods. Evidence in this file: it calls super(new Configuration()) in the constructor; it accesses inherited fields such as configuration, typeAliasRegistry, typeHandlerRegistry; and it repeatedly calls inherited/helper methods like resolveClass(...), createInstance(...), resolveJdbcType(...), booleanValueOf(...), integerValueOf(...), stringSetValueOf(...). There are no method overrides shown in this file (no overriding of parent methods and no trivial overrides calling only super.method()).

3. New/Independent Functionality:
- The subclass introduces its own state (parsed, parser, environment, localReflectorFactory) and a large set of methods to parse XML configuration (parse, parseConfiguration, propertiesElement, settingsElement, environmentsElement, mapperElement, etc.). These are significant new responsibilities (XML parsing and configuration assembly).

4. Breadth of Subclass:
- The class is non-trivial: many private fields and numerous methods handling different configuration concerns (properties, plugins, type handlers, environments, mappers, etc.).

5. Local Symptom Summary:
- Despite adding a lot of specific functionality, the subclass heavily uses inherited facilities (configuration and various helper/registry methods). The class appears to be a concrete builder specialized for XML input and leverages BaseBuilder utilities rather than refusing them.

NO, I did not find Refused Bequest — the class makes substantial use of inherited fields/methods (configuration, registries, resolveClass/createInstance helpers) rather than ignoring the parent's responsibilities."
Lexeme.java,"1. Inheritance Pattern:
- This file defines public class Lexeme which does not extend any explicit superclass. It implements Comparable<Lexeme>. The implicit parent is java.lang.Object.

2. Use of Inherited Functionality:
- Lexeme overrides Object methods equals(Object), hashCode(), and toString(), and implements compareTo(Lexeme) from Comparable. These overrides are substantial (non-trivial implementations) and there is no use of super.* calls. There is no evidence of relying on or ignoring a non-trivial parent class API.

3. New/Independent Functionality:
- Yes. The class introduces many fields (offset, begin, length, lexemeText, lexemeType and constants) and many domain-specific methods (position calculations, getLexemeTypeString, append, setters/getters). These represent a self-contained lexeme responsibility.

4. Breadth of Subclass:
- The class is non-trivial with several fields, constants and many methods; it is more than a marker or light extension.

5. Local Symptom Summary:
- There is no sign of Refused Bequest: Lexeme does not extend a meaningful parent class (only Object), and the overrides present are purposeful and substantial. The class is self-contained and does not appear to be a subclass that refuses an inherited contract.

NO, I did not find Refused Bequest. Evidence: class does not extend a non-trivial parent (only Object) and its overrides/implementations are meaningful and consistent with its own responsibilities."
DBeaverCore.java,"1. Inheritance Pattern:
- Yes. The file defines class DBeaverCore that extends BasePlatformImpl.

2. Use of Inherited Functionality:
- DBeaverCore overrides several parent methods (initialize, dispose, getWorkspace, getDefaultResourceHandler, getApplication, getPreferenceStore, getCertificateStorage, getSecureStorage, getExternalFileManager, getConfigurationFile, isShuttingDown).
- It calls super.initialize() and super.dispose(), so it cooperates with the parent lifecycle.
- Some overrides are simple one-liners that return concrete instances (e.g., getDefaultResourceHandler(), getApplication(), getPreferenceStore()) — likely implementations of abstract/extension points rather than trivial passthroughs that ignore base behavior. The initialize() and dispose() overrides are substantial and call into superclass behavior.

3. New/Independent Functionality:
- Yes. The class introduces multiple fields and responsibilities: tempFolder management, DBeaverWorkspace workspace, QMControllerImpl queryManager and QMLogFileWriter, certificate storage, lifecycle management (initialization and shutdown), temp folder creation logic, workspace saving, plugin logging, etc. These are substantial, application-specific behaviors.

4. Breadth of Subclass:
- The subclass is non-trivial: multiple fields, multiple substantive methods (initialize, dispose, getTempFolder, getQueryManager, etc.). This is more than a marker or light extension.

5. Local Symptom Summary:
- Despite many new responsibilities, DBeaverCore actively uses and cooperates with the parent (calls super.initialize()/super.dispose() and provides concrete implementations of platform hooks). The overrides are generally meaningful (especially initialize/dispose) and appear to fulfill the intended extension contract.

Final verdict:
NO, I did not find Refused Bequest. Evidence: substantial, meaningful overrides (initialize/dispose that call super) and implementations of platform hooks indicate this class is honoring and extending the parent contract rather than refusing it."
AztecCode.java,"1. Inheritance Pattern:
- The file defines ""public final class AztecCode"" and does not declare ""extends"". Its only parent is java.lang.Object (implicit).

2. Use of Inherited Functionality:
- There are no method overrides, no calls to super., and no interaction with inherited/protected state. All methods are simple getters and setters.

3. New/Independent Functionality:
- The class introduces its own fields (compact, size, layers, codeWords, matrix) and corresponding accessors — a representation of an Aztec code. This is domain-specific but self-contained.

4. Breadth of Subclass:
- The class is small and focused (five fields and trivial getters/setters). It is not a large subclass with many unrelated responsibilities.

5. Local Symptom Summary:
- There is no inheritance beyond Object and therefore no opportunity to refuse a bequest. The class does not override or ignore parent behavior; it is simply a small data-holder.

NO, I did not find Refused Bequest"
EntryConfig.java,"1. Inheritance Pattern:
- This file defines class EntryConfig. It does NOT extend any other class (no ""extends"" clause). Its implicit parent is java.lang.Object.

2. Use of Inherited Functionality:
- Not applicable: there are no overrides of parent methods (only toString from Object is overridden, which is normal and meaningful). There are no calls to super.* or interactions with inherited state beyond the toString override.

3. New/Independent Functionality:
- EntryConfig introduces its own fields (resourceName, entryType, resourceType, acquireCount, args, contextConfig), multiple constructors, getters, and a toString. These represent its own configuration responsibilities (not inherited behavior).

4. Breadth of Subclass:
- The class is non-trivial (several fields and methods), but it is a standalone class rather than a subclass.

5. Local Symptom Summary:
- Because EntryConfig does not extend a concrete parent class, it cannot exhibit Refused Bequest in the sense described. The clearest sign is simply the absence of inheritance.

Final determination:
NO, I did not find Refused Bequest. Evidence: EntryConfig does not extend any parent class (no inherited members to refuse)."
ScriptProcessorBuilder.java,"1. Inheritance Pattern:  
   This class (ScriptProcessorBuilder) does not explicitly extend any class. It only implicitly extends java.lang.Object.

2. Use of Inherited Functionality:  
   Not applicable — there are no method overrides, no calls to super.*, and no interaction with inherited protected state.

3. New/Independent Functionality:  
   The class defines its own fields (language, script, threadNum) and many builder-style methods (language(...), scriptFromFile(...), scriptFromClassPathFile(...), script(...), thread(...), build()). These are self-contained builder responsibilities.

4. Breadth of Subclass:  
   The class is non-trivial (multiple fields and methods), but it is an independent builder type rather than a small extension of a parent.

5. Local Symptom Summary:  
   There is no evidence of Refused Bequest because there is no superclass being extended (other than Object), so no inherited contract is being ignored.

NO, I did not find Refused Bequest. (Main reason: the class does not extend another class, so refused bequest cannot occur here.)"
MapTypeAdapterFactory.java,"1. Inheritance Pattern:  
- Yes. The file defines a private inner class Adapter<K,V> that extends TypeAdapter<Map<K,V>>.  
- The top-level class MapTypeAdapterFactory implements the TypeAdapterFactory interface.

2. Use of Inherited Functionality:  
- Adapter overrides the core abstract methods read(JsonReader) and write(JsonWriter, Map<K,V>) from TypeAdapter and provides full implementations for both.  
- The overrides are substantial (complete parsing/serialization logic) and do not merely call super.read()/super.write() or contain trivial one-liners.  
- The subclass does not appear to access protected state from the parent (TypeAdapter is an abstract API here); it conforms to the parent’s contract by implementing the required methods.

3. New/Independent Functionality:  
- Adapter declares its own fields (keyTypeAdapter, valueTypeAdapter, constructor) and methods (constructor, read, write, keyToString).  
- It contains significant logic for two serialization formats (map-as-object vs map-as-array), complex-key detection, duplicate-key checking, and conversion of key JsonElements to string forms. These are substantial responsibilities specific to map adaptation.

4. Breadth of Subclass:  
- Yes. The Adapter is non-trivial: several fields, a constructor, two large method implementations, and a helper method. It contains many lines of logic and local data structures (lists, looping, conditional branches).

5. Local Symptom Summary:  
- The subclass does not show symptoms of Refused Bequest. It meaningfully implements the abstract behavior required by TypeAdapter (read/write) with substantial, map-specific logic. Although it introduces many fields/methods, they align with the adapter’s responsibility (specializing TypeAdapter for Map), not evidence of ignoring the parent’s contract.

Final verdict: NO, I did not find Refused Bequest."
AttributeNameHistoWalker.java,"NO, I did not find Refused Bequest

Step-by-step:

1. Inheritance Pattern:
- Yes — the class extends AbstractHistoVisitable.

2. Use of Inherited Functionality:
- The subclass calls super(model, resolution) in its constructor.
- It overrides visit(IMetaMember mm) and uses an inherited histo field (histo.addValue(val)). The override is substantive (it implements the visitation logic to extract an attribute value and add it to the histogram), not just a trivial one-liner call to super.

3. New/Independent Functionality:
- The class introduces two fields (isCompileAttribute, attributeName), a constructor, and a visit implementation that selects between compiled/queued attributes and parses/adds values. This is specialization of the visit behavior rather than unrelated functionality.

4. Breadth of Subclass:
- The class is small but non-trivial: it provides state and a meaningful override rather than being merely a marker or a no-op extension.

5. Local Symptom Summary:
- The subclass appears to honor and use the parent’s responsibilities (it implements the visit contract and manipulates the inherited histo). The clearest evidence against Refused Bequest is the meaningful override of visit and direct use of inherited state (histo)."
PageModelExtractor.java,"1. Inheritance Pattern:
- The file defines class PageModelExtractor. It does not declare ""extends"" and therefore does not extend any parent class.

2. Use of Inherited Functionality:
- Not applicable: PageModelExtractor has no superclass, so there are no overridden methods, no calls to super.*, and no direct use of inherited protected members from a parent.

3. New/Independent Functionality:
- The class declares many fields (patterns, selectors, clazz, fieldExtractors, objectExtractor, logger) and many methods implementing page-model extraction logic (init, getAnnotation..., initClassExtractors, process, processSingle, convert, setField, getters, etc.). All functionality is self-contained and unrelated to any parent behavior.

4. Breadth of Subclass:
- Not applicable as it is not a subclass. The class is non-trivial with many methods and responsibilities (parsing annotations, building selectors, instantiating and populating model objects).

5. Local Symptom Summary:
- There are no symptoms of Refused Bequest because PageModelExtractor does not extend another class. The clearest sign: no inheritance (no extends), no overrides, no super usage — it's a standalone, self-contained extractor.

Conclusion:
NO, I did not find Refused Bequest."
TreeTypeAdapter.java,"1. Inheritance Pattern:
- Yes. This file defines class TreeTypeAdapter<T> that extends TypeAdapter<T>.

2. Use of Inherited Functionality:
- The subclass overrides the core TypeAdapter methods read(JsonReader) and write(JsonWriter, T). These overrides implement meaningful behavior: they either delegate to a lazily-obtained delegate TypeAdapter or use the provided JsonSerializer/JsonDeserializer to convert between streaming and tree representations. It does not call super.*, but the overrides are substantial (not trivial one-liners calling only super).

3. New/Independent Functionality:
- The class introduces multiple fields (serializer, deserializer, gson, typeToken, skipPast, context, delegate) and methods (constructor, delegate(), several static factory creators, inner SingleTypeFactory and inner GsonContextImpl). These represent additional responsibilities (adapting tree-style serializers/deserializers, factory creation, context bridging) but are directly related to TypeAdapter’s serialization/deserialization concern rather than an unrelated domain.

4. Breadth of Subclass:
- The subclass is non-trivial: several fields, helper methods, and two inner classes imply substantial added functionality.

5. Local Symptom Summary:
- The subclass does not show symptoms of Refused Bequest. It meaningfully overrides the parent’s core methods (read/write) to implement specialized behavior and provides related supporting facilities (factories and context). The added fields/methods extend the adapter’s serialization/deserialization role rather than indicating an unrelated responsibility.

Final verdict:
NO, I did not find Refused Bequest."
Spider.java,"1. Inheritance Pattern:
- The file defines class Spider which does not extend any other class. It implements two interfaces: Runnable and Task. There is no parent class.

2. Use of Inherited Functionality:
- Because Spider does not extend a concrete superclass, there are no inherited concrete fields or methods to override or call via super. It does implement interface methods (run(), getUUID(), getSite()) required by Runnable/Task; those implementations are substantial (run contains the main crawling loop, getUUID/getSite return state). There are no uses of super. No trivial overrides of parent-class behavior are present (since there is no parent class).

3. New/Independent Functionality:
- Spider defines many fields (downloader, pipelines, pageProcessor, scheduler, threadPool, site, site configuration flags, locks/conditions, listeners, counters, etc.) and many methods implementing crawler behavior (start/run/runAsync/stop, request processing, scheduling, retry logic, pipelines, resource management, etc.). This is significant, self-contained functionality unrelated to any superclass responsibilities.

4. Breadth of Subclass:
- The class is non-trivial: dozens of fields and many methods, including threading, scheduling, I/O/resource lifecycle, and crawling logic.

5. Local Symptom Summary:
- Refused Bequest is not applicable here because there is no superclass being extended. The class implements interfaces and provides full implementations of required methods, and most functionality is native to Spider rather than ignoring an inherited contract.

Conclusion:
NO, I did not find Refused Bequest."
RandomService.java,"1. Inheritance Pattern:
- The file defines public class RandomService. It does not declare an extends clause; it implicitly extends java.lang.Object only.

2. Use of Inherited Functionality:
- RandomService does not override any superclass methods and contains no calls to super., nor any interaction with inherited protected state. There are no method overrides beyond Object's defaults.

3. New/Independent Functionality:
- The class introduces its own fields (SHARED_RANDOM, random) and many methods (nextInt, nextLong, nextDouble, nextBoolean, hex, etc.) implementing random-related utilities — clearly its own responsibility.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields and several utility methods (including overloaded methods and helper logic). It is more than a light extension or marker.

5. Local Symptom Summary:
- Because RandomService does not extend a meaningful parent (only Object) and neither overrides nor uses inherited functionality, there is no evidence of Refused Bequest in this file. The class simply implements its own behavior.

NO, I did not find Refused Bequest."
RuleContainer.java,"1. Inheritance Pattern:
- This file defines class RuleContainer with no explicit extends clause. It therefore implicitly extends java.lang.Object (no custom parent class).

2. Use of Inherited Functionality:
- There are no overridden methods, no uses of super., and no interaction with any inherited protected state. All methods are newly declared in this class.

3. New/Independent Functionality:
- Yes. The class introduces its own fields (orderValues, testRules, methodRules) and many methods (setOrder, add overloads, getSortedEntries, apply, getSortedRules) and a static inner RuleEntry type. The logic is about ordering and applying TestRule/MethodRule instances — a distinct responsibility implemented entirely here.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields, several methods, a Comparator constant, and a nested static class. It is more than a light extension or marker.

5. Local Symptom Summary:
- Refused Bequest is not applicable here because RuleContainer does not extend a meaningful parent class (only Object), so there are no inherited behaviors to refuse. The class implements substantial, self-contained functionality.

Final verdict:
NO, I did not find Refused Bequest."
LocalCacheListener.java,"1. Inheritance Pattern:
- This file defines an abstract class LocalCacheListener. It does not explicitly extend any other class; it implicitly extends java.lang.Object.

2. Use of Inherited Functionality:
- There are no meaningful overrides of parent methods (no toString/equals/hashCode overrides, etc.). The only use of super is the trivial super() call in the constructor. There are no uses of super.method(...) or direct interaction with inherited state beyond the Object default.

3. New/Independent Functionality:
- The class introduces many fields (disabledKeys, name, commandExecutor, cache, object, instanceId, codec, options, cacheUpdateLogTime, lastInvalidate, invalidationTopic, syncListenerId, reconnectionListenerId) and many methods implementing caching, invalidation, topic listeners, scheduling, semaphore coordination, update log loading, etc. This represents substantial, self-contained functionality unrelated to any inherited behavior.

4. Breadth of Subclass:
- The class is non-trivial: multiple complex methods (add, createCache, clearLocalCacheAsync, disableKeys, loadAfterReconnection, etc.) and several fields. It is clearly more than a light extension or marker.

5. Local Symptom Summary:
- There is no evidence of Refused Bequest: the class does not extend a meaningful parent (only Object), so there is nothing inherited to accept or refuse. The class is a standalone component with many its own responsibilities.

NO, I did not find Refused Bequest. (Main evidence: class does not extend any custom parent—only java.lang.Object—and implements substantial independent functionality.)"
TransactionMQProducer.java,"1. Inheritance Pattern:
- Yes. The file defines class TransactionMQProducer that extends DefaultMQProducer.

2. Use of Inherited Functionality:
- The subclass clearly uses inherited state/members: it calls super(...) constructors, uses this.defaultMQProducerImpl and this.getNamespace() (presumably inherited/protected), and invokes super.start() and super.shutdown().
- It overrides start() and shutdown() to add transaction-specific initialization/cleanup around the superclass behavior (not just delegating trivially).
- It overrides sendMessageInTransaction(...) variants to perform checks, wrap the message topic with the namespace, and then delegate to defaultMQProducerImpl. These overrides are meaningful (add validation/namespace wrapping and transaction handling), not one-line trivial wrappers.

3. New/Independent Functionality:
- The class introduces transaction-specific fields and behavior: transactionCheckListener, transactionListener, thread-pool sizing fields, executorService, and associated getters/setters. It implements transaction-specific send logic and lifecycle hooks (init/destroy transaction env).
- This new functionality is specific to transactional message handling (a clear specialization of producer behavior).

4. Breadth of Subclass:
- The subclass is non-trivial: several fields, multiple constructors, multiple overridden methods, and several getters/setters. It does more than serve as a light extension or marker.

5. Local Symptom Summary:
- The subclass does not show the typical Refused Bequest symptom. It meaningfully uses inherited members (defaultMQProducerImpl, getNamespace, super.start/shutdown), and it adds coherent, related functionality (transactional behavior) that specializes the producer role.

Conclusion:
NO, I did not find Refused Bequest — TransactionMQProducer extends DefaultMQProducer to meaningfully specialize it for transactional message handling, using inherited state/methods and adding related functionality."
PlainPermissionManager.java,"1. Inheritance Pattern:
- This file defines class PlainPermissionManager, but it does not extend any other class (no ""extends"" clause). Its only implicit parent is java.lang.Object.

2. Use of Inherited Functionality:
- Not applicable: there are no overrides, no calls to super., and no direct use of inherited protected members from a parent class (because there is no explicit parent class).

3. New/Independent Functionality:
- The class introduces many fields and methods for ACL handling: file paths, maps/lists of PlainAccessResource and RemoteAddressStrategy, load/watch logic, create/update/delete ACL config methods, validation and permission-checking logic, data version handling, etc. These are substantial, self-contained responsibilities.

4. Breadth of Subclass:
- The class is non-trivial (many fields and many methods), but it is not a subclass of any domain parent in this file.

5. Local Symptom Summary:
- There are no symptoms of Refused Bequest because PlainPermissionManager does not extend another class in this file. The clearest sign is simply the absence of inheritance (no extends), so the Refused Bequest pattern cannot apply here.

Final verdict:
NO, I did not find Refused Bequest."
JSONTokener.java,"1. Inheritance Pattern:
- The file defines class JSONTokener which does not explicitly extend any class. It implicitly extends java.lang.Object.

2. Use of Inherited Functionality:
- The only inherited method overridden is toString() (overriding Object.toString()). There are no calls to super.*, and no interaction with any inherited state from a meaningful parent class. The toString() override is simple and appropriate (returns location info) — not a complex override of a parent's contract.

3. New/Independent Functionality:
- JSONTokener introduces many fields (character, eof, index, line, previous, usePrevious, reader, config) and many parsing methods (next, nextClean, nextString, nextValue, nextTo, skipTo, back, more, end, etc.). These represent a full JSON-parsing responsibility unrelated to any parent class behavior.

4. Breadth of Subclass:
- The class is non-trivial: many fields and many methods implement substantial functionality.

5. Local Symptom Summary:
- There is no evidence of Refused Bequest. The class does not extend a meaningful parent beyond Object, and it only provides a sensible toString() override. The heavy, unrelated functionality is not a sign of refusing an inherited contract because there is no non-trivial parent to refuse.

NO, I did not find Refused Bequest."
AndroidMusic.java,"1. Inheritance Pattern:
- The file defines class AndroidMusic which implements two interfaces: com.badlogic.gdx.audio.Music and android.media.MediaPlayer.OnCompletionListener.
- It does not extend any explicit superclass (only implicitly extends java.lang.Object).

2. Use of Inherited Functionality:
- Because there is no non-trivial superclass, there are no inherited protected members or concrete methods to override or call via super.
- The class implements interface methods (play, pause, stop, setVolume, etc.) and provides concrete behavior. There are no calls to super.* and no use of inherited state beyond Object.

3. New/Independent Functionality:
- Yes. AndroidMusic introduces its own fields (AndroidAudio audio, MediaPlayer player, isPrepared, wasPlaying, volume, onCompletionListener) and many methods (play/pause/stop/setPosition/getDuration/setPan, etc.) that manage a MediaPlayer instance and audio behavior — substantial, independent responsibilities implemented via composition.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields and many methods implementing full music playback behavior.

5. Local Symptom Summary:
- There is no sign of Refused Bequest here because the class does not extend a meaningful parent whose behavior it would be refusing. The class implements required interface methods and provides its own functionality via composition.

Final judgment:
NO, I did not find Refused Bequest. Evidence: the class does not extend a concrete parent (only implements interfaces) and does not ignore or override inherited behavior — it implements its own playback functionality via composition."
WriteWorkbookHolder.java,"1. Inheritance Pattern:  
Yes. The class is WriteWorkbookHolder and it extends AbstractWriteHolder.

2. Use of Inherited Functionality:  
Very limited. The constructor calls super(writeWorkbook, null, writeWorkbook.getConvertAllFiled()), and the class overrides a single method holderType() to return HolderEnum.WORKBOOK. There are no other super.method(...) calls or visible interactions with inherited state; the override is trivial.

3. New/Independent Functionality:  
Yes. The class defines many new fields (workbook, cachedWorkbook, file, outputStream, templateInputStream, tempTemplateInputStream, maps, flags, password, etc.) and methods (constructor with substantial initialization, copyTemplate(), many getters/setters). These represent file/template/workbook management responsibilities that are specific to this subclass.

4. Breadth of Subclass:  
Non-trivial. The class is large with many fields and methods (initialization logic, I/O handling, template copying, state maps), not a light extension.

5. Local Symptom Summary:  
The subclass shows symptoms of Refused Bequest: it provides substantial, independent functionality and state while only minimally using or overriding the parent’s behavior (one trivial override and a constructor super call).

YES, I found Refused Bequest — many new fields and methods implement independent workbook/template I/O logic while only a trivial override (holderType) and a constructor super call use the parent."
DefaultDateTypeAdapter.java,"1. Inheritance Pattern:  
Yes. The file defines class DefaultDateTypeAdapter that extends TypeAdapter<Date>.

2. Use of Inherited Functionality:  
The subclass overrides several inherited methods: write(JsonWriter, Date), read(JsonReader), and toString(). These overrides are substantial (implement actual serialization/deserialization logic, synchronized use of dateFormats, parsing fallbacks). It does not call super.method(), but that is expected because TypeAdapter defines/needs concrete implementations of these methods rather than providing reusable behavior to delegate to.

3. New/Independent Functionality:  
The class introduces its own fields (dateType, dateFormats) and a number of constructors plus helper method deserializeToDate and verifyDateType. These are significant and specific to date handling, but they are clearly the responsibilities needed to implement a Date TypeAdapter (format management, parsing, constructing Date/Timestamp/sql.Date).

4. Breadth of Subclass:  
The subclass is non-trivial: multiple fields, several overloaded constructors, and multiple methods implementing parsing/formatting logic. It is more than a trivial extension, but its added functionality is focused on the adapter's purpose.

5. Local Symptom Summary:  
The class provides meaningful overrides of the parent’s abstract methods and implements substantial date-specific logic using its own fields. This is consistent with honoring the TypeAdapter contract rather than refusing it.

NO, I did not find Refused Bequest. Evidence: the subclass implements core abstract methods (read/write) with substantial logic and uses its fields to fulfill the TypeAdapter role, not ignoring the parent’s contract."
AckSchedulerKey.java,"1. Inheritance Pattern:
- Yes. The file defines class AckSchedulerKey which extends SchedulerKey.

2. Use of Inherited Functionality:
- The subclass calls super(type, sessionId) in the constructor and calls super.hashCode() and super.equals(obj) in its overrides. The overrides (equals/hashCode) meaningfully incorporate the new field into inherited equality semantics rather than just delegating trivially.

3. New/Independent Functionality:
- It introduces one new field (private final long index) and a getter (getIndex()). This is a clear but small specialization (an extra component of the key).

4. Breadth of Subclass:
- The subclass is minimal: one additional field, one accessor, and two overridden methods. It is not a large class with many unrelated responsibilities.

5. Local Symptom Summary:
- The class does not show signs of Refused Bequest. It uses the parent via constructor and by delegating to super.equals()/super.hashCode(), and the added field is a small, coherent specialization of the key.

NO, I did not find Refused Bequest. Evidence: small, coherent specialization (one extra field + accessor) with meaningful use of superclass constructor and equals/hashCode, not a large unrelated feature set."
TableView.java,"1. Inheritance Pattern:
- This file defines public class TableView which implements an interface View. It does not extend any other class.

2. Use of Inherited Functionality:
- The class implements/overrides the draw() method (annotated @Override), presumably from the View interface. There are no calls to super. and no use of inherited fields or behaviors from a superclass (since there is no superclass here). The single override is the required interface method, not an override of a concrete parent implementation.

3. New/Independent Functionality:
- TableView introduces many fields (columnDefineArray, hasBorder, borders, padding), many methods (drawRow, drawSeparationLine, addRow, getTableHigh, getData, getDataFormat, padding, hasBorder, borders, getColumnCount, etc.) and an inner static class ColumnDefine with its own state and methods. This represents substantial table-rendering functionality independent of any parent/interface concerns.

4. Breadth of Subclass:
- The class is non-trivial — multiple fields, multiple complex methods, an inner enum and inner static class, and logic for layout and rendering. It is far more than a light extension or marker.

5. Local Symptom Summary:
- Because TableView does not extend a concrete parent class (only implements an interface) there is no opportunity here to “refuse” a superclass’s bequest. The class supplies substantial independent functionality and only implements the required draw() method from the View interface.

NO, I did not find Refused Bequest — main evidence: the class does not extend a superclass (only implements an interface) and implements its own large, independent table-rendering logic rather than ignoring inherited concrete behavior."
HttpClientDownloader.java,"1. Inheritance Pattern:
- Yes. The class is ""HttpClientDownloader"" and it extends ""AbstractDownloader"".

2. Use of Inherited Functionality:
- It overrides methods: download(Request, Task) and setThread(int) (both annotated @Override).
- The download override is substantial: it builds/executes HTTP requests, handles responses, and manages proxy return. It also calls inherited lifecycle hooks onSuccess(request) and onError(request). It does not use super.method() calls, but it does invoke inherited callback methods (onSuccess/onError), so it engages with the parent's contract rather than ignoring it.
- None of the overrides appear trivial (they do real work rather than just delegating to super).

3. New/Independent Functionality:
- The subclass introduces many fields and methods: httpClients map, HttpClientGenerator, HttpUriRequestConverter, ProxyProvider, responseHeader flag, getHttpClient(), handleResponse(), getHtmlCharset(), setters for converters/providers, etc. These are specific to implementing an HTTP-client-based downloader and represent substantial new functionality.

4. Breadth of Subclass:
- The class is non-trivial: several new fields, helper methods, and complex logic (HTTP client pooling, request conversion, response handling, charset detection, proxy handling). This is more than a light extension.

5. Local Symptom Summary:
- Although the class adds a lot of its own functionality, it also meaningfully implements the download behavior expected of a downloader and calls inherited lifecycle methods (onSuccess/onError). The added functionality appears directly related to the downloader responsibility (HTTP client management, response parsing), not unrelated logic.

Final verdict per instruction:
NO, I did not find Refused Bequest — evidence: subclass provides substantial, non-trivial overrides (not trivial no-ops) and invokes inherited hooks (onSuccess/onError); its added fields/methods implement the expected downloader responsibilities rather than unrelated behavior."
CN_QuantifierSegmenter.java,"1. Inheritance Pattern:
- The file defines class CN_QuantifierSegmenter which implements the interface ISegmenter. It does not extend any other class.

2. Use of Inherited Functionality:
- Because it implements an interface, there is no superclass to inherit fields or default behavior from. It provides concrete implementations of the interface methods (analyze and reset) and does not call any super.* methods or interact with inherited state.

3. New/Independent Functionality:
- Yes. The class declares its own fields (ChnNumberChars, nStart, nEnd, countHits) and many private methods (processCNumber, processCount, needCountScan, outputNumLexeme) implementing Chinese numeral/quantifier parsing logic. This is substantial, domain-specific functionality.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields, static initialization, and several non-trivial methods implementing parsing and matching behavior. It is more than a light extension or marker.

5. Local Symptom Summary:
- The Refused Bequest smell is about a subclass inheriting a parent class but not using the parent's members. Here, CN_QuantifierSegmenter does not extend a parent class at all (it implements an interface) and provides full implementations without any super calls. Therefore the Refused Bequest pattern is not applicable.

Final verdict:
NO, I did not find Refused Bequest."
CompareObjectsSettings.java,"1. Inheritance Pattern:
- This file defines class CompareObjectsSettings which does not extend any explicit superclass. Its implicit parent is java.lang.Object.

2. Use of Inherited Functionality:
- There are no overrides of superclass methods, no calls to super.*, and no direct use of inherited state beyond the implicit Object behavior. All methods are class-specific (getters/setters, load/save).

3. New/Independent Functionality:
- Yes. The class introduces its own enum (OutputType), several boolean and String fields, a List<DBNDatabaseNode> field, and many getters/setters plus loadFrom/saveTo methods that manage DBPSettingsSection. These represent configuration/settings responsibilities specific to this class.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields, an enum, and many methods — not a tiny marker or trivial extension.

5. Local Symptom Summary:
- Because the class does not extend a non-trivial parent (only Object) there is no inherited contract being refused. The class mainly defines its own settings functionality and does not exhibit the pattern of extending a parent but ignoring/overriding its members.

Conclusion:
NO, I did not find Refused Bequest."
InlineSizeHistoVisitable.java,"1. Inheritance Pattern:
- Yes. The class is InlineSizeHistoVisitable which extends AbstractHistoVisitable.

2. Use of Inherited Functionality:
- The subclass calls super(...) in its constructor.
- It uses inherited state—e.g. ignoreTags (adds many tags to ignore) and histo (histo.addValue(...))—so it interacts with parent-provided fields.
- It overrides parent methods: reset(), visit(IMetaMember) and visitTag(...). The overrides contain substantive logic (visit iterates compilations and invokes parsing, visitTag delegates to a local parser, reset clears local state). None of the overrides are mere one-line calls to super (reset does not call super.reset()).

3. New/Independent Functionality:
- Introduces a new field inlinedCounted (Set<String>) and substantial parsing logic in processParseTag(...) to inspect Tag trees, detect inline successes/failures, and add values to the histogram. This is specific behavior for inline-size histogram collection.

4. Breadth of Subclass:
- The class is non-trivial: several methods (constructor, reset, visit, visitTag, processParseTag) implement specific parsing and aggregation logic. Only one new field is added, but the class contains considerable behavior beyond a trivial extension.

5. Local Symptom Summary:
- The subclass does not show clear symptoms of Refused Bequest. It actively uses inherited fields (ignoreTags, histo), overrides key lifecycle/visitor methods with meaningful behavior, and implements functionality that fits the apparent responsibility of an AbstractHistoVisitable (building a histogram from parse tags).

Final determination:
NO, I did not find Refused Bequest. Evidence: meaningful overrides and direct use of parent fields (ignoreTags, histo) with subclass-specific parsing logic that aligns with the parent's histogram/visitable purpose."
CodahaleHealthChecker.java,"1. Inheritance Pattern:
- Yes. The file defines two inner classes that extend a parent class: ConnectivityHealthCheck and Connection99Percent both extend com.codahale.metrics.health.HealthCheck.

2. Use of Inherited Functionality:
- Both subclasses override the protected Result check() method — the core contract of HealthCheck. The overrides are substantive: ConnectivityHealthCheck obtains a Connection from HikariPool with a timeout and handles SQLException; Connection99Percent computes a 99th-percentile from a Timer snapshot and compares it to a threshold. They return Result.healthy()/Result.unhealthy(), i.e., they meaningfully implement the HealthCheck API. The overrides are not trivial one-liners nor mere calls to super.

3. New/Independent Functionality:
- Each subclass introduces fields and behavior necessary for its health-check role (ConnectivityHealthCheck: pool, checkTimeoutMs; Connection99Percent: waitTimer, expected99thPercentile). Those fields and methods directly support the health-check responsibilities and are not unrelated to HealthCheck.

4. Breadth of Subclass:
- Each subclass is non-trivial: they have constructors, fields, and non-trivial check() logic (I/O/exception handling and percentile calculation). The enclosing CodahaleHealthChecker also contains a registerHealthChecks utility method that wires these checks into a registry.

5. Local Symptom Summary:
- The subclasses implement the parent’s contract directly and add fields/logic that are aligned with HealthCheck responsibilities. There is no sign they inherit but refuse to use the parent’s functionality.

NO, I did not find Refused Bequest. Evidence: the subclasses meaningfully override the core check() method and add fields/logic aligned with health-check behavior rather than unrelated responsibilities."
ClassicPluginStrategy.java,"1. Inheritance Pattern:  
- The top-level class ClassicPluginStrategy does not extend a class; it implements the PluginStrategy interface.  
- There are inner classes that extend other classes:
  - DependencyClassLoader extends java.lang.ClassLoader.
  - AntClassLoader2 extends AntWithFindResourceClassLoader (a Jenkins/Ant class loader).

2. Use of Inherited Functionality:  
- DependencyClassLoader provides substantial overrides of ClassLoader APIs: findClass, findResources, findResource, and it calls the superclass constructor. These overrides implement custom class/resource lookup behavior (searching plugin dependencies/transitive plugins) — not trivial passthroughs.  
- AntClassLoader2 overrides defineClassFromData to apply a bytecode transformer before delegating to super.defineClassFromData — a meaningful specialization (not just a one-liner call to super).  
- The outer ClassicPluginStrategy implements PluginStrategy methods (getShortName, createPluginWrapper, load, startPlugin, updateDependency, etc.) and uses its own fields rather than inheriting behavior (it does not extend a parent to inherit behavior).

3. New/Independent Functionality:  
- ClassicPluginStrategy declares many fields (pluginManager, coreClassLoader, etc.) and many methods for plugin packaging, exploding archives, creating classloaders, parsing manifests, handling dependencies, and more. These represent significant functionality specific to plugin management.  
- The inner class DependencyClassLoader holds its own dependency list and transientDependencies state and implements dependency-aware loading — again a specialized responsibility.

4. Breadth of Subclass:  
- ClassicPluginStrategy (the main class) is non-trivial: many fields and many methods (file I/O, manifest handling, classloader construction, plugin lifecycle management).  
- The inner subclasses are also non-trivial with multiple methods and fields relevant to class loading.

5. Local Symptom Summary:  
- There is no clear Refused Bequest symptom. The main class does not extend a parent class, and the inner classes that do extend (ClassLoader and AntWithFindResourceClassLoader) meaningfully override and specialize inherited behavior in ways consistent with their responsibilities (custom class/resource lookup and bytecode transformation).

NO, I did not find Refused Bequest."
ClientHead.java,"1. Inheritance Pattern:
- This file defines ""public class ClientHead"" and it does not extend any other class (no ""extends"" clause). There is no parent class.

2. Use of Inherited Functionality:
- Not applicable: there are no inherited members to use/override. There are no method overrides, no uses of super., and no interaction with inherited state.

3. New/Independent Functionality:
- Yes. The class declares many fields and methods for managing transports, channels, namespace clients, handshake data, ack manager, store, scheduler, ping timeout scheduling, and disconnect behavior. These are substantial, self-contained responsibilities.

4. Breadth of Subclass:
- The class is non-trivial: many fields, multiple collections, and many methods implementing significant behavior (bindChannel, send, schedulePingTimeout, upgradeCurrentTransport, disconnect, etc.).

5. Local Symptom Summary:
- Because the class does not extend any other class, there are no symptoms of Refused Bequest in this file (cannot refuse a bequest if nothing is inherited).

NO, I did not find Refused Bequest."
Closer.java,"1. Inheritance Pattern:
- This file does not define a class that extends another concrete class. The top-level class is `public final class Closer` which implements the `Closeable` interface (no `extends` clause). The two nested classes (`LoggingSuppressor`, `SuppressingSuppressor`) are `static final` and implement the `Suppressor` interface; they do not extend a superclass other than `Object`.

2. Use of Inherited Functionality:
- Because `Closer` does not extend another class, there are no inherited concrete superclass methods or protected fields to override or call via `super.`. `Closer` implements `Closeable.close()` (interface implementation), and the nested classes implement the `Suppressor.suppress(...)` method. There are no trivial overrides of a parent class or calls to `super.*` in this file.

3. New/Independent Functionality:
- `Closer` defines its own fields (a `Deque<Closeable> stack`, `Throwable thrown`, and a `Suppressor suppressor`) and many methods (`create`, `register`, three overloads of `rethrow`, and `close`) implementing resource-collection/closing logic. This functionality is self-contained and consistent with its role; it is not a subclass repurposing an unrelated parent responsibility.

4. Breadth of Subclass:
- Not applicable as a subclass — `Closer` is non-trivial (several fields and methods), but it is not extending a parent class. The nested suppressor implementations are small but purposeful.

5. Local Symptom Summary:
- There are no symptoms of Refused Bequest: no class extends a parent and then ignores or fails to use inherited members. The code implements interfaces and provides its own cohesive functionality related to resource closing.

Final verdict:
NO, I did not find Refused Bequest."
Tokeniser.java,"1. Inheritance Pattern:
- The file defines ""final class Tokeniser"".
- It does not declare ""extends ...""; it only implicitly extends java.lang.Object.

2. Use of Inherited Functionality:
- There are no overrides of Object methods (no toString/equals/hashCode/etc).
- There is no use of super. and no interaction with inherited protected/state members from a superclass (because there is no non-Object superclass).

3. New/Independent Functionality:
- The class introduces many fields (reader, errors, state, buffers, pending tokens, etc.) and many parsing methods (read, emit variants, consumeCharacterReference, unescapeEntities, etc.) implementing a full tokenizer — clearly its own substantial responsibility.

4. Breadth of Subclass:
- The class is non-trivial: many fields, helpers, and parsing logic — not a thin extension or marker.

5. Local Symptom Summary:
- Refused Bequest is not applicable here: the class does not extend a meaningful parent, so there is no inherited contract being refused. Main evidence: the class is final and does not extend any other class (only Object), so there are no inherited members to ignore.

Final verdict:
NO, I did not find Refused Bequest."
HazelcastPubSubStore.java,"1. Inheritance Pattern:
- The file defines class HazelcastPubSubStore which implements the PubSubStore interface; it does not extend any parent class.

2. Use of Inherited Functionality:
- Because it implements an interface rather than extending a concrete class, there is no use of inherited fields or calls to super.*.
- It provides implementations for the interface methods publish, subscribe, unsubscribe, and shutdown. shutdown() is an empty/no-op implementation (a trivial implementation), while publish/subscribe/unsubscribe contain concrete Hazelcast logic.

3. New/Independent Functionality:
- The class introduces its own fields: hazelcastPub, hazelcastSub, nodeId, and a ConcurrentMap for tracking registration IDs.
- It contains Hazelcast-specific logic (getting topics, registering MessageListeners that filter by nodeId, managing registration IDs) — responsibilities tied to Hazelcast pub/sub behavior.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields and several non-trivial methods implementing subscription management and publish semantics.

5. Local Symptom Summary:
- This class does not extend a parent class, so the Refused Bequest smell (subclass inheriting but refusing parent behavior) is not applicable here. The only mildly trivial override is shutdown() being empty, but that alone is not evidence of Refused Bequest.

Final verdict:
NO, I did not find Refused Bequest."
ContentType.java,"1. Inheritance Pattern:
- This file declares ""public class ContentType"" with no explicit ""extends"" clause. It implicitly extends java.lang.Object (no custom parent class is defined).

2. Use of Inherited Functionality:
- There are no overrides of inherited methods (no toString, equals, hashCode, etc.).
- There is no use of super. or direct interaction with inherited state beyond default Object behavior.
- Therefore the class does not override, call, or meaningfully use parent-class behavior.

3. New/Independent Functionality:
- The class defines many constants, compiled Patterns, fields (contentTypeHeader, contentType, encoding, boundary) and methods for parsing and exposing Content-Type details (getDetailFromContentHeader, getters, isMultipart, tryUTF8).
- These are self-contained parsing/representation responsibilities unrelated to any parent contract.

4. Breadth of Subclass:
- The class is non-trivial: several private static constants, compiled regex Patterns, fields, and multiple public methods. It is more than a light extension or marker.

5. Local Symptom Summary:
- Because this class does not extend a custom parent (only Object) and thus has no inherited contract to refuse, it does not show Refused Bequest. The clearest sign is the absence of any superclass beyond Object and the lack of overrides or use of super.

NO, I did not find Refused Bequest."
ResultLoaderMap.java,"1. Inheritance Pattern:
- Yes. The file defines a nested private static class ClosedExecutor that extends BaseExecutor.

2. Use of Inherited Functionality:
- ClosedExecutor calls the BaseExecutor constructor (super(null, null)) but otherwise does not meaningfully use inherited behavior. It overrides the core executor methods:
  - isClosed() returns true,
  - doUpdate(...), doFlushStatements(...), doQuery(...), doQueryCursor(...) all throw UnsupportedOperationException.
- No calls to super.method(...) or interaction with inherited state beyond the constructor.

3. New/Independent Functionality:
- ClosedExecutor does not introduce new fields and only provides trivial/guarding behavior (marking itself closed and throwing for operations). It represents a different responsibility (a deliberately non-functional/closed executor) rather than specializing BaseExecutor behavior.

4. Breadth of Subclass:
- The subclass is small and non-trivial only in that it overrides several core methods, but those overrides are minimal and uniformly refuse functionality. It is not a rich extension with substantial new state or logic.

5. Local Symptom Summary:
- The ClosedExecutor shows strong symptoms of Refused Bequest: it inherits from BaseExecutor but refuses to implement the parent's core responsibilities (overrides core methods to throw UnsupportedOperationException and only reports itself as closed). The clearest sign: ""several core methods overridden to throw UnsupportedOperationException; only constructor calls super and isClosed returns true.""

YES, I found Refused Bequest — ClosedExecutor overrides BaseExecutor's core operations to refuse/disable them (throws UnsupportedOperationException) instead of meaningfully using or specializing inherited behavior."
HikariConfig.java,"1. Inheritance Pattern:
- This file defines class HikariConfig which implements the interface HikariConfigMXBean. It does not extend any other class (no ""extends"" clause). So there is no parent class in the sense of class inheritance here.

2. Use of Inherited Functionality:
- The class implements/overrides several methods from HikariConfigMXBean (getters/setters). Those overrides are used to access and validate the class's own fields (some contain non-trivial validation logic, e.g., setConnectionTimeout, setValidationTimeout, setMaximumPoolSize).
- There is no use of super. or direct interaction with inherited state from a superclass because there is no superclass.

3. New/Independent Functionality:
- The class declares many fields (timeouts, pool settings, DataSource, properties, metrics/health registries, threadFactory, etc.) and many methods to manipulate/validate them (validate(), validateNumerics(), loadProperties(), generatePoolName(), copyStateTo(), etc.). This is substantial, self-contained functionality centered on configuring a connection pool.

4. Breadth of Subclass:
- HikariConfig is non-trivial: many fields and many methods (construction, validation, property loading, logging, JNDI lookup, copying state). It is a full-featured configuration class, not a thin wrapper.

5. Local Symptom Summary:
- Refused Bequest is not applicable here because HikariConfig does not extend another class. The class implements an interface and provides meaningful implementations for those methods, while otherwise containing extensive independent functionality.

Final verdict:
NO, I did not find Refused Bequest — the class does not extend a parent class (only implements an interface), and it meaningfully implements interface methods while containing substantial, self-contained configuration behavior."
Configuration.java,"1. Inheritance Pattern:
- This file defines class Configuration but it does not extend any other class (no ""extends"" clause). Parent class: none.

2. Use of Inherited Functionality:
- Not applicable: there are no inherited methods/fields to override or call. The class has no overrides and contains no super.method() usage.

3. New/Independent Functionality:
- The class declares its own fields (environment, settings, useSmart, enableRemoteDict, enableLowercase) and methods (getters, setUseSmart, getConfigInPluginDir, constructor logic). These are self-contained responsibilities for configuration handling.

4. Breadth of Subclass:
- Not applicable as it is not a subclass. The class is small-to-moderate in size (a few fields and accessor methods), not a large subclass hierarchy extension.

5. Local Symptom Summary:
- Because there is no inheritance here, there are no signs of Refused Bequest in this file.

NO, I did not find Refused Bequest."
VCardResultParser.java,"1. Inheritance Pattern:
- Yes. The class VCardResultParser extends ResultParser.

2. Use of Inherited Functionality:
- It overrides parse(Result) with a substantial implementation (not a trivial one-liner).
- It calls getMassagedText(result) (likely provided by ResultParser) and references EMPTY_STR_ARRAY (likely inherited). It does not call super.parse(...) or otherwise delegate to parent behavior, nor does it access many inherited fields/methods beyond those helper utilities.

3. New/Independent Functionality:
- Yes. The class defines many static Pattern constants and numerous parsing helpers (matchVCardPrefixedField, decodeQuotedPrintable, maybeAppendFragment, formatNames, etc.). These implement extensive VCard-specific parsing logic and state handling unrelated to generic parser duties.

4. Breadth of Subclass:
- The subclass is non-trivial: many fields and many private/static methods implement a full parsing subsystem.

5. Local Symptom Summary:
- Although VCardResultParser introduces a lot of new, specialized functionality and implements parse itself, it does make modest, appropriate use of inherited helpers (getMassagedText and EMPTY_STR_ARRAY). The heavy specialization appears appropriate for a concrete ResultParser for vCard data rather than a subclass refusing its parent's contract.

NO, I did not find Refused Bequest. Evidence: meaningful override of parse plus use of inherited helper utilities (getMassagedText, EMPTY_STR_ARRAY); the added functionality is VCard-specific parsing, which fits the expected role of a ResultParser subclass."
InterceptorProcessor.java,"1. Inheritance Pattern:
- This file defines ""public class InterceptorProcessor"" and it does not extend any other class (no ""extends"" clause). So there is no parent class in this file.

2. Use of Inherited Functionality:
- Not applicable: there are no overridden methods, no uses of super., and no inherited fields referenced because InterceptorProcessor does not extend a superclass here.

3. New/Independent Functionality:
- The class declares its own fields (locationMatcher, interceptorMethodConfig, exceptionHandlerConfig, classLoader) and many methods (process, errorHandler, plus getters/setters). It implements substantial logic for bytecode manipulation, bindings, inline handling, try/catch insertion, etc.

4. Breadth of Subclass:
- Not applicable as a subclass. The class is non-trivial (many fields and substantial methods), but it is not extending another class.

5. Local Symptom Summary:
- There is no subclassing in this file, so the Refused Bequest smell cannot apply here. The clearest sign: the class does not extend any parent (no ""extends"" usage).

Final determination:
NO, I did not find Refused Bequest — the class does not extend another class, so it cannot refuse a parent's bequest."
HandleCallbackParam.java,"1. Inheritance Pattern:
- This class does not extend any other class; it implements the Serializable interface.
- Implicitly it extends java.lang.Object (as all classes do).

2. Use of Inherited Functionality:
- The only explicit inherited method overridden is Object.toString(), which is a normal, simple POJO stringifier.
- There is no use of super. or interaction with protected/inherited state from a superclass (because there is no explicit superclass beyond Object).

3. New/Independent Functionality:
- The class introduces its own fields (logId, logDateTim, handleCode, handleMsg) and corresponding getters/setters, plus constructors and toString.
- These are self-contained POJO responsibilities (data carrier), unrelated to any parent class behavior.

4. Breadth of Subclass:
- The class is small and straightforward (a few fields, getters/setters, constructors, toString) — non-trivial but not large. It is a simple data-transfer object.

5. Local Symptom Summary:
- There is no subclassing of a meaningful parent and the file contains no signs of refusing a parent's contract. The only override is toString, and the class primarily defines its own fields/behavior as a POJO.

Final conclusion per instructions:
NO, I did not find Refused Bequest."
SimpleWebServer.java,
AbstractWriteHolder.java,"1. Inheritance Pattern:
- Yes. The class extends AbstractHolder (it declares ""public abstract class AbstractWriteHolder extends AbstractHolder"").

2. Use of Inherited Functionality:
- It calls super(...) in the constructor.
- It calls several inherited methods/accessors: getGlobalConfiguration(), getClazz(), getHead(), getConverterMap(), setConverterMap(), and likely others from AbstractHolder.
- It also overrides/implements methods (e.g., ignore(...) is annotated @Override, and several interface methods are implemented by delegating to its own getters). The overrides are not trivial one-liners in every case (ignore contains logic); most behavior appears to build on the parent's API rather than blatantly ignoring it.

3. New/Independent Functionality:
- Yes. The subclass introduces many fields and responsibilities specific to writing: needHead, relativeHeadRowIndex, excelWriteHeadProperty, writeHandlerMap, ownWriteHandlerMap, style and merge handling flags/collections, include/exclude column collections, and many helper methods for handler sorting, style/width/row-height strategies, and compatibility with older code.

4. Breadth of Subclass:
- The class is non-trivial: many private helper methods and a lot of fields and initialization logic. It is a substantial extension, not a simple marker.

5. Local Symptom Summary:
- Although the subclass adds a large amount of write-specific state and behavior, it also makes substantive use of inherited state and methods (configuration, class/head info, converter map). The new functionality appears to be a specialization (write-related) that builds on the parent's facilities rather than refusing them.

Final verdict:
NO, I did not find Refused Bequest. Evidence: the subclass both heavily uses inherited methods/state (getGlobalConfiguration(), getClazz(), getHead(), converter map) and adds write-specific extensions — indicating specialization rather than a refused bequest."
TestProxies.java,"1. Inheritance Pattern:  
   - The file defines public class TestProxies. It does not explicitly extend any other class (it only implicitly extends java.lang.Object).

2. Use of Inherited Functionality:  
   - There are no method overrides in this class, no calls to super., and no direct use of inherited protected members. All methods are test methods annotated with @Test and implement their own logic.

3. New/Independent Functionality:  
   - The class introduces a suite of test methods that construct HikariConfig/HikariDataSource, obtain Connections, exercise PreparedStatement/Statement/Connection proxies and exception paths. This is independent testing logic unrelated to any superclass behavior.

4. Breadth of Subclass:  
   - The class is non-trivial in the sense that it contains multiple test methods, but it defines no new fields — only several methods that implement testing scenarios.

5. Local Symptom Summary:  
   - There are no signs of Refused Bequest: the class does not extend a meaningful parent (no explicit superclass) and does not inherit/override parent behavior while focusing on unrelated functionality.

NO, I did not find Refused Bequest."
JITDataModel.java,"1. Inheritance Pattern:  
This class does not extend a concrete parent class; it implements the interface IReadOnlyJITDataModel. (Implicitly it extends java.lang.Object, but there is no explicit superclass other than Object.)

2. Use of Inherited Functionality:  
There are many @Override methods, but they are implementations of the IReadOnlyJITDataModel interface, not overrides of a non-trivial superclass. There are no calls to super.* and no use of inherited state from a parent class beyond the implicit Object methods. No trivial overrides of a parent class are present.

3. New/Independent Functionality:  
Yes — the class declares many fields (packageManager, stats, jitEvents, codeCacheTagList, compilerThreads, endOfLog, jdkMajorVersion, baseTimestamp) and many methods for managing events, stats, packages, compiler threads, building MetaClass objects, etc. This is significant, independent functionality.

4. Breadth of Subclass:  
The class is non-trivial: multiple collections, state fields, and many public methods (event handling, stat updates, meta-class building, code-cache handling). It is clearly more than a light extension or marker.

5. Local Symptom Summary:  
Refused Bequest is not applicable here because the class does not extend a substantive parent class whose protected members it would be refusing to use. The class implements an interface and provides rich, self-contained behavior.

NO, I did not find Refused Bequest."
BytecodeInstruction.java,"1. Inheritance Pattern:
- This file defines public class BytecodeInstruction. It does not extend any other class (no ""extends"" clause). Parent class: none (implicitly extends java.lang.Object).

2. Use of Inherited Functionality:
- There are overrides of Object methods: toString(), hashCode(), equals(...). These are typical and do not call super.*; there are no calls to super., and no use of inherited state from a custom parent. No other inherited methods/fields are referenced.

3. New/Independent Functionality:
- The class introduces its own fields (offset, opcode, parameters, hasComment, comment, logger) and many methods to build string representations, manage parameters/comments, and handle switch-specific formatting. This is substantial, self-contained functionality.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields, many methods (toString variants, toStringSwitch/toStringNonSwitch, getLabelLines, parameter handling, comment processing, equals/hashCode), so it is a full-featured, standalone type.

5. Local Symptom Summary:
- Because BytecodeInstruction does not extend any other class (other than Object), there is no evidence of a subclass refusing a parent's bequest. The only overrides are standard Object methods and there are no super calls or inherited-protected-member usage to inspect.

NO, I did not find Refused Bequest."
BatchResult.java,"1. Inheritance Pattern:
- This file defines ""public class BatchResult"" with no explicit ""extends"" clause. It therefore only inherits from java.lang.Object. (No custom parent class.)

2. Use of Inherited Functionality:
- There are no overrides of Object methods (no toString, equals, hashCode, etc.).
- The only call to super is a trivial super() in the constructor. No use of inherited fields or meaningful calls to parent behavior.

3. New/Independent Functionality:
- The class introduces its own fields (mappedStatement, sql, parameterObjects, updateCounts) and provides getters, a setter, and addParameterObject; these are its primary responsibilities (a small data holder for batch execution).

4. Breadth of Subclass:
- The class is non-trivial in the sense it defines multiple fields and methods, but it is a small, self-contained DTO/holder rather than an extension or specialization of a superclass.

5. Local Symptom Summary:
- Because the class does not extend a domain superclass (only Object), it cannot exhibit Refused Bequest in the usual sense: there is no inherited contract being ignored. The only inherited interaction is a trivial super() constructor call.

NO, I did not find Refused Bequest. Evidence: class does not extend a custom parent (only Object) and contains no meaningful overrides or use of inherited behavior."
AbstractSendMessageProcessor.java,"1. Inheritance Pattern:
- Yes. The class AbstractSendMessageProcessor extends AsyncNettyRequestProcessor (and also implements NettyRequestProcessor).

2. Use of Inherited Functionality:
- Very little visible use of inherited features in this file. There are no calls to super.* and no access to apparent inherited protected fields. The only override shown is rejectRequest(), which is trivial (returns false). No substantial method overrides or calls to parent behavior are present here.

3. New/Independent Functionality:
- Yes. The class defines multiple fields (brokerController, storeHost, sendMessageHookList) and many domain-specific methods: buildMsgContext, buildInnerMsg, msgContentCheck, msgCheck, registerSendMessageHook, doResponse, executeSendMessageHookBefore/After, parseRequestHeader, decodeSendMessageHeaderV2, etc. These implement message construction, topic validation, hook management, response handling — responsibilities specific to message/broker logic rather than generic request-processing.

4. Breadth of Subclass:
- Non-trivial. The class contains many methods and logic, not just a marker or a light extension.

5. Local Symptom Summary:
- The subclass shows symptoms consistent with Refused Bequest: it introduces substantial domain-specific functionality (many fields/methods for message/broker logic) while scarcely overriding or using the parent class’s behavior (only a trivial rejectRequest override, no super calls).

Final verdict:
YES, I found Refused Bequest — evidence: many new fields/methods implementing broker-specific message handling while only a trivial override (rejectRequest) and no use of inherited behavior."
StpLogic.java,"NO, I did not find Refused Bequest.

Step-by-step answers:

1. Inheritance Pattern:
- This file defines class StpLogic with no ""extends"" clause. It does not extend any other class.

2. Use of Inherited Functionality:
- Not applicable: there are no superclass methods or fields to override or call (no use of super.), so no evidence of weak/partial use of inherited members.

3. New/Independent Functionality:
- The class declares its own field (loginType) and many methods implementing token/session/login/logout/permission/role/safety logic and key-splicing helpers. These are clearly self-contained responsibilities.

4. Breadth of Subclass:
- The class is non-trivial: dozens of methods and substantial logic. But since it is not a subclass, this indicates a large standalone class rather than a subclass refusing a parent's contract.

5. Local Symptom Summary:
- Because StpLogic does not extend a parent class, the Refused Bequest smell cannot apply here. The clearest sign is simply the absence of inheritance (no extends / no overrides)."
QueueTest.java,"1. Inheritance Pattern:
- The file defines public class QueueTest which does not declare ""extends"". It does not extend any explicit parent class (implicitly extends java.lang.Object).

2. Use of Inherited Functionality:
- Not applicable: since QueueTest does not subclass another custom class, there are no overrides, no use of super., nor interaction with inherited protected state from a parent class.

3. New/Independent Functionality:
- The class introduces many test methods and two private helper methods (assertEqualsAndHash, assertValues). These are test utilities and test cases focused on Queue behavior, not extending or specializing a parent class.

4. Breadth of Subclass:
- The class is non-trivial (many test methods), but it contains no additional fields and is a standalone test class rather than a domain subclass.

5. Local Symptom Summary:
- There is no subclassing in this file, so the symptoms of Refused Bequest (subclass ignoring inherited behavior while adding unrelated functionality) cannot appear here.

NO, I did not find Refused Bequest (class does not extend another class)."
DetectionResultRowIndicatorColumn.java,"1. Inheritance Pattern:
- Yes. The file defines class DetectionResultRowIndicatorColumn which extends DetectionResultColumn.

2. Use of Inherited Functionality:
- The subclass calls super(boundingBox) in its constructor and calls super.toString() in its toString() override.
- It makes regular use of inherited accessors/utility methods/state: getCodewords(), getBoundingBox(), imageRowToCodewordIndex() (presumably inherited from DetectionResultColumn).
- It only overrides one method (toString) and that override is trivial (adds ""IsLeft: ..."" then delegates to super.toString()). There are no other meaningful overrides of parent behavior in this file.

3. New/Independent Functionality:
- Yes. The class introduces its own field (isLeft) and many methods focused on row-indicator logic: setRowNumbers(), adjustCompleteIndicatorColumnRowNumbers(...), adjustIncompleteIndicatorColumnRowNumbers(...), getRowHeights(), getBarcodeMetadata(), removeIncorrectCodewords(...), isLeft().
- These methods contain substantial domain-specific logic (looping, validation, metadata extraction) unrelated to a simple column container.

4. Breadth of Subclass:
- The subclass is non-trivial: multiple multi-page methods with loops and conditional logic, and its own state. It is clearly more than a light extension or marker.

5. Local Symptom Summary:
- The class reuses a few inherited helpers/getters but otherwise implements extensive, separate responsibilities specific to row-indicator handling and provides only a trivial override of parent behavior.

Final judgment:
YES, I found Refused Bequest — many new fields and complex methods implementing row-indicator logic, but only trivial overrides of the parent (only toString) and limited reliance on inherited behavior, suggesting the subclass focuses on a different domain than the parent."
RedissonSessionRepository.java,"1. Inheritance Pattern:  
- This file does not define a class that extends another class. RedissonSessionRepository implements interfaces (FindByIndexNameSessionRepository and PatternMessageListener). The inner class RedissonSession implements the Session interface. No ""extends"" parent class is present.

2. Use of Inherited Functionality:  
- Because there is no superclass, there are no inherited concrete methods or fields to override or call via super. The class and its inner class implement interface methods (e.g., createSession, save, findById, deleteById, findByIndexNameAndIndexValue, onMessage, and Session methods in RedissonSession). None of these call super.* (there is no super implementation). Some implementations are substantial (many methods do non-trivial work), while one is a trivial no-op (save() is empty because changes are stored in real time).

3. New/Independent Functionality:  
- The class introduces many fields (RedissonClient redisson, ApplicationEventPublisher eventPublisher, various RPatternTopic fields, keyPrefix, defaultMaxInactiveInterval) and many methods for session storage, event handling, key naming, and principal index management. The inner RedissonSession class has significant state and behavior interacting with Redis structures. This represents concrete responsibilities around Redis-backed session management.

4. Breadth of Subclass:  
- The class is non-trivial: it provides a sizable API, internal helpers, event handling, and a complex inner Session implementation with many methods and Redis interactions. It is not a thin wrapper or marker.

5. Local Symptom Summary:  
- The Refused Bequest smell is about a subclass inheriting from a parent class but refusing to use the parent's members. Here there is no superclass inheritance, so that pattern does not apply.

Final determination:
NO, I did not find Refused Bequest."
RelationshipTest.java,"1. Inheritance Pattern:  
Yes — this class extends AbstractFakerTest.

2. Use of Inherited Functionality:  
Yes — the subclass calls super.before() in its @Before method and uses an inherited faker instance (calls faker.relationships() in many tests). It does override the before() setup method but immediately delegates to super.before() and then adds mock initialization (not a trivial one-liner that only calls super).

3. New/Independent Functionality:  
It introduces a private Faker mockFaker field and many test methods focused on Relationships behavior and exception cases. However, these are test-specific additions that build on the parent’s testing setup rather than unrelated domain logic.

4. Breadth of Subclass:  
The class is non-trivial in terms of number of test methods, but it only adds a single field and test methods — typical for a test subclass that specializes behavior for a particular component.

5. Local Symptom Summary:  
The subclass makes meaningful use of inherited setup and state (super.before(), faker) and only adds test-specific behavior; it does not ignore or refuse the parent’s responsibilities.

Conclusion: NO, I did not find Refused Bequest — evidence: uses inherited faker and calls super.before(); only adds test methods and a mock field rather than unrelated functionality."
BaseSwaggerConfig.java,"1. Inheritance Pattern:  
   This file defines an abstract class BaseSwaggerConfig. It does not explicitly extend any other class (implicitly extends java.lang.Object).

2. Use of Inherited Functionality:  
   There are no overrides of parent/Object methods, no use of super., and no direct interaction with inherited state. All methods are self-contained (helpers and a @Bean factory).

3. New/Independent Functionality:  
   The class introduces several methods that build and configure a Swagger Docket (createRestApi, apiInfo, securitySchemes, securityContexts, defaultAuth, getContextByPath) and declares an abstract swaggerProperties() method. These represent its own responsibility (Swagger configuration).

4. Breadth of Subclass:  
   The class is non-trivial: it contains multiple private helper methods and a public factory method. (There are no fields, but multiple substantial methods.)

5. Local Symptom Summary:  
   The file does not show the Refused Bequest pattern: it defines a base class providing concrete behavior to be reused by subclasses rather than a subclass that ignores its parent. The clearest sign is that there is no explicit superclass to be refused and no overrides or use of inherited members.

NO, I did not find Refused Bequest. Evidence: no explicit superclass or overridden inherited behavior; this is a base class that supplies functionality for subclasses to reuse."
MapperBuilderAssistant.java,"1. Inheritance Pattern:
- Yes. The file defines ""public class MapperBuilderAssistant extends BaseBuilder"". The parent class is BaseBuilder.

2. Use of Inherited Functionality:
- The subclass calls super(configuration) in its constructor.
- It heavily uses an inherited configuration field/API throughout (configuration.get*, configuration.add*, configuration.isLazyLoadingEnabled(), etc.).
- It also calls inherited helper methods (e.g., resolveTypeHandler(...) — this method is not defined in this file and is likely provided by BaseBuilder).
- The class does not override parent methods in this file; there are no non-trivial overrides or methods that only call super.method() apart from the constructor.

3. New/Independent Functionality:
- Yes. The class introduces its own fields: currentNamespace, resource, currentCache, unresolvedCacheRef.
- It implements many mapper-specific methods: applyCurrentNamespace, useCacheRef, useNewCache, addParameterMap, buildParameterMapping, addResultMap, buildDiscriminator, addMappedStatement, buildResultMapping, parsing helpers, type-resolution helpers, etc. These represent substantial, domain-specific responsibilities for building mappers.

4. Breadth of Subclass:
- The subclass is non-trivial: multiple fields and many methods (builder logic, parsing, mapping, cache management). It is a large, focused implementation rather than a light extension or marker.

5. Local Symptom Summary:
- The class adds a lot of mapper-specific behavior but also makes substantial, repeated use of inherited state and helper functionality (configuration and likely helper methods from BaseBuilder). There are no signs of trivial overrides or ignoring the parent’s API.

Final decision:
NO, I did not find Refused Bequest — the subclass extensively uses inherited state and utilities (configuration, resolveTypeHandler), and its additional responsibilities appear to be a legitimate specialization (mapper-building) rather than an unrelated replacement."
BuildCommand.java,"1. Inheritance Pattern:
- Yes. The file defines BuildCommand which extends CLICommand.
- It also defines a nested class CLICause which extends UserIdCause.

2. Use of Inherited Functionality:
- BuildCommand overrides several core CLICommand members: getShortDescription(), protected int run(), and printUsageSummary(). These are substantial overrides that implement the main command behavior rather than trivial passthroughs.
- The subclass also uses inherited members (e.g., stdout and getClientCharset(), which are likely provided by CLICommand), so it interacts with the parent's runtime/IO support.
- None of the overrides are mere one-liners calling super.method(); they provide full implementations.

3. New/Independent Functionality:
- BuildCommand introduces many new fields (options and arguments: job, follow, sync, wait, checkSCM, parameters, consoleOutput, retryCnt) and substantial logic in run() for parameter handling, SCM checks, scheduling builds, waiting, printing logs, and handling interrupts/errors. This is new behavior but it is the expected specialization for a CLI command implementation.
- The nested CLICause class provides its own fields and overrides (getShortDescription, print, equals, hashCode) to customize cause reporting.

4. Breadth of Subclass:
- The subclass is non-trivial: multiple fields, a long run() implementation, and a usage-summary printer. This is a full-featured command implementation, not a light extension.

5. Local Symptom Summary:
- The class provides substantial overrides of parent behaviors, uses inherited IO/runtime facilities, and implements the command's responsibilities. The new functionality aligns with the role of a CLICommand subclass (implementing a specific command) rather than ignoring the parent API.

Final verdict:
NO, I did not find Refused Bequest. Main evidence: substantial, meaningful overrides of core CLICommand methods and direct use of inherited members (e.g., stdout/getClientCharset), indicating proper specialization rather than refusal of the parent's responsibilities."
FrameworkField.java,"1. Inheritance Pattern:  
Yes. The file defines class FrameworkField which extends FrameworkMember<FrameworkField>.

2. Use of Inherited Functionality:  
FrameworkField overrides several inherited methods: getName(), isShadowedBy(...), isBridgeMethod(), getModifiers(), getType(), getDeclaringClass(), and toString(). None of the overrides call super.*; most overrides provide concrete behavior by delegating to the contained java.lang.reflect.Field (e.g., getName -> field.getName(), getType -> field.getType(), getModifiers -> field.getModifiers()). One override is trivial (isBridgeMethod() just returns false), but the majority are meaningful implementations of the parent contract rather than one-line wrappers of super.

3. New/Independent Functionality:  
The class introduces a private final Field field and several methods that operate on it: getField(), getAnnotations(), getAnnotation(...), get(Object), and the constructor that sets accessibility. These are directly related to representing/wrapping a java.lang.reflect.Field.

4. Breadth of Subclass:  
The subclass is non-trivial: it has its own state (the wrapped Field) and multiple methods to expose/translate Field behavior into the FrameworkMember API. It is not merely a marker, though it has only one field.

5. Local Symptom Summary:  
This subclass implements multiple inherited abstract/virtual methods and provides field-backed behavior that matches the class’s role as a wrapper for java.lang.reflect.Field. It does not appear to ignore or refuse the parent’s contract.

Final verdict:
NO, I did not find Refused Bequest. The class actively implements the parent’s contract via several meaningful overrides and provides cohesive functionality for wrapping a Field."
CmsSubjectCategoryExample.java,"1. Inheritance Pattern:
- Yes. The inner class Criteria extends the inner abstract class GeneratedCriteria. (Parent: GeneratedCriteria.)

2. Use of Inherited Functionality:
- Criteria does not override any methods from GeneratedCriteria and contains only a trivial constructor that calls super(). It does not call super.method() elsewhere or add behavior that customizes inherited methods. The bulk of the query-building methods (andId..., andName..., etc.) are defined in GeneratedCriteria and simply inherited.

3. New/Independent Functionality:
- The subclass Criteria introduces no new fields and no new methods aside from the protected no-arg constructor. It does not add new responsibilities.

4. Breadth of Subclass:
- The subclass is trivial (one small constructor). It is not a non-trivial extension — it appears to exist only to provide a concrete type.

5. Local Symptom Summary:
- This subclass does not show symptoms of Refused Bequest: it does not add unrelated functionality nor ignore the parent’s members — instead it is a thin concrete subclass of a feature-rich abstract parent.

Final verdict:
NO, I did not find Refused Bequest. Main evidence: Criteria is a minimal subclass with only a trivial constructor and no meaningful overrides or new fields/methods."
GsonBuilder.java,"1. Inheritance Pattern:
- This file defines public final class GsonBuilder with no explicit ""extends"" clause. It therefore only inherits from java.lang.Object (no custom parent class).

2. Use of Inherited Functionality:
- There are no method overrides, no calls to super.*, and no interaction with inherited protected state. All methods are class-specific builder/configuration methods.

3. New/Independent Functionality:
- Yes. GsonBuilder declares many fields (excluder, longSerializationPolicy, fieldNamingPolicy, instanceCreators, factories, hierarchyFactories, various booleans and date settings) and many methods to configure and create a Gson. These are builder-specific responsibilities unrelated to any parent behavior.

4. Breadth of Subclass:
- The class is non-trivial: many fields, many configuration methods, and internal helper methods (create, addTypeAdaptersForDate). This is a substantial standalone component.

5. Local Symptom Summary:
- Since GsonBuilder does not extend a meaningful parent (only Object), it cannot show the Refused Bequest smell here. The class is a self-contained builder with substantial independent functionality.

Final verdict:
NO, I did not find Refused Bequest."
RedissonBloomFilter.java,
InvokeCountOperation.java,"1. Inheritance Pattern:  
- This class does not extend another class. It implements the interface IJarScanOperation.

2. Use of Inherited Functionality:  
- It implements/overrides the interface methods getReport() and processInstructions(...). There is no use of super., no access to inherited fields, and no parent-class method calls. getReport() is a small delegating result; processInstructions(...) contains the main logic (loop + switch + count calls).

3. New/Independent Functionality:  
- Yes. It declares its own fields (opcodeInvokeCountMap, limitPerInvoke) and methods (count, processInstructions, getReport) that implement counting and reporting of invoke opcodes — domain-specific behavior not coming from a superclass.

4. Breadth of Subclass:  
- The class is non-trivial: multiple fields and methods, including a non-trivial processInstructions implementation and a helper count method.

5. Local Symptom Summary:  
- Refused Bequest is not indicated here: the file does not extend a parent class, only implements an interface and provides the expected functionality. The class introduces and uses its own behavior and does not inherit unused protected members.

NO, I did not find Refused Bequest."
AbstractSentinelAspectSupport.java,"1. Inheritance Pattern:
- This file defines an abstract class AbstractSentinelAspectSupport. It does not declare ""extends"", so it does not extend any other class in this file (it implicitly extends java.lang.Object).

2. Use of Inherited Functionality:
- Not applicable as this class is a base class in this file, not a subclass. There are no overridden methods (no super. calls or explicit use of inherited protected members from a parent class are present here).

3. New/Independent Functionality:
- The class introduces many protected and private methods handling tracing, fallback/block handler resolution, method invocation and reflection utilities — substantial, self-contained responsibilities for annotation/aspect support.

4. Breadth of Subclass:
- The class is non-trivial: many methods and logic (exception tracing, resolving/invoking fallback and block handler methods, caching lookups, reflection helpers). It is a sizeable abstraction, not a light extension.

5. Local Symptom Summary:
- Because this file contains a base/utility abstract class (not a subclass of a concrete parent), there is no evidence of a subclass refusing a parent's bequest here.

Final verdict:
NO, I did not find Refused Bequest."
SaTokenConfig.java,"1. Inheritance Pattern:
- This file defines class SaTokenConfig which implements Serializable but does not extend any other class (it implicitly inherits from java.lang.Object).

2. Use of Inherited Functionality:
- The class overrides Object.toString() (producing a field-based representation). It does not call super.* anywhere, nor does it interact with any protected/inherited state from a custom parent class (there is no custom parent).

3. New/Independent Functionality:
- The class introduces many fields (tokenName, timeout, activityTimeout, isConcurrent, tokenStyle, jwtSecretKey, cookie, sso, etc.) and many getters/setters, plus some deprecated convenience methods. These represent self-contained configuration responsibilities unrelated to any parent class behavior.

4. Breadth of Subclass:
- The class is non-trivial: many fields, many accessor methods, nested config objects (SaCookieConfig, SaSsoConfig), and a substantial toString implementation.

5. Local Symptom Summary:
- Because SaTokenConfig does not extend a custom parent (only Object) and only overrides toString(), there are no signs of Refused Bequest in this file (no inherited API is being refused or ignored).

NO, I did not find Refused Bequest."
HelpCommand.java,"1. Inheritance Pattern:  
Yes. The class HelpCommand extends AnnotatedCommand.

2. Use of Inherited Functionality:  
HelpCommand overrides core inherited methods: process(CommandProcess) and complete(Completion). It does not call super.process(...) or super.complete(...), nor does it reference inherited fields or call super.* elsewhere. However, the overrides are substantial (implement full command behavior), not trivial one-liners.

3. New/Independent Functionality:  
HelpCommand introduces its own state (private String cmd) and many helper methods (createHelpModel, createHelpDetailModel, createCommandVO, createArgumentVO, createOptionVO, isEmptyName, allCommands, findCommand). These methods implement the help-related responsibilities (building view models, iterating CLI options/arguments, finding commands).

4. Breadth of Subclass:  
The subclass is non-trivial: multiple private helper methods and logic, iteration over command resolvers, building models, and completion logic — clearly more than a light extension.

5. Local Symptom Summary:  
This class does not ignore the parent contract — it overrides and implements the command lifecycle methods required by the framework. The added functionality is cohesive and focused on providing ""help"" behavior rather than unrelated domains.

NO, I did not find Refused Bequest. Evidence: the class meaningfully overrides core inherited methods to provide its intended behavior and its added methods are cohesive to the help command functionality."
UrlConnectionClient.java,"1. Inheritance Pattern:
- This file defines public class UrlConnectionClient which implements the Client interface. It does not extend any other class (implicit superclass is Object).

2. Use of Inherited Functionality:
- It implements the interface method execute(Request). It does not call super.* anywhere and has no access/use of inherited fields or protected members from a concrete parent class (there is no superclass to inherit behavior from). The only override is the interface method implementation, not an override of a superclass method.

3. New/Independent Functionality:
- Yes. The class introduces its own static field CHUNK_SIZE, several methods (openConnection, prepareRequest, readResponse, execute) and a private static inner class TypedInputStream. These contain substantial HTTP-specific logic (opening HttpURLConnection, preparing requests, reading responses, streaming bodies).

4. Breadth of Subclass:
- The class is non-trivial: multiple helper methods and an inner class, not a light wrapper or marker.

5. Local Symptom Summary:
- Refused Bequest applies to subclasses that inherit but refuse to use a parent’s members. This class does not extend a concrete parent class at all — it implements an interface and provides its own substantial behavior. There are many new methods and no inherited-state usage, but that is expected for an implementation of an interface rather than evidence of Refused Bequest.

Final verdict:
NO, I did not find Refused Bequest."
AssemblyProcessor.java,"1. Inheritance Pattern:  
- This file defines public class AssemblyProcessor. It does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:  
- Not applicable: since AssemblyProcessor does not extend a parent class, there are no overrides, super. calls, or inherited-field accesses to inspect.

3. New/Independent Functionality:  
- The class defines several fields (StringBuilder builder, flags like assemblyStarted/methodStarted/methodInterrupted, nativeAddress/entryAddress, previousLine, List<AssemblyMethod>, Architecture) and many methods (handleLine, getStartAddress, complete, attachAssemblyToMembers, clear, getAssemblyMethods). These implement parsing and attaching assembly output — all local functionality.

4. Breadth of Subclass:  
- Not applicable as it is not a subclass. The class is non-trivial (multiple fields and methods), but it is a standalone class.

5. Local Symptom Summary:  
- There are no symptoms of Refused Bequest because there is no inheritance relationship to refuse. The class is self-contained and does not extend or fail to use a parent class.

NO, I did not find Refused Bequest. Main evidence: the class does not extend any parent (no ""extends""), so the Refused Bequest smell cannot apply here."
JavaBeanDeserializer.java,"1. Inheritance Pattern:
- This file defines class JavaBeanDeserializer which implements the interface ObjectDeserializer. It does not explicitly extend any other class (so it implicitly extends java.lang.Object).

2. Use of Inherited Functionality:
- There are no calls to super.* and no explicit overrides of meaningful inherited methods (no override of Object methods like toString/equals/hashCode/clone/etc.). The class implements interface methods (deserialze, getFastMatchToken) but does not appear to rely on or override behavior from a non-trivial parent class.

3. New/Independent Functionality:
- Yes. The class defines many fields (fieldDeserializers, sortedFieldDeserializers, beanInfo, maps, hash arrays, etc.) and a large set of methods implementing JSON deserialization, instance creation, smart matching, parsing, factory handling, enum handling, array parsing, etc. These are substantial, independent responsibilities.

4. Breadth of Subclass:
- The class is non-trivial and large, with many helper methods and complex logic — not a light extension or marker.

5. Local Symptom Summary:
- This file does not show the Refused Bequest smell: JavaBeanDeserializer is not a subclass of a richer parent whose protected members it ignores. It is a standalone implementation (implements an interface) that provides its own extensive functionality.

NO, I did not find Refused Bequest."
RetrofitError.java,"1. Inheritance Pattern:
   - Yes. The class extends RuntimeException.

2. Use of Inherited Functionality:
   - Minimal. It only calls super(message, exception) in the constructor to set the exception message and cause. It does not override RuntimeException methods or otherwise call super.* elsewhere. No meaningful overrides are present (no getMessage(), toString(), etc. are overridden).

3. New/Independent Functionality:
   - Yes. The class introduces its own fields (url, response, converter, successType, networkError), multiple static factory constructors (networkError, conversionError, httpError, unexpectedError), and several getters and conversion helpers (getUrl, getResponse, isNetworkError, getBody, getSuccessType, getBodyAs) that implement Retrofit-specific behavior.

4. Breadth of Subclass:
   - Non-trivial. Several fields and multiple methods implement substantial, Retrofit-specific responsibilities (error categorization and response-body conversion), not just a light extension.

5. Local Symptom Summary:
   - The subclass shows symptoms of Refused Bequest: it primarily implements its own domain logic and state, with few or no meaningful uses/overrides of the parent’s behavior.

Conclusion:
YES, I found Refused Bequest — evidence: many new Retrofit-specific fields and methods and only a trivial use of the parent (only calling super in the constructor; no overrides), indicating the subclass focuses on unrelated responsibilities."
Selectable.java,"1. Inheritance Pattern:
- This file defines an interface named Selectable. It does not extend any other interface or class (no ""extends"" clause).

2. Use of Inherited Functionality:
- Not applicable: this is an interface, not a subclass, so there are no overrides, no uses of super., and no inherited fields/methods being called or specialized here.

3. New/Independent Functionality:
- The interface declares many methods (xpath, css, regex, jsonPath, get, all, nodes, etc.), but it does not introduce fields or concrete implementations — just method signatures. There is no evidence of a subclass adding unrelated responsibilities in this file.

4. Breadth of Subclass:
- Not applicable: again, this is an interface rather than a concrete subclass. The interface is fairly broad (many method signatures), but that is not a subclass characteristic.

5. Local Symptom Summary:
- Because this file is an interface and not a subclass of another class, there are no local symptoms of Refused Bequest (no inheritance relationship to inspect, no trivial overrides, and no unrelated fields/methods in a subclass).

NO, I did not find Refused Bequest."
CellFormulaTagHandler.java,"1. Inheritance Pattern:
- Yes. The class is CellFormulaTagHandler and it extends AbstractXlsxTagHandler.

2. Use of Inherited Functionality:
- It overrides three methods: startElement, endElement, and characters. There are no calls to super.method() and no direct access to parent fields shown in this file. However, the overrides implement meaningful behavior (setting formula flags, building formula text) rather than trivial pass-throughs.

3. New/Independent Functionality:
- The class does not declare its own fields. Its methods perform formula-specific actions on XlsxReadSheetHolder (setting formula state, collecting formula characters), which are consistent with a tag handler role rather than unrelated responsibilities.

4. Breadth of Subclass:
- The subclass is small (three overridden methods) and focused. It is not heavy with many new fields or a wide set of unrelated methods.

5. Local Symptom Summary:
- The subclass does not show the typical symptoms of Refused Bequest. It provides focused, meaningful overrides for handling cell formulas (no many new fields or unrelated logic), even though it does not call super.

NO, I did not find Refused Bequest."
ClassWriter.java,"1. Inheritance Pattern:
- This file defines ""public class ClassWriter"" and it does not extend any other class (no ""extends"" clause). There is also no ""implements"" clause. So there is no parent class in this file.

2. Use of Inherited Functionality:
- Not applicable: the class does not override methods, call super., or reference inherited fields because it does not extend another class.

3. New/Independent Functionality:
- The class introduces many fields and methods for building Java class bytecode: constant pool management (pool, items, index, key/key2/key3, newConstItem, newUTF8, newClassItem, newFieldItem, newMethodItem, newNameTypeItem, get, put, etc.), lists of fields/methods (firstField/lastField, firstMethod/lastMethod), toByteArray(), visit(), and utility logic for resizing hash table. These are substantial, self-contained responsibilities unrelated to any parent class (since none exists here).

4. Breadth of Subclass:
- The class is non-trivial: dozens of fields and many methods, complex internal logic and data structures. It is clearly more than a light extension or marker.

5. Local Symptom Summary:
- Because this class does not inherit from any parent in this file, there are no signs of a subclass refusing a bequest. The clearest sign is simply the absence of inheritance (no extends / no use of super).

NO, I did not find Refused Bequest."
CompareToBuilder.java,"1. Inheritance Pattern:  
- This class (CompareToBuilder) does not extend any other class. It implements the Builder<Integer> interface but has no ""extends"" clause.

2. Use of Inherited Functionality:  
- Because it does not extend a parent class, there are no inherited concrete members being overridden or calls to super.*.  
- The only interface method implemented is build(), which simply returns toComparison() — a trivial one-liner that delegates to a local method.

3. New/Independent Functionality:  
- The class defines its own state (a single field: comparison) and a large set of methods (many append overloads, static reflectionCompare/reflectionAppend helpers, toComparison(), appendSuper(), etc.). These represent substantial, self-contained functionality for building compareTo semantics and reflection-based comparisons.

4. Breadth of Subclass:  
- The class is non-trivial: many methods, many overloads, both static utilities and instance behavior. It is clearly more than a marker or light extension.

5. Local Symptom Summary:  
- Because CompareToBuilder does not extend a parent class, the Refused Bequest smell (a subclass inheriting but refusing the parent’s behavior) cannot apply here. The only implemented interface method is a trivial delegation.

NO, I did not find Refused Bequest. Evidence: the class does not extend another class (only implements an interface), so there is no subclass-parent relationship to refuse; the sole implemented interface method (build) is a trivial one-liner."
DataFormatter.java,"1. Inheritance Pattern:
- This file defines public class DataFormatter, and it does not extend any other class (no ""extends"" clause). So there is no parent class in this file.

2. Use of Inherited Functionality:
- Not applicable: since DataFormatter does not extend a superclass, there are no inherited methods/fields to override, call via super., or use.

3. New/Independent Functionality:
- The class introduces many fields (patterns, symbols, caches, locale/use1904windowing/useScientificFormat flags) and numerous methods for parsing/creating formats, date and number formatting, and several nested Format subclasses (SSNFormat, ZipPlusFourFormat, PhoneFormat, InternalDecimalFormatWithScale, CellFormatResultWrapper). These represent substantial, self-contained formatting responsibilities.

4. Breadth of Subclass:
- Not applicable as a subclass. However, the class itself is non-trivial: many fields, methods, and inner classes.

5. Local Symptom Summary:
- Because DataFormatter does not inherit from any parent in this file, there is no evidence of a subclass refusing a parent's bequest. The clearest sign is simply that no inheritance relationship exists here.

NO, I did not find Refused Bequest. (Reason: class does not extend another class, so refused bequest cannot occur in this file.)"
AccessTokenModel.java,"NO, I did not find Refused Bequest.

Step-by-step:

1. Inheritance Pattern:
- This file defines class AccessTokenModel which implements Serializable. It does not explicitly extend another class (thus implicitly extends java.lang.Object).

2. Use of Inherited Functionality:
- The only inherited member overridden is toString() from Object. There are no calls to super.method(...) (except the implicit super() in the constructor). No use of inherited state or protected members from a meaningful superclass (none exist here).

3. New/Independent Functionality:
- The class introduces many fields (accessToken, refreshToken, expiresTime, refreshExpiresTime, clientId, loginId, openid, scope) and several methods (constructors, getExpiresIn, getRefreshExpiresIn, toLineMap, toString). These represent its own responsibilities as an access-token model.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields and helper methods, not a tiny marker or minimal extension.

5. Local Symptom Summary:
- Since the class does not extend a domain superclass (only implements Serializable) there is no evidence of refusing a parent's contract. The only inherited override is a meaningful toString; otherwise it does not interact with superclass behavior. Therefore no Refused Bequest symptoms.

Final verdict: NO, I did not find Refused Bequest."
NiceSecurePasswordField.java,"1. Inheritance Pattern:  
Yes. The class NiceSecurePasswordField extends StackPane.

2. Use of Inherited Functionality:  
Yes. The subclass uses StackPane API: getStyleClass(), getChildren().addAll(...), StackPane.setAlignment(...), disabledProperty().addListener(...), and it overrides requestFocus() to forward focus to the inner password field. The override is purposeful (delegation to the contained field), not a trivial no-op.

3. New/Independent Functionality:  
Yes. The class introduces many new fields and behavior: a SecurePasswordField instance, multiple FontAwesome5IconView icons, a ToggleButton, an HBox for icon layout, bindings between these elements and the passwordField properties, and methods to expose/delegate password operations. This is significant UI composition and behavior specific to this control.

4. Breadth of Subclass:  
Non-trivial. Several private fields and many methods/bindings are present, indicating substantive additional responsibilities (icon management, reveal behavior, passthrough API).

5. Local Symptom Summary:  
This subclass does not exhibit the typical Refused Bequest pattern. It makes meaningful use of the parent (StackPane) for layout, styling and child management, and it overrides requestFocus to adapt focus behavior. Although it composes and delegates to an internal SecurePasswordField, that is normal for a custom composite UI control.

Final verdict: NO, I did not find Refused Bequest. Evidence: uses StackPane's layout/children/style/properties and provides a meaningful override (requestFocus); added functionality is appropriate for a specialized UI container rather than a refusal of the parent's contract."
GeometryViewerRegistry.java,"1. Inheritance Pattern:  
- This file defines class GeometryViewerRegistry. It does not extend any other class (no ""extends"" clause). Parent class: none.

2. Use of Inherited Functionality:  
- Not applicable: since the class does not extend a parent, there are no overrides, no use of super., and no inherited fields or methods to call.

3. New/Independent Functionality:  
- The class introduces its own state and responsibilities: viewers (Map), predefinedTiles and userDefinedTiles (Lists), tilesLock, defaultLeafletTiles, plus many methods for loading/saving configuration (SAX parsing, XML building), registry initialization, tile management, and preference handling. This is substantial and self-contained functionality.

4. Breadth of Subclass:  
- The class is non-trivial: multiple fields and many methods for initialization, IO, synchronization, and preference persistence.

5. Local Symptom Summary:  
- Because this class does not inherit from any parent, it cannot exhibit Refused Bequest in this file. All functionality is self-contained and there are no inherited members being ignored or overridden.

NO, I did not find Refused Bequest."
RestMethodInfoTest.java,"1. Inheritance Pattern:
- This file defines public class RestMethodInfoTest. It does not declare ""extends"" any other class; it only implicitly extends java.lang.Object.

2. Use of Inherited Functionality:
- There are no method overrides, no calls to super.*, and no interaction with an inherited protected/instance state from a non-Object parent. (Only normal use of Object methods implicitly.)

3. New/Independent Functionality:
- The class introduces many test methods and one static field (extendingGenericCallbackType). These are self-contained testing responsibilities (JUnit tests), not specializations of a parent class.

4. Breadth of Subclass:
- The class is non-trivial (many methods), but that complexity is test logic, not evidence of specialized use/override of inherited behavior.

5. Local Symptom Summary:
- There is no evidence of a subclass refusing a parent's bequest because there is no meaningful inheritance from a non-Object parent: no overrides, no super usage, and the class is a standalone test suite.

Final verdict:
NO, I did not find Refused Bequest."
AssertUtil.java,"1. Inheritance Pattern:
- This file defines class AssertUtil which does not declare ""extends"". It implicitly extends java.lang.Object only.

2. Use of Inherited Functionality:
- There are no overrides of parent methods (no toString/equals/hashCode/etc.), no uses of super., and no direct interaction with inherited state. All methods are static utility methods operating on their arguments.

3. New/Independent Functionality:
- The class introduces only static assertion/utility methods (assertCollectionContains, assertByteArrayListEquals, assertByteArraySetEquals, assertCollectionContainsAll, assertByteArrayCollectionContainsAll). There are no fields. These methods implement independent testing logic unrelated to any parent behavior.

4. Breadth of Subclass:
- Not applicable: this is not a subclass. The class is non-trivial as a utility class (multiple methods), but it is not an extension of another type.

5. Local Symptom Summary:
- Since AssertUtil does not extend any other class (beyond Object) and contains only static utility methods with no overrides or use of inherited features, there are no symptoms of Refused Bequest.

NO, I did not find Refused Bequest."
FieldAttributes.java,"1. Inheritance Pattern:
- The file defines ""public final class FieldAttributes"". It does not declare an extends clause; it only implicitly extends java.lang.Object.

2. Use of Inherited Functionality:
- There are no method overrides, no calls to super., and no interaction with inherited/protected state from a custom parent class. All methods operate on the contained java.lang.reflect.Field.

3. New/Independent Functionality:
- The class introduces its own field (private final Field field) and a number of accessor methods (getDeclaringClass, getName, getDeclaredType, getDeclaredClass, getAnnotation, getAnnotations, hasModifier, get, isSynthetic). These represent the class’s primary responsibility: wrapping and exposing metadata about a reflective Field.

4. Breadth of Subclass:
- The class is non-trivial (multiple methods) but all methods are cohesive and focused on the Field wrapper role.

5. Local Symptom Summary:
- This file does not show Refused Bequest symptoms: there is no meaningful parent class being extended or ignored. The class does not override or avoid using any inherited contract from a superclass other than Object.

NO, I did not find Refused Bequest. Main evidence: the class does not extend any custom parent (only Object), has no overrides or super usage, and its methods cohesively wrap a java.lang.reflect.Field."
ExcelWriteFillExecutor.java,"1. Inheritance Pattern:
- Yes. The class is declared as ""public class ExcelWriteFillExecutor extends AbstractExcelWriteExecutor"". The parent class is AbstractExcelWriteExecutor.

2. Use of Inherited Functionality:
- Minimal. The subclass calls the parent constructor via super(writeContext) in its constructor and uses inherited helper methods such as converterAndSet(...) and convert(...). It also uses the inherited writeContext field extensively (writeContext.writeSheetHolder(), etc.). However there are no method overrides of parent behavior and no calls to super.method(...) beyond the constructor; no apparent overriding of core behaviors — most logic is implemented locally.

3. New/Independent Functionality:
- Yes. The class defines many of its own fields (templateAnalysisCache, templateCollectionAnalysisCache, collectionFieldStyleCache, collectionRowHeightCache, collectionLastIndexCache, relativeRowIndexMap, currentDataPrefix, currentUniqueDataFlag) and many methods implementing template parsing, row/column management, cell creation, shifting rows, and filling data (fill, shiftRows, doFill, readTemplateData, prepareData, etc.). These represent substantial, specialized responsibilities for filling Excel templates.

4. Breadth of Subclass:
- Non-trivial. The class is large with many fields and methods, handling parsing, caching, row/column manipulation, style propagation, and filling logic — far more than a light extension.

5. Local Symptom Summary:
- The subclass shows symptoms of Refused Bequest: it extends AbstractExcelWriteExecutor but implements most behavior itself, only using a few inherited helpers (conversion methods and writeContext) and not overriding parent methods. The clearest sign is ""many new fields/methods; few meaningful overrides; unrelated/template-filling logic dominates.""

YES, I found Refused Bequest — evidence: many new fields and methods implementing template-fill behavior while only minimally using inherited helpers (constructor + conversion helpers), with no substantive overrides of parent behavior."
Throwables.java,"1. Inheritance Pattern:  
   - The file defines `public final class Throwables`. It does not declare an `extends` clause; it only implicitly extends `java.lang.Object`.

2. Use of Inherited Functionality:  
   - There are no overrides of parent methods (no `toString`, `equals`, `hashCode`, etc.), no `super.` calls, and no direct interaction with inherited state beyond the implicit Object behavior.

3. New/Independent Functionality:  
   - The class is a utility holder of many static methods (rethrowing, getting stack traces, trimming traces, reflection-based suppressed detection, helper methods) and private static fields (e.g., `getSuppressed`, arrays of method-name prefixes). This is substantial functionality unrelated to any parent behavior.

4. Breadth of Subclass:  
   - The class is non-trivial: many methods, a private enum `State`, an anonymous `AbstractList` implementation, and several private helpers — clearly more than a light extension.

5. Local Symptom Summary:  
   - Since the class does not extend another explicit parent (only `Object`) and therefore inherits nothing meaningful to refuse, there is no evidence of Refused Bequest in this file.

NO, I did not find Refused Bequest."
BeanCopier.java,"1. Inheritance Pattern:
- This file defines public class BeanCopier<T> implements Copier<T>, Serializable. It does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:
- Not applicable: since BeanCopier does not extend a superclass, there are no inherited methods/fields from a parent class to override, call via super., or interact with. It only implements interfaces (Copier, Serializable).

3. New/Independent Functionality:
- The class introduces its own fields (source, dest, destType, copyOptions) and many methods implementing copy logic (copy, beanToBean, mapToBean, mapToMap, beanToMap, valueProviderToBean, plus factory/create methods and constructor). These represent substantial, self-contained functionality for bean/map copying.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields and many helper methods implement complex behavior (iteration over properties, value providers, mapping/filters, etc.).

5. Local Symptom Summary:
- Because the class does not extend a parent, it cannot exhibit Refused Bequest in the usual sense here. The class contains significant independent functionality but no superclass relationship to refuse.

NO, I did not find Refused Bequest."
AndroidGraphics.java,"1. Inheritance Pattern:
- Yes. The class is declared as ""public class AndroidGraphics extends AbstractGraphics implements Renderer"".  
- Parent class: AbstractGraphics.

2. Use of Inherited Functionality:
- The subclass provides many overrides of Graphics/AbstractGraphics methods: getGL20, setGL20, isGL30Available, getHeight, getWidth, getBackBufferWidth/Height, getFrameId, getDeltaTime, getType, getGLVersion, getFramesPerSecond, getPpiX/Y, getPpcX/Y, getDensity, display/monitor/displayMode related methods, buffer format, continuous rendering controls, cursor methods, etc.
- Many of these overrides are substantive (implementing core behavior for Android GL rendering and platform integration — e.g., setGL20/setGL30 update global Gdx.gl references, onSurfaceCreated/onSurfaceChanged/onDrawFrame implement the renderer lifecycle and frame loop, updatePpi(), setupGL(), buffer format logging and management).
- A few overrides are trivial/no-op (examples: setTitle(String) empty, setResizable(boolean) empty, newCursor returns null, setCursor/setSystemCursor empty, setVSync and setForegroundFPS empty, supportsDisplayModeChange returns false). But these are a small subset and typical for a platform implementation that doesn't support certain features.

3. New/Independent Functionality:
- Yes. The class introduces many Android-specific fields and behavior: GLSurfaceView20 view, AndroidApplicationBase app, GL20/GL30/eglContext/glVersion/extensions, window safe insets, ppi/ppc/density fields, bufferFormat, flags (created, running, pause, resume, destroy), synchronization object and threading/lifecycle logic (resume/pause/destroy, onDrawFrame handling), cache invalidation/managed resources logging, methods to interact with EGL and Android Display/Cutout APIs, etc. This is substantial platform-specific functionality.

4. Breadth of Subclass:
- The subclass is non-trivial: many fields, numerous methods implementing rendering lifecycle, EGL/GL setup, device metrics, resource management, synchronization for pause/resume/destroy, and display/safe-area handling. This is a large, concrete implementation class, not a thin wrapper.

5. Local Symptom Summary:
- The class implements many core and platform-specific behaviors and also overrides a wide set of abstract/interface methods to fulfill the Graphics contract. While a few overrides are trivial or no-op (because the platform doesn't support those features), the majority are meaningful and central to the parent's responsibilities (rendering, frame timing, GL setup, resource management).
- Therefore there is no clear symptom of Refused Bequest (the subclass appears to be a legitimate platform-specific implementation of the parent contract rather than refusing inherited responsibility).

Final verdict (per instructions):
NO, I did not find Refused Bequest. Evidence: extends AbstractGraphics but provides many substantial overrides and implements core rendering/lifecycle behavior; trivial/no-op overrides are limited and expected for unsupported platform features."
ExecutorRouteBusyover.java,"1. Inheritance Pattern:
- Yes. The file defines class ExecutorRouteBusyover which extends ExecutorRouter.

2. Use of Inherited Functionality:
- The subclass overrides the route(TriggerParam, List<String>) method (annotated @Override) and implements its own routing logic. It does not call super.route(...). It does use an inherited logger (logger.error(...)) for error reporting, but otherwise does not appear to directly manipulate parent state. The override is substantial (full implementation), not a trivial one-liner call to super.

3. New/Independent Functionality:
- The class adds routing logic specific to a ""busy-over"" strategy (iterating addresses, performing idleBeat calls, assembling messages). It does not declare new fields in this file; it introduces a non-trivial method that encapsulates its own behavior.

4. Breadth of Subclass:
- The subclass is modest in size: a single non-trivial method, no new fields. It is not a broad class with many new fields/methods.

5. Local Symptom Summary:
- Based on this file, I do not see symptoms of Refused Bequest. The subclass provides a meaningful override of a routing method (likely the intended extension point of ExecutorRouter), uses an inherited logger, and does not introduce a disparate set of unrelated responsibilities.

NO, I did not find Refused Bequest. Evidence: substantial override of the expected route behavior (specialization), no many new unrelated fields/methods, and only minor use of inherited logger."
IncompleteElementException.java,"1. Inheritance Pattern:  
Yes — the file defines class IncompleteElementException that extends BuilderException.

2. Use of Inherited Functionality:  
The subclass does not override any parent methods; it only defines constructors that delegate to the parent via super(...). There are no calls to super beyond constructor delegation and no direct interaction with inherited state or behavior.

3. New/Independent Functionality:  
No — the subclass introduces no new fields or methods beyond the constructors. It does not add independent responsibilities or logic.

4. Breadth of Subclass:  
The subclass is trivial (only four constructors and a serialVersionUID). It is not a large class with many new features.

5. Local Symptom Summary:  
The class does not show symptoms of Refused Bequest: it’s a simple exception specialization that only delegates to the parent and adds no unrelated functionality.

Final verdict: NO, I did not find Refused Bequest. Evidence: only constructor delegations to super and no new fields/methods or meaningful overrides."
NioClientTest.java,"1. Inheritance Pattern:  
- This file defines class NioClientTest which does not declare ""extends"" — it only implicitly extends java.lang.Object. No parent class other than Object is present.

2. Use of Inherited Functionality:  
- Not applicable: there is no explicit superclass to inherit from here, so there are no overrides, no use of super., and no inherited protected members being referenced.

3. New/Independent Functionality:  
- The class provides a single main method that constructs and uses a NioClient instance, sets a channel handler (lambda), and interacts with the console and a Scanner. This is composition/usage of NioClient, not subclass-provided behavior.

4. Breadth of Subclass:  
- The class is trivial (only main), no additional fields or instance methods. It is not a non-trivial subclass.

5. Local Symptom Summary:  
- There are no symptoms of Refused Bequest because no inheritance relationship is defined/used in this file; the code uses composition rather than extending a parent.

Final conclusion:
NO, I did not find Refused Bequest. Evidence: class does not extend any superclass (no overrides or use of inherited members), so the refused-bequest pattern cannot appear here."
ClientHandler.java,"1. Inheritance Pattern:  
- This file defines class ClientHandler which does not extend any explicit parent class (it implicitly extends java.lang.Object). It implements the Runnable interface.

2. Use of Inherited Functionality:  
- There is no superclass whose protected/inherited members could be used or overridden. The class implements Runnable and provides run(), but that is an interface method implementation rather than a superclass override. There are no calls to super. and no interaction with inherited state beyond Object.

3. New/Independent Functionality:  
- ClientHandler introduces its own fields (httpd, inputStream, acceptSocket) and methods (constructor, close(), run()) that handle socket I/O, session creation and loop, and cleanup. This is self-contained connection-handling logic unrelated to any inherited parent behavior.

4. Breadth of Subclass:  
- The class is non-trivial: it has multiple fields and a substantial run() method with error handling and cleanup. However, this complexity is standalone and not the result of specializing an inherited API.

5. Local Symptom Summary:  
- There are no symptoms of Refused Bequest here because the class does not extend a concrete parent with inherited behavior to refuse. The clearest sign: ClientHandler implements Runnable and defines its own complete connection-handling responsibilities rather than overriding or ignoring a superclass.

Final conclusion: NO, I did not find Refused Bequest."
DefaultJedisSocketFactory.java,"1. Inheritance Pattern:
- This file defines class DefaultJedisSocketFactory which implements the interface JedisSocketFactory. It does NOT extend any parent class.

2. Use of Inherited Functionality:
- It implements/overrides the interface methods (createSocket, updateHostAndPort, getDescription, getHost, setHost, getPort, setPort, getConnectionTimeout, setConnectionTimeout, getSoTimeout, setSoTimeout, etc.).
- There are no super. calls (because there is no superclass). The implementations are not mere trivial passthroughs — createSocket() is substantial and many getters/setters access and use internal state.

3. New/Independent Functionality:
- The class introduces many fields: hostAndPort, connectionTimeout, socketTimeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier, hostAndPortMapper.
- It provides logic for socket creation (including TCP options and SSL wrapping/hostname verification), host mapping, and configuration — responsibilities consistent with a socket factory.

4. Breadth of Subclass:
- The class is non-trivial: multiple constructors, many fields, numerous methods, and a complex createSocket implementation.

5. Local Symptom Summary:
- This class does not show symptoms of Refused Bequest. It does not extend a superclass (so classic refused bequest doesn't apply), and it meaningfully implements the interface methods and uses its own configuration/state. The clearest sign against the smell: a substantial createSocket implementation plus many related fields and accessors.

NO, I did not find Refused Bequest. Evidence: does not extend a parent class and provides substantial, cohesive socket/SSL-related behavior rather than ignoring inherited functionality."
CronExpression.java,"1. Inheritance Pattern:  
- This file does not define a class that extends another concrete class. CronExpression is declared as ""public final class CronExpression implements Serializable, Cloneable"" and therefore implicitly extends java.lang.Object only. (There is also a package-private ValueSet class that likewise does not extend any class.)

2. Use of Inherited Functionality:  
- Since CronExpression does not extend a domain parent class, there is no subclass/parent relationship to inspect for use/misuse of inherited members. CronExpression does override Object.toString() and provides a clone() method (deprecated) and implements Serializable — these are normal uses of Object/interface contracts, not evidence of refusing a parent's responsibilities.

3. New/Independent Functionality:  
- The class defines many fields (cron parsing state, sets for seconds/minutes/hours/days/months/years, flags like lastdayOfWeek, etc.) and a large number of parsing and scheduling methods (buildExpression, storeExpressionVals, getTimeAfter, etc.). This is substantial domain functionality, but it is all self-contained in a class that is not a subclass of a richer parent.

4. Breadth of Subclass:  
- Not applicable: CronExpression is not a subclass. It is a non-trivial, standalone final class with many fields and methods.

5. Local Symptom Summary:  
- There is no subclassing relationship in this file to exhibit Refused Bequest. All functionality is implemented directly in the class; there is no evidence of a subclass inheriting a parent API and refusing to use/override it.

Conclusion:
NO, I did not find Refused Bequest. The file contains no subclass extending a parent class (only implicit extension of Object), so the Refused Bequest smell cannot apply here."
PooledDataSource.java,"1. Inheritance Pattern:
- This file declares ""public class PooledDataSource implements DataSource"". It does not extend any other class (no ""extends"" clause). The only overridden method from a superclass is finalize() from java.lang.Object.

2. Use of Inherited Functionality:
- It implements the DataSource interface methods (getConnection, getConnection(String,String), getLogWriter, getLoginTimeout, unwrap/isWrapperFor, getParentLogger, etc.), providing full implementations rather than trivial passthroughs.
- It overrides finalize() and calls super.finalize() (a trivial, appropriate cleanup call).
- There are virtually no uses of super.<method>() other than super.finalize(). The class primarily delegates to its contained UnpooledDataSource instance and manages its own PoolState rather than relying on inherited state or behavior.

3. New/Independent Functionality:
- The class defines many fields specific to pooling (poolMaximumActiveConnections, poolMaximumIdleConnections, poolMaximumCheckoutTime, poolTimeToWait, poolPingQuery, poolPingEnabled, poolPingConnectionsNotUsedFor, expectedConnectionTypeCode, state, dataSource).
- It implements substantial pooling logic: pushConnection, popConnection, pingConnection, forceCloseAll, assembleConnectionTypeCode, unwrapConnection, and many getters/setters for pool configuration.
- This is significant, domain-specific functionality (connection pooling) implemented locally.

4. Breadth of Subclass:
- The class is non-trivial: many fields, constructors, and complex methods managing pool state, connection creation, validation, rollback, and logging.

5. Local Symptom Summary:
- The code does not show the Refused Bequest pattern because it is not a subclass of another concrete class; it implements an interface and composes an UnpooledDataSource. The only superclass method overridden is finalize(), which is a small, appropriate cleanup override.

Conclusion:
NO, I did not find Refused Bequest. Main evidence: the class does not extend another class (implements DataSource), contains extensive, cohesive pooling functionality and composes an UnpooledDataSource rather than ignoring or failing to use inherited behavior."
EmbedServer.java,"1. Inheritance Pattern:
- Yes. The file defines an inner class EmbedHttpServerHandler that extends SimpleChannelInboundHandler<FullHttpRequest>.

2. Use of Inherited Functionality:
- The subclass overrides several lifecycle/handler methods: channelRead0 (required), channelReadComplete, exceptionCaught, and userEventTriggered. These overrides are substantive (implement full HTTP request parsing, dispatch, response writing, error handling). It calls super.userEventTriggered(...) only in the non-idle-event branch; other overrides implement behavior rather than delegating trivially to super.

3. New/Independent Functionality:
- The handler introduces its own fields (executorBiz, accessToken, bizThreadPool) and methods (process, writeResponse) and creates/runs tasks on a thread pool. It contains logic for HTTP parsing, URI routing to ExecutorBiz, JSON (de)serialization, and response construction — responsibilities beyond what the generic parent provides.

4. Breadth of Subclass:
- The subclass is non-trivial: multiple fields, utility methods, and substantial request-processing logic.

5. Local Symptom Summary:
- This subclass does not show Refused Bequest symptoms. Although it adds significant new functionality, that functionality is a meaningful specialization of the parent’s contract (a channel/request handler) — there are several meaningful overrides implementing the expected behavior rather than ignoring or lightly delegating inherited responsibilities.

Final verdict:
NO, I did not find Refused Bequest. Evidence: meaningful, non-trivial overrides (channelRead0, etc.) that implement the handler contract; added functionality is appropriate specialization (HTTP parsing, routing, response), not unrelated refusal of the parent’s behavior."
SentinelDubboConsumerFilter.java,"1. Inheritance Pattern:
- Yes. The class is SentinelDubboConsumerFilter which extends BaseSentinelDubboFilter.

2. Use of Inherited Functionality:
- The subclass overrides multiple methods from the parent: getMethodName, getInterfaceName, and invoke.
- These overrides are substantial (not trivial one-liners). invoke dispatches between sync and async flows; getMethodName/getInterfaceName return concrete resource names via DubboUtils. There is no simple pass-through to super, but the overrides implement the expected filtering/invocation responsibilities rather than ignoring the parent contract.

3. New/Independent Functionality:
- The class introduces several methods (syncInvoke, asyncInvoke, exitEntry), a constructor, and a small inner EntryHolder class. However, this functionality is directly related to implementing the consumer-side Sentinel/Dubbo filter behavior (resource entry/exit, block handling, tracing), i.e., specialization of the parent role rather than an unrelated domain.

4. Breadth of Subclass:
- The subclass is non-trivial: multiple methods and an inner class, with asynchronous handling and exception tracing logic.

5. Local Symptom Summary:
- The subclass does not show the usual symptoms of Refused Bequest. It provides meaningful overrides and implements behavior aligned with a Dubbo consumer filter (resource naming, entry/exit handling, sync/async invocation). The clearest sign is: many non-trivial overrides and domain-aligned logic rather than ignoring inherited responsibilities.

NO, I did not find Refused Bequest."
QueryParser.java,"1. Inheritance Pattern:  
- This file defines class QueryParser which does not extend any other class (no ""extends"" clause). It only overrides toString() from java.lang.Object.

2. Use of Inherited Functionality:  
- Not applicable in the subclass sense because QueryParser has no superclass other than Object. The only inherited method overridden is toString(), and that override is trivial (returns the local query field).

3. New/Independent Functionality:  
- The class defines many fields (tq, query, evals, static patterns/arrays) and many parsing methods (parse, combinator, findElements, byId, byClass, byTag, byAttribute, cssNthChild, has, contains, matches, not, etc.) implementing a full CSS-query parser — clearly its own responsibilities.

4. Breadth of Subclass:  
- The class is non-trivial: many private methods, constants, and substantial logic. But again, it is a standalone class rather than a subclass of a meaningful parent.

5. Local Symptom Summary:  
- There are no symptoms of Refused Bequest because the class does not inherit from a domain superclass; it only overrides toString() from Object (a trivial override). No evidence of inheriting and then ignoring parent responsibilities.

Final verdict per instructions:  
NO, I did not find Refused Bequest. Main evidence: QueryParser does not extend any domain superclass (only Object), so there is no subclass refusing a parent's bequest."
HikariDataSource.java,"1. Inheritance Pattern:
- Yes. The class HikariDataSource extends HikariConfig.

2. Use of Inherited Functionality:
- The subclass does call and use several inherited methods from HikariConfig: validate(), seal(), getPoolName(), getMetricRegistry()/getMetricsTrackerFactory()/getHealthCheckRegistry(), and copyStateTo(...) in the constructor.
- It overrides a few configuration-related setters (setMetricRegistry, setMetricsTrackerFactory, setHealthCheckRegistry). Those overrides largely call super.<method>() and then propagate the setting to the pool (or enforce single-set semantics). The overrides are not large behavioral reimplementations — they mainly add small, extra propagation/validation around the superclass behavior.

3. New/Independent Functionality:
- The class introduces its own fields: isShutdown (AtomicBoolean), fastPathPool, and pool (HikariPool).
- It implements substantial, independent responsibilities unrelated to plain configuration: DataSource and pool lifecycle and access (getConnection(), getConnection(username,password) throwing unsupported, getLogWriter/setLogWriter, login timeout methods, unwrap/isWrapperFor), pool management and state (isRunning, getHikariPoolMXBean, evictConnection), shutdown/close and isClosed, plus toString().
- Those methods implement pool behavior and DataSource API rather than configuring properties.

4. Breadth of Subclass:
- The subclass is non-trivial: multiple fields and many methods spanning pooling lifecycle, DataSource API, unwrapping, and shutdown. It is far more than a light extension or marker.

5. Local Symptom Summary:
- The class heavily focuses on pool/DataSource responsibilities (many new methods/fields) while using the parent largely as a configuration holder with relatively few and small overrides. The clearest sign is: many new fields/methods implementing an independent domain (connection pooling/DataSource) and only a few minor overrides of configuration methods that mostly delegate to super.

Conclusion per instructions:
YES, I found Refused Bequest — many new pool/DataSource responsibilities and fields dominate the subclass while only a few trivial/propagating overrides of the parent config behavior are present (subclass uses the parent mostly as a configuration holder)."
Excluder.java,"1. Inheritance Pattern:
- The file defines ""public final class Excluder implements TypeAdapterFactory, Cloneable"". It does not extend a non-Object class; its implicit parent is java.lang.Object. It implements the TypeAdapterFactory interface (and Cloneable marker).

2. Use of Inherited Functionality:
- The class overrides clone() and calls super.clone(), returning a casted Excluder. Aside from that, there are no calls to super.<method>() or interaction with inherited state from a concrete parent class. It implements the interface method create(...) (not an inherited concrete implementation to specialize). The clone override is small and mostly delegates to Object.clone().

3. New/Independent Functionality:
- Yes. Excluder introduces many fields (version, modifiers, serializeInnerClasses, requireExpose, serializationStrategies, deserializationStrategies) and many methods implementing exclusion logic (withVersion, withModifiers, disableInnerClassSerialization, excludeFieldsWithoutExposeAnnotation, withExclusionStrategy, create, excludeField, excludeClass, isAnonymousOrLocal, isInnerClass, isValidVersion, etc.). These represent substantial, self-contained responsibilities for field/type exclusion.

4. Breadth of Subclass:
- The class is non-trivial: multiple configuration methods, multiple boolean checks, and an inner TypeAdapter implementation. It is a full-featured utility/strategy class rather than a light extension.

5. Local Symptom Summary:
- This file does not show Refused Bequest symptoms because Excluder does not extend a meaningful parent class (only Object) whose protected members it ignores. It defines and uses its own fields and logic and only minimally overrides clone() to support cloning.

NO, I did not find Refused Bequest."
JedisClusterCommand.java,"1. Inheritance Pattern:
- The file defines an abstract class JedisClusterCommand<T>, but it does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:
- Not applicable: there is no superclass, so there are no inherited methods/fields to override, call via super., or interact with.

3. New/Independent Functionality:
- The class itself declares multiple fields (connectionHandler, maxAttempts, maxTotalRetriesDuration) and many methods that implement cluster retry, redirection handling, backoff, etc. Those are internal responsibilities of this class, not additions to a parent.

4. Breadth of Subclass:
- The class is non-trivial: several fields and many methods (run variants, runWithRetries, handleConnectionProblem, getBackoffSleepMillis, sleep, releaseConnection, etc.), but again this is the class’s own implementation rather than a subclass adding unrelated behavior.

5. Local Symptom Summary:
- There is no subclassing here, so the Refused Bequest smell cannot occur in this file: no inheritance, no weak/unused inherited members.

NO, I did not find Refused Bequest. (Main evidence: the class does not extend any other class — no inherited members are present to be refused.)"
TestConnections.java,"1. Inheritance Pattern:
- The top-level class in this file, TestConnections, does not extend any other class.
- There are a few local/inner subclasses defined in this file:
  - StubDataSourceWithErrorSwitch extends StubDataSource.
  - A local class BadConnection (inside testInvalidConnectionTestQuery) extends StubConnection.
  - An anonymous subclass of StubDataSource is also used in testInvalidConnectionTestQuery (overrides getConnection()).
  - OverrideHandler implements the SQLExceptionOverride interface (not a subclass).

2. Use of Inherited Functionality:
- StubDataSourceWithErrorSwitch: overrides getConnection() to either return a new StubConnection or throw a RuntimeException based on an internal flag. It does not call super.getConnection() or otherwise interact with inherited state; it replaces behavior for testing.
- BadConnection: overrides createStatement() to throw an SQLException. This is a small, focused override that intentionally changes one inherited method for test simulation.
- The anonymous StubDataSource subclass returns an instance of BadConnection in getConnection(); it overrides one method to inject the test double.
- None of these subclasses use super.method(...) calls or manipulate many inherited/protected fields — the overrides are targeted and minimal.

3. New/Independent Functionality:
- StubDataSourceWithErrorSwitch introduces a private boolean field errorOnConnection and a setter setErrorOnConnection(boolean) to control behavior; its responsibility is to simulate a data source that can be toggled to throw errors.
- BadConnection changes a single inherited method to simulate a failure.
- OverrideHandler provides a small implementation of the adjudicate method to decide eviction behavior from an SQLExceptionOverride interface.
- These additions are small, test-oriented behaviors rather than broad, unrelated responsibilities.

4. Breadth of Subclass:
- The subclasses are small and focused: one field + setter + one overridden method (StubDataSourceWithErrorSwitch), one one-line overridden method (BadConnection), and a small interface implementation (OverrideHandler). They are not broad, multi-field, multi-responsibility classes.

5. Local Symptom Summary:
- The local subclasses do replace or override inherited behavior, but only in narrowly scoped ways for test simulation. They do not introduce large, unrelated responsibilities, nor do they ignore a parent’s contract in a way that suggests a design smell in this context.

Final judgment:
NO, I did not find Refused Bequest. The few subclasses present are small test doubles that intentionally override specific behaviors for testing; they do not exhibit the pattern of inheriting a large parent API while mostly ignoring it and taking on unrelated responsibilities."
OmsReceiverInfoParam.java,"1. Inheritance Pattern:
- The file defines ""public class OmsReceiverInfoParam"" and does not declare an extends clause. It therefore only inherits implicitly from java.lang.Object.

2. Use of Inherited Functionality:
- There are no overrides of parent methods (no @Override, no methods that call super.*, and no interaction with inherited state beyond Object). The class uses Lombok @Getter/@Setter but also declares a number of manual getter methods that currently return null — these are not overrides of any superclass behaviour.

3. New/Independent Functionality:
- The class declares many fields specific to an order/receiver DTO (orderId, receiverName, receiverPhone, receiverPostCode, receiverDetailAddress, receiverProvince, receiverCity, receiverRegion, status). Those are domain-specific and represent its own responsibilities unrelated to any parent class (other than Object).

4. Breadth of Subclass:
- The class is non-trivial for a DTO: multiple fields and many getter methods (even though the manual getters are currently stubbed). It is not a simple marker or tiny extension.

5. Local Symptom Summary:
- This file does not show Refused Bequest symptoms because it does not extend a meaningful parent class nor use/inherit parent functionality. The clearest signs are: no explicit parent (only Object), no meaningful overrides or super calls, and the class defines domain-specific fields and methods.

Final verdict:
NO, I did not find Refused Bequest."
ResizeController.java,"NO, I did not find Refused Bequest

1. Inheritance Pattern:
- This file defines ""public class ResizeController implements FxController"". It implements the FxController interface; it does not extend any class (no ""extends"" clause).

2. Use of Inherited Functionality:
- There is no superclass, so there is no use of inherited fields or calls to super.*. The class does declare an initialize() method (common for controllers), but it is not shown calling any parent implementation. No super.method() calls or access to inherited state are present in this file.

3. New/Independent Functionality:
- The class introduces many of its own fields (Stage window, many Region fields, Settings settings, BooleanBinding showResizingArrows, origin coordinates) and many methods implementing window-resize behavior (resizeTop/Left/Right/Bottom, startResize, savePositionalSettings, getMonitorSizes, didDisplayConfigurationChange, etc.). This is substantial, self-contained UI/resizing logic tied to Settings and Stage.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields and numerous methods implementing complex behavior (bindings, screen enumeration, bounds checks, updating settings). It is more than a light extension or marker.

5. Local Symptom Summary:
- Refused Bequest is not applicable here because the class does not extend another class. Although the class has many new, independent responsibilities and does not use any inherited class members, that is expected for a concrete class implementing an interface. The clearest points: no superclass to refuse, no super.* usage, and many own fields/methods implementing window resizing.

Main evidence for conclusion: the class implements an interface (FxController) rather than extending a parent class, and there are no superclass overrides or super calls."
Lifecycle.java,"1. Inheritance Pattern:  
- This file defines an abstract class named Lifecycle. It does not explicitly extend another class (implicitly extends java.lang.Object). It implements ExtensionPoint.  
- The file also creates anonymous subclasses of Lifecycle inside the get() method (and references SolarisSMFLifecycle and UnixLifecycle, which appear to be external subclasses but are not defined in this file).

2. Use of Inherited Functionality:  
- The anonymous subclasses in this file override a single method, verifyRestartable(), and their overrides are trivial: they simply throw RestartNotSupportedException with a message. They do not call super.verifyRestartable() or otherwise interact with inherited state or call other inherited methods/fields.  
- There are no other uses of super.* or substantial overrides in this file.

3. New/Independent Functionality:  
- The anonymous subclasses introduce no new fields and only a single one-line override each; they do not add significant, unrelated responsibilities.  
- The main class Lifecycle itself declares multiple methods and fields (INSTANCE, get(), getHudsonWar(), rewriteHudsonWar(), canRewriteHudsonWar(), restart(), verifyRestartable(), canRestart()), but that is the parent class, not a subclass.

4. Breadth of Subclass:  
- The subclasses shown here are trivial (anonymous, single-method override). There is no non-trivial subclass with several fields or methods in this file.

5. Local Symptom Summary:  
- Based on this file alone, the only subclasses present are tiny anonymous implementations that provide a trivial override to signal lack of restart support. There is no evidence here of a subclass that inherits but largely ignores or replaces the parent with unrelated functionality.

NO, I did not find Refused Bequest. (Evidence: only trivial anonymous overrides of verifyRestartable; no large subclasses in this file that add many unrelated fields/methods or ignore inherited behavior.)"
MarkdownWebServerPlugin.java,"1. Inheritance Pattern:  
- This file defines class MarkdownWebServerPlugin which implements the interface WebServerPlugin.  
- It does NOT extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:  
- Because it implements an interface rather than extending a concrete superclass, there is no inherited implementation to override.  
- The class provides implementations for the interface methods canServeUri, initialize, and serveFile. There are no calls to super., no use of inherited fields, and no overridden parent behavior to inspect.

3. New/Independent Functionality:  
- The class introduces its own field: private final PegDownProcessor processor.  
- It defines a private utility method readSource(File) and logic in serveFile to convert markdown to HTML and produce a response. These are substantial, self-contained responsibilities (file reading, markdown processing, response creation).

4. Breadth of Subclass:  
- The class is non-trivial: several methods (constructor, canServeUri, initialize, readSource, serveFile) and one significant field. It implements real functionality rather than being a trivial adapter.

5. Local Symptom Summary:  
- There is no subclassing of a concrete parent class here, so the Refused Bequest smell (a subclass inheriting but not using parent features) cannot occur in the usual form. The class implements an interface and supplies its own behavior and state, with no super calls or unused inherited members.

Final verdict per instructions:
NO, I did not find Refused Bequest."
EsProductServiceImpl.java,"1. Inheritance Pattern:
- This file defines public class EsProductServiceImpl which implements the EsProductService interface. It does not extend any superclass (no ""extends"" clause).

2. Use of Inherited Functionality:
- There are @Override methods, but those are implementations of interface methods, not overrides of a concrete parent class. There are no calls to super., no references to inherited protected state, and no attempts to change core behavior of a superclass.

3. New/Independent Functionality:
- The class declares its own fields (productDao, productRepository, elasticsearchRestTemplate, LOGGER) and provides many methods (importAll, delete, create, multiple search methods, recommend, searchRelatedInfo, convertProductRelatedInfo) implementing complex Elasticsearch query/aggregation logic. These represent substantial, specific responsibilities (search, aggregation, recommend) unrelated to any inherited superclass behavior.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields and many complex methods. It is more than a light extension or marker.

5. Local Symptom Summary:
- Since the class does not extend a concrete parent class, there is no inherited implementation to refuse. The class implements an interface and fully supplies its own substantial functionality. Therefore there is no evidence of a subclass inheriting but refusing a parent's behavior.

NO, I did not find Refused Bequest."
ProjectExportWizard.java,"1. Inheritance Pattern:
- Yes. The file defines class ProjectExportWizard which extends Wizard (and implements IExportWizard).

2. Use of Inherited Functionality:
- The subclass overrides Wizard lifecycle methods: init(IWorkbench, IStructuredSelection), addPages(), and performFinish().
- It calls inherited methods such as setWindowTitle(...) and setNeedsProgressMonitor(...) in init, calls super.addPages() in addPages(), and uses getContainer() in performFinish() to run a long-running UI operation.
- The overrides are not purely trivial: performFinish contains substantial finish logic (running export work), init configures the wizard, addPages is a small override but is a normal extension point rather than a meaningless passthrough.

3. New/Independent Functionality:
- The class introduces many constants and fields (COPY_BUFFER_SIZE, PROJECT_DESC_FILE, IGNORED_RESOURCES, mainPage) and a large set of methods for export behavior: exportProjects(...), exportProject(...), exportResourceTree(...), getChildCount(...), plus ZIP and XML handling and I/O logic.
- This is substantial domain logic (project/resource traversal, zipping, meta XML) that is new to the subclass.

4. Breadth of Subclass:
- The subclass is non-trivial: multiple helpers, I/O and archive handling, meta building, driver/library export, and recursion over resources. It is far more than a marker or light extension.

5. Local Symptom Summary:
- Although the class adds a lot of independent export logic, it does meaningfully use the Wizard parent API: it overrides the standard lifecycle hooks and uses parent methods (setWindowTitle, setNeedsProgressMonitor, addPage/getContainer). The heavy new functionality is appropriate for implementing a concrete wizard.

NO, I did not find Refused Bequest. The subclass overrides and uses Wizard lifecycle methods (init/addPages/performFinish and getContainer), so it is extending the parent to implement the expected wizard behavior even though it contains substantial export-specific code."
SentinelApacheHttpClientConfig.java,"1. Inheritance Pattern:  
   - The file defines class SentinelApacheHttpClientConfig. It does not explicitly extend any other class; it implicitly extends java.lang.Object.

2. Use of Inherited Functionality:  
   - There are no method overrides, no calls to super., and no direct interaction with inherited state beyond default Object behavior. No inherited methods are specialized.

3. New/Independent Functionality:  
   - The class introduces its own fields (prefix, extractor, fallback) and corresponding getters/setters, plus null checks via AssertUtil. These are configuration responsibilities specific to this class, not use of a parent's contract.

4. Breadth of Subclass:  
   - The class is small: three fields and simple accessor/mutator methods. It is not a broad or complex subclass — it’s a plain configuration holder.

5. Local Symptom Summary:  
   - There is no evidence of Refused Bequest here: the class doesn’t extend a meaningful parent (only Object), provides its own small configuration responsibilities, and does not override or ignore inherited behavior.

NO, I did not find Refused Bequest."
CachingExecutor.java,"1. Inheritance Pattern:  
   - This class does not extend another class. It implements the Executor interface (public class CachingExecutor implements Executor). There is no parent class name to report.

2. Use of Inherited Functionality:  
   - Because it implements an interface rather than extending a concrete class, there is no use of superclass methods/fields or calls to super.*. The class implements the Executor methods and, in most implementations, delegates work to an internal Executor instance named delegate. Some methods are simple pass-throughs to delegate (e.g., getTransaction(), isClosed(), flushStatements(), deferLoad(), clearLocalCache()), while others add behavior (e.g., update() calls flushCacheIfRequired before delegating; query(...) implements cache lookup/put logic using tcm).

3. New/Independent Functionality:  
   - Yes. The class introduces its own state and behavior: a TransactionalCacheManager tcm and helper methods ensureNoOutParams(...) and flushCacheIfRequired(...). It contains caching logic around queries (create/lookup CacheKey, get/put via tcm, commit/rollback of tcm), which is a distinct responsibility (caching/decorating) beyond merely forwarding Executor calls.

4. Breadth of Subclass:  
   - The class is non-trivial: it has two fields (delegate and tcm), many method implementations, and several helper methods implementing caching semantics. It is more than a light wrapper or marker.

5. Local Symptom Summary:  
   - This class does not show the Refused Bequest smell. It implements an interface and intentionally decorates/delegates to another Executor while adding caching behavior. The overrides are meaningful (not just trivial calls to super) and the class’s own functionality (tcm and caching logic) is the declared purpose (a decorator), not evidence of refusing a parent’s contract.

NO, I did not find Refused Bequest. Evidence: the class implements Executor and intentionally decorates a delegate with caching logic (many new methods/fields and meaningful additional behavior rather than unused inherited members)."
RedisPriorityScheduler.java,"1. Inheritance Pattern:  
Yes. The file defines class RedisPriorityScheduler which extends RedisScheduler.

2. Use of Inherited Functionality:  
The subclass uses inherited state/members: it accesses pool (pool.getResource()) and calls inherited helper methods getItemKey(task) and getSetKey(task). It overrides three parents methods: pushWhenNoDuplicate, poll, and resetDuplicateCheck. Those overrides are not trivial one-liners or mere super calls — they provide substantial, replacement logic (priority zset/queue handling, Redis interactions). There are no calls to super.method() in the overrides.

3. New/Independent Functionality:  
Yes. The subclass introduces many new responsibilities for priority scheduling: several private helper methods (getRequest, getZsetPlusPriorityKey, getZsetMinusPriorityKey, getQueueNoPriorityKey, setExtrasInItem, getExtrasInItem) and multiple constants for key naming. The code implements new logic for priority-aware push/poll behavior and item extras storage.

4. Breadth of Subclass:  
The subclass is non-trivial: multiple new methods and constants, and full reimplementation of core scheduling behaviours (pushWhenNoDuplicate, poll). It’s more than a light extension.

5. Local Symptom Summary:  
Although the class adds substantial new functionality, it does make meaningful use of inherited members (pool, getItemKey, getSetKey) and purposefully overrides core methods to implement specialized behavior. The overrides are substantial, not trivial.

Final verdict:  
NO, I did not find Refused Bequest. The subclass intentionally specializes scheduling behavior (priority handling) and reuses key inherited resources/methods (pool, getItemKey/getSetKey); overrides are substantial rather than merely refusing the parent’s contract."
EnablePluginCommand.java,"1. Inheritance Pattern:  
Yes. The file defines class EnablePluginCommand which extends CLICommand.

2. Use of Inherited Functionality:  
The subclass overrides CLICommand methods: getShortDescription() and the core run() method. run() contains substantial logic (permission check, iterating pluginNames, restarting) and directly uses an inherited field stdout (stdout.printf). It does not merely call super.run() — the overrides implement the command’s behavior.

3. New/Independent Functionality:  
Yes. The class introduces its own fields (pluginNames, restart) and helper methods (enablePlugin, enableDependencies) that implement plugin-enabling behavior. Those responsibilities are specific to this CLI command but are the expected responsibilities of a CLICommand subclass.

4. Breadth of Subclass:  
Non-trivial — several fields and multiple non-trivial methods are present, implementing meaningful logic rather than serving as a trivial or marker subclass.

5. Local Symptom Summary:  
The subclass implements the required command contract (overrides run with substantial behavior, uses inherited stdout) and adds command-specific logic and helpers. There is no sign that it ignores or lightly overrides the parent’s responsibilities.

NO, I did not find Refused Bequest — the class meaningfully implements and uses the parent CLICommand contract (notably run() and inherited stdout) and provides appropriate command-specific functionality."
PoolStats.java,"1. Inheritance Pattern:
- The file defines ""public abstract class PoolStats"" and does not extend any user-defined class; it implicitly extends java.lang.Object.

2. Use of Inherited Functionality:
- There are no overrides of superclass methods (no toString/equals/hashCode overrides) and no use of super.*. Inherited Object behavior is not specialized.

3. New/Independent Functionality:
- PoolStats defines its own state and behavior: AtomicLong reloadAt, timeoutMs, several volatile connection counters, multiple getter methods, a protected abstract update(), and a private shouldLoad() concurrency helper. These are cohesive to pool statistics and not relying on an inherited API.

4. Breadth of Subclass:
- The class is non-trivial: several fields and methods, concurrency logic, and an abstract update hook for subclasses.

5. Local Symptom Summary:
- This is not a subclass misusing an inherited parent; it is a base/abstract class providing its own responsibilities and an abstract hook for specialization.

NO, I did not find Refused Bequest. (The class does not extend another user-defined class and shows cohesive, primary functionality rather than refusing a parent's contract.)"
MinMaxPriorityQueue.java,"1. Inheritance Pattern:  
Yes — this file defines ""public final class MinMaxPriorityQueue<E> extends AbstractQueue<E>"". The parent class is AbstractQueue.

2. Use of Inherited Functionality:  
The subclass overrides many core AbstractQueue/Queue methods (size(), add(), addAll(), offer(), poll(), peek(), iterator(), clear(), toArray(), etc.). These overrides are substantial implementations (not just trivial one-liners or mere calls to super). The class does not call super.* methods, but it implements the queue contract with full, non-trivial logic (custom heap management, iterator with fail-fast checks, etc.).

3. New/Independent Functionality:  
Yes — the class defines many new fields (minHeap, maxHeap, maximumSize, queue[], size, modCount) and many helper/inner types and methods (Builder, Heap, MoveDesc, QueueIterator, heap manipulation methods, peekFirst/peekLast/pollLast/removeLast, capacity/growth logic, etc.). Those additions are all for implementing the min-max priority queue behavior (not unrelated domains).

4. Breadth of Subclass:  
The subclass is non-trivial: it contains many fields, many methods, multiple inner classes, and considerable algorithmic code — clearly more than a light extension or marker.

5. Local Symptom Summary:  
This class does not show the typical symptoms of Refused Bequest. Although it doesn't call super.*, it purposefully overrides and implements the core queue behavior required by AbstractQueue with substantial code and specialized behavior (min-max heap). The new fields and methods are directly related to fulfilling the parent's contract in a specialized way.

Final verdict: NO, I did not find Refused Bequest. Evidence: many substantial overrides of AbstractQueue methods and extensive, queue-related implementation (heaps/iterators) rather than unrelated functionality."
MapDeserializer.java,"1. Inheritance Pattern:  
Yes. The file defines ""public class MapDeserializer extends ContextObjectDeserializer implements ObjectDeserializer"". The parent class is ContextObjectDeserializer.

2. Use of Inherited Functionality:  
There are no calls to super.* anywhere in this file, and I do not see usage of any inherited protected fields or methods from ContextObjectDeserializer. The only candidate ""override"" visible is getFastMatchToken(), which is a one-line return of JSONToken.LBRACE (a trivial implementation). Overall there is no substantial use or specialization of inherited behavior.

3. New/Independent Functionality:  
Yes. The class introduces many of its own methods (multiple deserialze overloads, static parseMap variants, createMap, createMap with features, etc.) and static/instance members. These implement detailed Map parsing and creation logic unrelated to any visible parent responsibilities.

4. Breadth of Subclass:  
The subclass is non-trivial: it contains many methods (parsing branches, type handling, map instantiation logic) and complex logic. It is clearly more than a light extension or marker.

5. Local Symptom Summary:  
The class shows symptoms consistent with Refused Bequest: it extends ContextObjectDeserializer but does not meaningfully use or override parent functionality (no super calls; only a trivial getFastMatchToken), while containing extensive independent logic and fields for map parsing/creation.

YES, I found Refused Bequest — main evidence: many new parsing/creation methods and logic with no calls to super or meaningful overrides of the parent (only a trivial getFastMatchToken)."
ConversionException.java,"1. Inheritance Pattern:
- Yes. The class ConversionException extends java.lang.Exception (parent class name: Exception).

2. Use of Inherited Functionality:
- Minimal. The file only defines three constructors that delegate to super(...). There are no overrides of inherited methods, no use of super beyond constructor delegation, and no interaction with inherited state beyond standard Exception construction. These are trivial delegations.

3. New/Independent Functionality:
- None significant. The subclass adds no fields and no methods other than constructors. It does not introduce new responsibilities or behavior beyond providing a specific exception type.

4. Breadth of Subclass:
- The subclass is trivial (small, only constructors). It is not a large class with many new fields/methods.

5. Local Symptom Summary:
- This class does not show symptoms of Refused Bequest. It is a conventional, lightweight custom exception type (a marker) that legitimately exists mainly to represent a specific error condition; it only delegates to the parent via constructors.

Final verdict:
NO, I did not find Refused Bequest."
Profiler.java,"1. Inheritance Pattern:
- This file defines an interface Profiler<T> and a nested static final class RequestInformation. There is no class here that extends another class (RequestInformation implicitly extends Object).

2. Use of Inherited Functionality:
- Not applicable: there are no subclasses in this file, so there are no overrides, no calls to super., and no interaction with inherited state.

3. New/Independent Functionality:
- The file declares profiling methods (beforeCall, afterCall) and a small immutable data holder RequestInformation. These are the interface's own API, not extra responsibilities grafted onto an unrelated parent.

4. Breadth of Subclass:
- Not applicable: there is no subclass. The interface plus its simple nested DTO are small and focused.

5. Local Symptom Summary:
- There are no symptoms of Refused Bequest in this file because no class inherits from a parent here; therefore no evidence of a subclass refusing an inherited contract.

Conclusion:
NO, I did not find Refused Bequest."
ParentRunnerTest.java,"NO, I did not find Refused Bequest

1. Inheritance Pattern:
- Yes. This file defines subclasses:
  - CountingRunListener extends RunListener.
  - Exclude extends Filter.
  - An anonymous subclass of TypeSafeMatcher<List<?>> is created in isEmpty().

2. Use of Inherited Functionality:
- Exclude: overrides shouldRun(Description) and describe(), implementing the Filter contract (uses Description and methodName). These are meaningful overrides, not trivial calls to super.
- CountingRunListener: overrides many RunListener callbacks (testSuiteStarted, testSuiteFinished, testStarted, testFinished, testFailure, testAssumptionFailure, testIgnored) and uses Failure/Description to distinguish suite vs test failures. These are substantive implementations of the parent API (no trivial passthroughs).
- Anonymous TypeSafeMatcher: overrides describeTo and matchesSafely with a concrete matching implementation.

3. New/Independent Functionality:
- CountingRunListener adds counters (several fields) and logic to increment them—this is clearly an implementation of the listener role, not unrelated behavior.
- Exclude stores a methodName field and applies it in shouldRun — functionality aligned with Filter's purpose.
- No subclass introduces fields or methods that appear unrelated to the parent’s responsibilities.

4. Breadth of Subclass:
- CountingRunListener is non-trivial (multiple fields and many overridden methods).
- Exclude is small but appropriately focused (two overrides + one field).
- Overall, subclasses are substantial where appropriate and focused on the parent's domain.

5. Local Symptom Summary:
- No signs of Refused Bequest. The subclasses meaningfully implement/override the parent contracts (Filter, RunListener, TypeSafeMatcher); they do not ignore inherited responsibilities in favor of unrelated functionality. The clearest sign against the smell: multiple meaningful overrides implementing the expected behavior of the parent classes."
NumberTest.java,"1. Inheritance Pattern:
- Yes. This class is declared as `public class NumberTest extends AbstractFakerTest`. The parent class name is AbstractFakerTest.

2. Use of Inherited Functionality:
- The subclass makes substantial use of an inherited member: it repeatedly calls `faker` (e.g., `faker.number().randomDigit()`, `faker.number().numberBetween(...)`), which is very likely a protected field or accessor provided by AbstractFakerTest.
- There are no method overrides in this file (no `@Override` methods) and no calls to `super.`. So it does not override or alter parent behavior; it mainly uses an inherited fixture (`faker`).

3. New/Independent Functionality:
- The class defines many test methods and several helper methods and fields of its own: constants (RANDOMIZATION_*), configuration doubles (`individualRunGtPercentUnique`, `percentRunsGtUniquePercentage`), and private helpers (`randomizationQualityTest`, `uniquePercentageOfResults`, `calculateNumbersToGet`). These implement test logic and quality checks specific to number generation.

4. Breadth of Subclass:
- The subclass is non-trivial: it contains many test methods and helper utilities; it is more than a light extension or marker.

5. Local Symptom Summary:
- This subclass does not show symptoms of Refused Bequest. It relies on inherited `faker` functionality heavily (the core purpose of these tests), does not override parent behavior, and the additional fields/methods are directly related to its testing responsibility rather than an unrelated domain.

Final verdict:
NO, I did not find Refused Bequest. Evidence: the class extensively uses the inherited `faker` fixture (meaningful use of parent-provided functionality), does not override parent behavior, and its added methods support its test role."
TextEditorUtils.java,"NO, I did not find Refused Bequest

Step-by-step answers:

1. Inheritance Pattern:
- Yes. There is an inner class FakeTextEditor that extends AbstractTextEditor. Parent class name: AbstractTextEditor.

2. Use of Inherited Functionality:
- The subclass does not override any methods and does not call super.*. It only accesses inherited static members/types: AbstractTextEditor.ACTION_MAP and the nested type AbstractTextEditor.IdMapEntry (iterating over ACTION_MAP and reading entries). There are no meaningful overridden behaviors — no instance method customizations.

3. New/Independent Functionality:
- FakeTextEditor introduces a single static helper method fillActionMap(Map<String,Integer>) to copy entries from ACTION_MAP into a provided map. The outer TextEditorUtils class contains many unrelated utility methods, but the subclass itself adds only this small helper, not a set of new responsibilities.

4. Breadth of Subclass:
- The subclass is trivial: one small static method, no fields, no overrides. It is not a non-trivial subclass with several new fields/methods.

5. Local Symptom Summary:
- The subclass does not show symptoms of Refused Bequest. It is a tiny utility shim used to access protected/static infrastructure of AbstractTextEditor rather than a full subclass that ignores the parent contract. Clearest sign: only a single helper method that reads a static ACTION_MAP; no overrides or instance specialization."
PageResult.java,"YES, I found Refused Bequest — many new pagination fields/methods and almost no use/overrides of ArrayList (only the super-constructor call).

1. Inheritance Pattern:
- Yes. The class PageResult<T> extends java.util.ArrayList<T>.

2. Use of Inherited Functionality:
- Minimal. The only explicit use of the parent is calling super(initialCapacity) in the constructor.
- There are no method overrides from ArrayList, no calls to super.someMethod(), and no visible direct interaction with inherited internal state beyond using ArrayList as the underlying collection.

3. New/Independent Functionality:
- Yes. The class introduces pagination-specific fields (page, pageSize, totalPage, total), getters/setters, and helper methods (isFirst, isLast), plus a DEFAULT_PAGE_SIZE constant. These represent a distinct responsibility (pagination metadata) separate from basic list behavior.

4. Breadth of Subclass:
- Non-trivial. Several fields, multiple constructors, and many accessor and helper methods are added — not a tiny extension.

5. Local Symptom Summary:
- The subclass shows symptoms of Refused Bequest: it adds substantial, independent pagination logic and data, while rarely or never overriding or explicitly using inherited ArrayList behavior (only setting initial capacity). The clearest sign: many new fields/methods for pagination and no meaningful overrides of parent behavior."
HikariPool.java,
SMSParsedResult.java,"1. Inheritance Pattern:
- Yes. The file defines class SMSParsedResult that extends ParsedResult.

2. Use of Inherited Functionality:
- The subclass calls the parent constructor via super(ParsedResultType.SMS) in both constructors.
- It overrides getDisplayResult() and uses maybeAppend(...) there — likely an inherited helper from ParsedResult — to build the display string. This override is substantive (it assembles a display result), not a trivial one-line call to super.
- No other direct use of inherited fields or extensive calls to super.otherMethod() are present in this file.

3. New/Independent Functionality:
- Yes. SMSParsedResult introduces its own fields (numbers, vias, subject, body) and multiple SMS-specific methods: two constructors, getSMSURI(), getters for fields, and the overridden getDisplayResult(). getSMSURI() builds an SMS URI string — clearly SMS-specific logic unrelated to generic ParsedResult behavior.

4. Breadth of Subclass:
- The subclass is non-trivial: several fields, two constructors, at least five public methods including a nontrivial getSMSURI() and an overridden getDisplayResult(). This is more than a light extension.

5. Local Symptom Summary:
- The class specializes parsed results for SMS and both introduces SMS-specific state/behavior and provides a meaningful override of getDisplayResult() using an inherited helper. It does not ignore the parent API — it uses the parent constructor and an inherited helper method — and the added functionality is an appropriate specialization.

Final verdict:
NO, I did not find Refused Bequest. Evidence: meaningful override of getDisplayResult() and use of inherited helper/constructor combined with appropriate SMS-specific fields and methods (e.g., getSMSURI()), indicating legitimate specialization rather than a refused bequest."
AnnotationScanner.java,"1. Inheritance Pattern:  
   This file defines an interface, AnnotationScanner. It does not define a class that extends another class (no parent class is present).

2. Use of Inherited Functionality:  
   Not applicable — there is no subclass in this file. The interface only declares three methods; there are no implementations, overrides, or uses of super. or inherited fields.

3. New/Independent Functionality:  
   The interface declares its own method signatures (getScanAnnotation, addListener, validate), but these are API contracts, not a subclass adding independent responsibilities.

4. Breadth of Subclass:  
   Not applicable — there is no subclass. The interface is small (three methods) and not a non-trivial class with many fields/methods.

5. Local Symptom Summary:  
   No symptoms of Refused Bequest are present in this file because there is no subclass extending and failing to use a parent’s functionality.

NO, I did not find Refused Bequest."
easyexcel-2.2.11_ExcelDataConvertException.java,"1. Inheritance Pattern:
- Yes. The class is ExcelDataConvertException and it extends RuntimeException.

2. Use of Inherited Functionality:
- Minimal. The class only calls super(message) and super(message, cause) in its constructors. It does not override any Throwable/Exception methods (no getMessage(), toString(), etc.), nor does it access inherited fields or call super.* elsewhere. The use of inheritance is trivial (constructor delegation only).

3. New/Independent Functionality:
- The subclass introduces its own fields (rowIndex, columnIndex, cellData, excelContentProperty) and corresponding getters/setters. These represent specific metadata about where and what failed during Excel data conversion — a domain-specific responsibility beyond RuntimeException’s behavior.

4. Breadth of Subclass:
- Non-trivial but small: several additional fields, constructors, and accessor methods. This is more than a marker but still typical for specialized exceptions.

5. Local Symptom Summary:
- The class adds specific state and behavior for Excel data conversion errors and makes only trivial use of the parent (only calling super constructors). However, this pattern is common and appropriate for custom exceptions: extending RuntimeException to be throwable while carrying extra context.

NO, I did not find Refused Bequest — evidence: only trivial use of the parent (constructor calls) while the added fields are purposeful exception context, not an unrelated responsibility."
Connection.java,"1. Inheritance Pattern:
- The file defines class Connection which does not extend any explicit class. It implements the Closeable interface. (Implicit parent is java.lang.Object.)

2. Use of Inherited Functionality:
- There are two obvious inherited/interface methods touched: toString() (overrides Object.toString()) and close() (implements Closeable.close()). Neither uses super.* nor accesses inherited state beyond the usual Object behaviour. The overrides are small and straightforward (toString builds a string; close delegates to disconnect()). No substantial calls to or overrides of complex parent behavior are present.

3. New/Independent Functionality:
- The class defines many fields (socketFactory, socket, outputStream, inputStream, timeouts, broken flag, etc.) and many methods for connection management, sending commands, reading protocol responses, timeout handling, etc. These represent a substantial, self-contained responsibility (managing a Redis socket/protocol).

4. Breadth of Subclass:
- The class is non-trivial: numerous fields and many methods (connect, disconnect, sendCommand, various get*Reply methods, timeout handling, read/flush helpers, etc.), not a light wrapper.

5. Local Symptom Summary:
- Because Connection does not extend a concrete parent class (only implements an interface) there is no evidence of a subclass inheriting a parent’s behavior and refusing to use it. The class primarily implements its own connection/protocol responsibilities.

NO, I did not find Refused Bequest."
CameraInputController.java,"1. Inheritance Pattern:
- Yes. The file defines class CameraInputController which extends GestureDetector.

2. Use of Inherited Functionality:
- The subclass makes substantial use of inherited behavior:
  - It calls super(...) in the constructor to install its GestureListener.
  - It overrides many input-processing methods from the parent: touchDown, touchUp, touchDragged, scrolled, keyDown, keyUp, and uses super.touchDown/ touchUp/ touchDragged in those overrides.
  - The overrides are not trivial one-liners: they add logic to track pointers, multitouch, button state, and translate drag/scroll/key events into camera operations. The class also provides and wires a CameraGestureListener (extending GestureAdapter) to handle gesture callbacks (zoom) and delegates to controller methods.
- Some methods do return false or call super, but the overrides typically add meaningful camera-related behavior rather than merely delegating.

3. New/Independent Functionality:
- Yes. The subclass introduces many camera-specific fields and behavior: rotateButton/angle, translateButton/units, forwardButton, activateKey and pressed flags, scroll/pinch factors, autoUpdate, target Vector3, translateTarget/forwardTarget/scrollTarget flags, Camera camera reference, tmp vectors, update(), process(), zoom(), pinchZoom(), and a nested CameraGestureListener. These implement a distinct responsibility: mapping input/gestures to 3D camera control.

4. Breadth of Subclass:
- The class is non-trivial: many fields, helper vectors, nested listener class, and several methods implementing complex behavior (update, process, touch handling, zoom/pinch handling). This is a full-featured controller, not a light extension.

5. Local Symptom Summary:
- The subclass does not show the typical symptoms of Refused Bequest. It meaningfully overrides and uses the parent class’s input/gesture handling (including calling super when appropriate) to implement the camera-control contract, while adding substantial, related functionality (mapping input to camera transforms).

Final verdict:
NO, I did not find Refused Bequest."
WebLogAspect.java,"1. Inheritance Pattern:
- No. The file defines class WebLogAspect but it does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:
- Not applicable: since WebLogAspect does not subclass anything, there are no inherited methods/fields to override, call via super., or otherwise use.

3. New/Independent Functionality:
- Yes. The class declares its own static LOGGER field, a pointcut method, and several advice methods (doBefore, doAfterReturning, doAround) plus a helper getParameter(...) — all implement logging/aspect concerns.

4. Breadth of Subclass:
- Not applicable as it is not a subclass. The class is non-trivial (multiple methods and logic) but not an extension of another type.

5. Local Symptom Summary:
- There are no symptoms of Refused Bequest because there is no inheritance relationship in this file.

NO, I did not find Refused Bequest. Main evidence: the class does not extend any parent class."
ComparisonCriteria.java,"1. Inheritance Pattern:
- The file defines ""public abstract class ComparisonCriteria"" and does not explicitly extend any other class. It implicitly extends java.lang.Object.

2. Use of Inherited Functionality:
- There are no overrides of inherited methods from a non-Object superclass and no use of super.*. The only method override in the file is an anonymous inner Object that overrides toString(), which is unrelated to ComparisonCriteria inheriting behavior. Thus the class does not call or override parent-class behavior beyond the implicit Object methods.

3. New/Independent Functionality:
- The class introduces substantial functionality: arrayEquals (public and private overload), several private helpers (getToStringableArrayElement, objectWithToString, componentTypeName, isArray), a private static sentinel field, and declares the protected abstract assertElementsEqual for subclasses. These represent a focused responsibility (array comparison criteria) implemented locally.

4. Breadth of Subclass:
- The class is non-trivial: multiple methods and a private static field; it is more than a light extension or marker and defines a clear set of behaviors to be reused/extended.

5. Local Symptom Summary:
- This file does not show Refused Bequest symptoms. It does not meaningfully extend another concrete parent (only Object), does not weakly use inherited features, and itself defines the core functionality and an abstract hook for subclasses.

Final verdict:
NO, I did not find Refused Bequest. Evidence: no explicit superclass beyond Object, no super/overrides of parent behavior, and the class provides substantial, self-contained functionality with an abstract method for intended specialization."
CodeCacheEventWalker.java,"1. Inheritance Pattern:
- Yes. This class is CodeCacheEventWalker which extends AbstractCompilationWalker.

2. Use of Inherited Functionality:
- It calls super(model) in the constructor.
- It overrides two inherited methods: reset() and visit(IMetaMember). The visit(...) override contains substantial logic (iterating compilations, parsing addresses, creating CodeCacheEvent objects) rather than being a trivial one-liner. None of the overrides call super.reset() or super.visit(...), and there are no explicit uses of super. other than the constructor call.

3. New/Independent Functionality:
- Yes. The class introduces a private result field (CodeCacheWalkerResult), a getResult() accessor, and substantial logic to build and collect CodeCacheEvent instances (parsing native addresses, handling errors, logging). This is domain-specific functionality separate from any visible inherited behavior.

4. Breadth of Subclass:
- The subclass is non-trivial: it has its own state and a fairly large visit(...) implementation with control flow, parsing, logging, and object construction — not just a marker or thin wrapper.

5. Local Symptom Summary:
- While the class adds significant new functionality and does not call super in its overrides, it also provides substantial overrides (especially visit) that implement the walker behavior expected of an AbstractCompilationWalker. Given the meaningful overrides and the constructor delegation to super, the class appears to be a concrete specialized walker rather than a subclass that merely refuses its parent's responsibilities.

NO, I did not find Refused Bequest. Evidence: meaningful overrides (not trivial) and constructor delegation to super; the subclass implements the expected walker behavior rather than merely adding unrelated features."
Dictionary.java,"1. Inheritance Pattern:
- The file defines ""public class Dictionary"" with no explicit ""extends"" clause. It therefore only implicitly extends java.lang.Object (no custom parent class).

2. Use of Inherited Functionality:
- The class does not override Object methods (toString, equals, hashCode, finalize, etc.) and contains no calls to super.*. There is no evidence of calling or specializing inherited behavior from a non-trivial parent.

3. New/Independent Functionality:
- Yes. The class introduces many fields (e.g., _MainDict, _QuantifierDict, _StopWords, configuration, props, scheduled pool, path constants) and many methods for loading dictionaries, reading files, fetching remote resources, and managing a singleton. These represent substantial, self-contained responsibilities related to dictionary management and I/O.

4. Breadth of Subclass:
- The class is non-trivial: dozens of methods and multiple fields, scheduled tasks, HTTP access, file system traversal, and parsing logic. It is more than a light extension or marker.

5. Local Symptom Summary:
- Refused Bequest is not applicable here because the class does not extend a domain parent beyond Object and therefore does not inherit meaningful behavior to refuse. The clearest sign is the absence of any explicit superclass and lack of overrides or super usage; all functionality is self-contained.

Final verdict:
NO, I did not find Refused Bequest. The class does not extend a meaningful parent (only java.lang.Object) and therefore cannot exhibit Refused Bequest in this file."
SmartContentSelector.java,"1. Inheritance Pattern:
- This file defines class SmartContentSelector which implements the Selector interface. It does not extend any parent class (no ""extends"" clause).

2. Use of Inherited Functionality:
- Since it implements an interface, there is no inherited implementation to reuse via super. It overrides/selects methods required by Selector: select(String) with a full custom algorithm, and selectList(String) which simply throws UnsupportedOperationException. There are no calls to super.* and no use of inherited state.

3. New/Independent Functionality:
- The class contains a substantial, self-contained HTML cleaning/content-extraction algorithm inside select(String) (regex cleaning, block distribution, thresholding, assembling text). That logic appears independent and not tied to any parent implementation or inherited fields.

4. Breadth of Subclass:
- The class is non-trivial in behavior: a fairly large method doing the extraction work. It does not add class-level fields, but adds significant method-level logic (not just a tiny override).

5. Local Symptom Summary:
- There is no subclassing of a concrete parent to refuse; the class implements an interface and provides its own large algorithm. One minor note: selectList throws UnsupportedOperationException, so it does not support the full interface contract, but this is not the classic Refused Bequest symptom.

Final decision:
NO, I did not find Refused Bequest. Evidence: the class does not extend any parent class (implements an interface), contains a standalone implementation (no use of super or inherited state), and the main issue is an unsupported interface method rather than refusal of an inherited class's behavior."
Faker.java,"1. Inheritance Pattern:  
- The file defines ""public class Faker"" with no ""extends"" clause. There is no parent class specified.

2. Use of Inherited Functionality:  
- Not applicable: there are no overridden methods, no calls to super., and no interaction with inherited state because Faker does not extend another class.

3. New/Independent Functionality:  
- Yes. Faker declares many private final fields (Ancient, App, Artist, Avatar, ..., EnglandFootBall) and provides constructors, factory-style instance() methods, lots of accessor methods, and string-generation helpers (numerify, letterify, bothify, regexify, expression, resolve). These are substantial, domain-specific responsibilities.

4. Breadth of Subclass:  
- Not applicable as a subclass. The class is non-trivial and large (many fields and methods), but it is not extending any parent.

5. Local Symptom Summary:  
- Because Faker does not extend a parent class, there is no evidence of Refused Bequest in this file. The clearest facts: no inheritance, no overrides, and the class is a large, self-contained provider of functionality.

Final conclusion: NO, I did not find Refused Bequest."
ConstructorConstructor.java,"1. Inheritance Pattern:
- The file defines a top-level class ConstructorConstructor which does not explicitly extend any other class. It implicitly extends java.lang.Object. There are several anonymous classes that implement ObjectConstructor<T>, but those are implementations of an interface, not subclasses of a custom superclass.

2. Use of Inherited Functionality:
- The only explicit override from a superclass is toString(), which overrides Object.toString() and returns instanceCreators.toString(). There are no calls to super.* anywhere in the file. The anonymous classes override construct() from the ObjectConstructor interface (not an inherited superclass), so there is no usage of inherited protected members or other parent-class behavior to inspect.

3. New/Independent Functionality:
- The class introduces its own fields (instanceCreators, accessor) and many methods (get, newDefaultConstructor, newDefaultImplementationConstructor, newUnsafeAllocator). It contains extensive logic to produce ObjectConstructor instances for many types — this is clearly its own independent functionality.

4. Breadth of Subclass:
- Not applicable in the usual sense because ConstructorConstructor is not a subclass of a richer parent class. The class itself is non-trivial: it contains many methods and anonymous inner classes, so it is a substantial class, not a light extension or marker.

5. Local Symptom Summary:
- There is no subclass that extends a meaningful parent class and then ignores inherited behavior. The only inheritance from a concrete parent is the implicit java.lang.Object; the class overrides only toString() in a small, relevant way. Anonymous classes implement an interface rather than extending and refusing a parent contract.

NO, I did not find Refused Bequest. The file does not define a subclass extending a richer parent class and therefore does not show the typical symptoms (many new unrelated fields/methods with few/weak overrides) of Refused Bequest."
StatisticSlot.java,"1. Inheritance Pattern:
- Yes. This file defines class StatisticSlot that extends AbstractLinkedProcessorSlot<DefaultNode>.

2. Use of Inherited Functionality:
- The subclass overrides entry(...) and exit(...). It calls inherited helper methods fireEntry(...) and fireExit(...), which are likely provided by AbstractLinkedProcessorSlot, but it does not simply delegate to super.entry(...) or super.exit(...). The overrides are substantial (large implementations) rather than trivial one-liners.

3. New/Independent Functionality:
- The class implements substantial statistics-related behavior: thread/pass/block counting, handling origin/global nodes, invoking callback registries, computing response time, and a private helper recordCompleteFor(...). This is significant, focused on runtime/statistics responsibilities.

4. Breadth of Subclass:
- The subclass is non-trivial: two long overridden methods and a helper method with multiple responsibilities. It contains no new fields but substantial logic.

5. Local Symptom Summary:
- The subclass implements extensive, focused behavior (real-time statistics) and uses a small set of inherited helpers (fireEntry/fireExit). This looks like a concrete specialization of an abstract slot rather than a subclass that refuses the parent's contract.

NO, I did not find Refused Bequest. Evidence: substantial meaningful overrides and use of inherited chain hooks (fireEntry/fireExit); the class provides large, appropriate specialization (statistics) rather than ignoring the parent."
HttpConnection.java,"1. Inheritance Pattern:  
- Yes. This file defines subclasses Request and Response that extend the nested parent class HttpConnection.Base (i.e., Request extends HttpConnection.Base<Connection.Request>, Response extends HttpConnection.Base<Connection.Response>).

2. Use of Inherited Functionality:  
- The subclasses make substantial use of inherited fields and methods from Base. Examples:
  - Request's constructor calls addHeader(...) and sets the inherited method field (method = Method.GET).
  - Request and Response use inherited header/cookie APIs (addHeader, header, cookie, cookies(), multiHeaders(), getHeadersCaseInsensitive(), etc.).
  - Response sets inherited url and method fields in its constructor (url = conn.getURL(); method = Method.valueOf(...)) and calls processResponseHeaders which uses addHeader/cookie.
- There are no trivial overrides that only call super; instead the subclasses rely on and manipulate the Base state and APIs.

3. New/Independent Functionality:  
- Yes. Both subclasses introduce many fields and methods that represent significant, specific responsibilities:
  - Request adds proxy, timeouts, maxBodySize, followRedirects, data collection, request body, parser settings, SSL factory, cookie manager, executing flag, and many request-building methods.
  - Response adds statusCode, statusMessage, byteData, bodyStream, HttpURLConnection conn, charset/contentType handling, execute/parse logic, redirect handling, response parsing, and many I/O helpers.

4. Breadth of Subclass:  
- The subclasses are non-trivial. They contain many fields and numerous methods; they implement substantial request/response behavior rather than acting as light extensions or markers.

5. Local Symptom Summary:  
- NO, I did not find Refused Bequest. Main evidence: the subclasses actively reuse and manipulate the Base class’s core state and APIs (headers, cookies, url, method) while adding substantial request/response-specific behavior — i.e., they extend Base to reuse common functionality rather than refusing it."
FireBirdMetaModel.java,"1. Inheritance Pattern:
- Yes. The file defines class FireBirdMetaModel which extends GenericMetaModel.

2. Use of Inherited Functionality:
- The subclass overrides many parent methods (createDataSourceImpl, createDataTypeCache, getViewDDL, getProcedureDDL, createProcedureImpl, supportsSequences, loadSequences, supportsTriggers, loadTriggers, getTriggerDDL, getErrorPosition, isSystemTable, prepareTableLoadStatement, createTableImpl, createTableColumnImpl, prepareUniqueConstraintsLoadStatement, getUniqueConstraintType, etc.).
- It seldom calls super.method(), but the overrides are substantive — they implement Firebird-specific SQL, parsing, and object creation rather than trivial one-line passthroughs.

3. New/Independent Functionality:
- The class declares a couple of private constants/fields (OBJECT_NAME_LENGTH, ERROR_POSITION_PATTERN) and many Firebird-specific behaviors (creating FireBirdDataSource, FireBirdSequence, FireBirdTrigger, FireBirdTable/View/Column, error position parsing, SQL statements tailored to RDB$* tables).
- Those new members represent specialization for the Firebird DBMS, not unrelated domain logic.

4. Breadth of Subclass:
- Non-trivial: the class contains many methods and substantial logic for loading sequences, triggers, tables, columns, and parsing error messages — not a light extension.

5. Local Symptom Summary:
- The subclass is a focused specialization for Firebird: many meaningful overrides implement DB-specific behavior and it adds only small supporting fields. It does not ignore the parent's contract; rather it customizes it.

Final verdict:
NO, I did not find Refused Bequest."
PendingEntry.java,"1. Inheritance Pattern:
- The file defines class PendingEntry. It does not declare an explicit parent with ""extends""; it only implicitly extends java.lang.Object.

2. Use of Inherited Functionality:
- There are no overrides of inherited methods (no toString(), equals(), hashCode(), etc.).
- The only direct use of the parent is a trivial call to super() in the constructor. No use of super.someMethod(), no interaction with inherited state beyond the implicit Object parent.

3. New/Independent Functionality:
- The class introduces its own fields (StreamMessageId id, String consumerName, long idleTime, long lastTimeDelivered) and simple getters for them. This is a small data-holder representing pending-message metadata.

4. Breadth of Subclass:
- The class is small but non-trivial for a value object: one constructor and four getters. It is not a broad feature-rich subclass.

5. Local Symptom Summary:
- This class does not show symptoms of Refused Bequest. It only inherits from Object (no meaningful parent contract to refuse), does not override or use inherited behavior in any substantive way, and simply defines a small, appropriate data-holder API.

Final verdict:
NO, I did not find Refused Bequest — the class only implicitly extends java.lang.Object, uses no meaningful inherited behavior (only a trivial super() call), and is a straightforward value object."
Location.java,
Evaluator.java,"1. Inheritance Pattern:
- Yes. The file defines many nested classes that extend a parent abstract class named Evaluator. (There are also intermediate abstract subclasses such as AttributeKeyPair, IndexEvaluator, and CssNthEvaluator that themselves extend Evaluator, and several concrete classes extend those.)

2. Use of Inherited Functionality:
- Yes. Subclasses consistently override the abstract method matches(Element root, Element element) (and often toString()). These overrides contain the concrete matching logic (not trivial one-liners that only call super). There are no inherited fields in Evaluator to reference, so subclasses implement the required contract rather than ignore it. A few toString() implementations are simple, but the core matches() implementations are substantive.

3. New/Independent Functionality:
- Subclasses declare their own fields (e.g., tagName, id, className, key/value/pattern) and methods implementing different matching strategies (attribute matching, index matching, text matching, nth-child logic, etc.). Those fields and methods represent specific selector responsibilities but are directly related to the Evaluator role.

4. Breadth of Subclass:
- The subclasses are non-trivial: many classes, several fields per class in places, and substantive logic in matches() implementations — this is more than a light extension or marker.

5. Local Symptom Summary:
- NO sign of Refused Bequest. Evidence: the subclasses meaningfully implement the parent's contract by overriding matches() with substantial logic; added fields/methods are relevant specializations for element-selection behavior rather than unrelated responsibilities.

Final verdict:
NO, I did not find Refused Bequest."
JsonAdapterAnnotationTypeAdapterFactory.java,"1. Inheritance Pattern:
- This file defines a class JsonAdapterAnnotationTypeAdapterFactory that implements the TypeAdapterFactory interface. It does not extend any other class.

2. Use of Inherited Functionality:
- The class implements/overrides the create(...) method required by TypeAdapterFactory and provides substantive logic (it looks up a @JsonAdapter annotation and delegates to getTypeAdapter). There are no calls to super. or inherited fields from a superclass (there is no superclass).

3. New/Independent Functionality:
- The class introduces one field (constructorConstructor), a constructor, the create(...) method, and a package-private getTypeAdapter(...) method that contains the core logic for constructing/adapting instances. This functionality directly implements the factory role (building TypeAdapters), not unrelated behavior.

4. Breadth of Subclass:
- The class is modest but non-trivial: one field and two main methods with branching logic. It is not merely a marker, but focused on the adapter-creation responsibility.

5. Local Symptom Summary:
- There are no symptoms of Refused Bequest. The type implements an interface and meaningfully fulfills that contract; it does not inherit a class and then ignore or avoid inherited functionality.

Final answer:
NO, I did not find Refused Bequest."
DriverDataSource.java,"1. Inheritance Pattern:  
- This class does not extend another concrete class; it implements the javax.sql.DataSource interface (DataSource).

2. Use of Inherited Functionality:  
- The class implements the DataSource methods: getConnection(), getConnection(String,String), getLogWriter(), setLogWriter(...), setLoginTimeout(...), getLoginTimeout(), getParentLogger(), unwrap(...), isWrapperFor(...).  
- Several methods meaningfully use or delegate to inherited/related functionality: getConnection(...) delegates to driver.connect(...); set/getLoginTimeout delegate to DriverManager; getParentLogger() delegates to driver.getParentLogger().  
- A few methods deliberately signal non-support by throwing SQLFeatureNotSupportedException (getLogWriter, setLogWriter, unwrap) or return false (isWrapperFor), but these are explicit decisions rather than trivial overrides that merely call super.

3. New/Independent Functionality:  
- The class introduces fields (jdbcUrl, driverProperties, driver) and substantial constructor logic to populate driverProperties, locate/instantiate a Driver, sanitize the URL, and validate the driver. Those responsibilities are central to providing connections and align with DataSource concerns rather than being unrelated functionality.

4. Breadth of Subclass:  
- The class is non-trivial: it has multiple fields, a complex constructor with classloading/driver-resolution logic, and implementations for DataSource methods. However, the extra code appears to implement the DataSource role (wrapping a JDBC Driver) rather than representing an unrelated domain.

5. Local Symptom Summary:  
- The class largely implements and delegates the DataSource contract (driver.connect, DriverManager usage, getParentLogger). The unsupported methods are explicit and limited. The additional fields/methods implement the data-source behavior (driver resolution and properties handling), not an unrelated responsibility.

Final decision:
NO, I did not find Refused Bequest. Evidence: the class implements DataSource and consistently implements/delegates DataSource responsibilities (driver.connect, DriverManager calls and driver management) rather than ignoring inherited contract while doing unrelated work."
AbstractMetaMember.java,"1. Inheritance Pattern:
- This file defines ""public abstract class AbstractMetaMember implements IMetaMember, Comparable<IMetaMember>"".
- It does not extend any explicit superclass (only extends java.lang.Object implicitly). So there is no parent class other than Object.

2. Use of Inherited Functionality:
- There are no calls to super.* and no overrides of methods from a concrete parent class (aside from implementing the Comparable interface's compareTo). The class provides many concrete method implementations required by IMetaMember.
- No trivial overrides of a parent class are present because there is no non-Object superclass to override from.

3. New/Independent Functionality:
- The class declares many fields (metaClass, compilations, selectedCompilationIndex, flags like isVarArgs/isPolymorphicSignature/isCompiled, modifier, memberName, returnType, paramTypes).
- It implements lots of behavior: signature matching, parameter/return-type handling, compilation storage/retrieval, bytecode and assembly attachment, regex building for source signatures, etc. These are substantial and domain-specific responsibilities.

4. Breadth of Subclass:
- The class is non-trivial: many fields and many helper and public methods. It is clearly more than a light extension or marker.

5. Local Symptom Summary:
- Refused Bequest looks for a subclass that inherits from a parent class but largely ignores or fails to use overridden/protected inherited features. In this file there is no superclass to refuse (only Object), and the class implements interfaces and provides substantial functionality itself.

Conclusion:
NO, I did not find Refused Bequest. Evidence: the class does not extend any non-trivial parent (only implements interfaces), so the core condition for Refused Bequest (subclass inheriting but not using parent members) is not present."
ParentRunner.java,"1. Inheritance Pattern:  
- Yes. This file defines ""ParentRunner"" which extends the class ""Runner"".

2. Use of Inherited Functionality:  
- ParentRunner overrides the core Runner API methods getDescription() and run(RunNotifier), implementing the Runner contract. These overrides are substantial (they construct descriptions, run the test suite, handle notifications and exceptions). It does not simply call super.* in these overrides; it provides full implementations of the expected behavior.

3. New/Independent Functionality:  
- ParentRunner introduces multiple fields (childrenLock, testClass, filteredChildren, scheduler) and many methods for managing children, filtering, sorting/ordering, class rules, before/after class handling, scheduling, and executing child tests. These are substantial new responsibilities, but they are clearly aligned with the role of a parent test runner rather than unrelated functionality.

4. Breadth of Subclass:  
- The class is non-trivial: many methods, an inner ClassRuleCollector class, and several fields — far more than a light extension.

5. Local Symptom Summary:  
- No strong signs of Refused Bequest. ParentRunner both implements the parent (Runner) contract with substantial overrides and provides extensive additional behavior that extends the runner responsibilities. The clearest evidence against Refused Bequest is the substantial, meaningful implementations of Runner’s core abstract methods (getDescription and run) and many methods that logically build on the Runner role.

NO, I did not find Refused Bequest."
OmsPortalOrderServiceImpl.java,"1. Inheritance Pattern:
- This file defines class OmsPortalOrderServiceImpl which implements the OmsPortalOrderService interface. It does not explicitly extend any other class (so its direct parent is Object).

2. Use of Inherited Functionality:
- Because it implements an interface rather than extending a concrete superclass, there are no uses of inherited superclass state or calls to super.* in this file.
- The methods annotated with @Override are implementations of the interface contract, and they contain full business logic (not trivial one-liners delegating to super).

3. New/Independent Functionality:
- The class introduces many fields (autowired services, mappers, DAOs, Redis key values) and implements a large set of order-related methods (generateConfirmOrder, generateOrder, paySuccess, cancelOrder, etc.). These are substantial, domain-specific responsibilities (order creation, coupon handling, stock locking, integration calculation, etc.).

4. Breadth of Subclass:
- The class is non-trivial: many fields and many helper/private methods (calculation, coupon handling, stock lock, paging/listing, etc.). It is a full service implementation rather than a light extension.

5. Local Symptom Summary:
- There is no evidence of Refused Bequest here: the class does not extend a parent class, there are no inherited protected members being ignored or trivial overrides, and the file contains substantial own functionality.

NO, I did not find Refused Bequest — main evidence: the class implements an interface (no superclass), contains many domain-specific fields/methods, and has no use of super/overridden superclass behavior."
JUnitCommandLineParseResult.java,"NO, I did not find Refused Bequest

1. Inheritance Pattern:
- The top-level class JUnitCommandLineParseResult does not extend any class (it extends java.lang.Object implicitly).
- There is a nested static class CommandLineParserError that extends java.lang.Exception.

2. Use of Inherited Functionality:
- CommandLineParserError only calls super(message) in its constructor and declares a serialVersionUID. It does not override any Exception methods or interact with inherited state beyond the trivial constructor call.

3. New/Independent Functionality:
- The nested subclass adds only a serialVersionUID field and a single constructor. The outer class itself introduces many fields and methods for parsing command-line arguments, but it does not extend or inherit from another class.

4. Breadth of Subclass:
- The subclass (CommandLineParserError) is trivial: one field and one constructor. The outer class is non-trivial, but it is not a subclass of another type.

5. Local Symptom Summary:
- No: the only subclass present is a minimal custom exception used to signal parser errors. This is a normal, appropriate specialization (few trivial additions), not a sign of Refused Bequest. The clearest sign that rules out the smell here is “only a tiny exception subclass with a constructor calling super; no substantial new, unrelated behavior.”"
ClassReader.java,"1. Inheritance Pattern:  
- This file defines ""public class ClassReader"" and it does not extend any other class (no ""extends"" clause). Parent class: none / N/A.

2. Use of Inherited Functionality:  
- Not applicable: there are no inherited methods or fields used, no overrides, and no calls to super.* (since the class does not extend another).

3. New/Independent Functionality:  
- The class defines its own fields (b, items, strings, maxStringLength, header, readAnnotations) and many methods for parsing class file bytes (constructing from InputStream, accept, getAttributes, readMethod, readUnsignedShort, readInt, readUTF8, readUTF). These represent a clear, self-contained responsibility (reading/parsing class files).

4. Breadth of Subclass:  
- The class is non-trivial: multiple fields and many substantial methods. It is a full implementation, not a thin wrapper or marker.

5. Local Symptom Summary:  
- There are no symptoms of Refused Bequest in this file because there is no inheritance to refuse. The class focuses on its own parsing logic and does not show weak or trivial use of a parent API.

NO, I did not find Refused Bequest."
XxlJobExecutor.java,"1. Inheritance Pattern:
- This file defines ""public class XxlJobExecutor"" and it does not extend any other class (no ""extends"" clause). So there is no parent class in this file.

2. Use of Inherited Functionality:
- Not applicable: there is no superclass, so there are no inherited methods or fields to override, call via super., or otherwise use.

3. New/Independent Functionality:
- The class introduces many fields (adminAddresses, accessToken, appname, address, ip, port, logPath, logRetentionDays, embedServer, and static repositories) and many methods (start, destroy, initAdminBizList, initEmbedServer, stopEmbedServer, registries/loaders for job handlers and threads, etc.). These represent substantial, self-contained responsibilities (server lifecycle, admin-client init, job/thread management, logging cleanup).

4. Breadth of Subclass:
- The class is non-trivial with many fields and methods; however, it is not a subclass at all.

5. Local Symptom Summary:
- Because XxlJobExecutor does not extend any parent class, there are no inheritance relationships to refuse. The clearest sign is simply the absence of a superclass (no ""extends""), so Refused Bequest cannot apply here.

NO, I did not find Refused Bequest — main evidence: the class does not extend any parent (no inherited members to refuse)."
InPacketHandler.java,"1. Inheritance Pattern:
- Yes. The file defines class InPacketHandler which extends io.netty.channel.SimpleChannelInboundHandler<PacketsMessage>.

2. Use of Inherited Functionality:
- The subclass overrides core handler methods: channelRead0(...) (substantial custom logic) and exceptionCaught(...). The channelRead0 method implements full decoding/routing logic (does not merely call super). exceptionCaught delegates to an ExceptionListener and only calls super.exceptionCaught(...) as a fallback. These are meaningful overrides, not trivial one-liners.

3. New/Independent Functionality:
- The class introduces several fields (packetListener, decoder, namespacesHub, exceptionListener) and a constructor to initialize them. It implements substantial logic: decoding packets, namespace lookup, client management, and invoking packetListener — responsibilities specific to packet processing rather than being unrelated to the parent’s role as a Netty inbound handler.

4. Breadth of Subclass:
- The subclass is non-trivial: it has multiple fields, a constructor, and two overridden methods with significant logic (especially channelRead0). This is more than a light or marker extension.

5. Local Symptom Summary:
- The subclass does not show symptoms of Refused Bequest. It meaningfully specializes the inbound-handler contract by overriding and implementing core behavior for incoming packets, and its new fields/methods are directly related to that responsibility.

Final verdict:
NO, I did not find Refused Bequest. The class provides substantial, appropriate overrides (especially channelRead0) and uses its new fields to implement the handler's expected responsibilities."
ConstrainableInputStream.java,"NO, I did not find Refused Bequest

Step-by-step:

1. Inheritance Pattern:
- Yes. The class ConstrainableInputStream extends BufferedInputStream.

2. Use of Inherited Functionality:
- The subclass overrides core methods (read(byte[], int, int) and reset()) and calls super.read(...) and super.reset().  
- It also uses an inherited protected field markpos (in reset()) and calls the super constructor.  
- The overrides are substantive: they add logic for capping reads, timeouts, and interruption handling rather than merely delegating to super.

3. New/Independent Functionality:
- The class introduces several fields (capped, maxSize, startTime, timeout, remaining, interrupted) and methods (wrap, readToByteBuffer, timeout, expired, constructor).  
- Those members implement the specialized responsibility of ""constrainable"" reading (size cap, timeouts, interrupt semantics), which is a meaningful specialization of an InputStream rather than unrelated behavior.

4. Breadth of Subclass:
- The subclass is non-trivial: multiple fields and helper methods, plus substantive overrides — not just a marker or tiny extension.

5. Local Symptom Summary:
- The subclass specializes and makes meaningful use of BufferedInputStream functionality (super calls, protected state) while adding related behavior (capping, timeout). The clearest sign against Refused Bequest is ""many new fields/methods, but they directly extend and modify inherited read/reset behavior (use of super and markpos) to implement constraints.""

Overall conclusion: the class is a focused specialization of BufferedInputStream and does not show the main symptoms of Refused Bequest."
AndroidGL20.java,"1. Inheritance Pattern:  
- This file defines class AndroidGL20 which implements the GL20 interface. It does not extend any class.

2. Use of Inherited Functionality:  
- Because it implements an interface there is no superclass implementation to override or call via super. The class does not use any inherited state or call super.*. All methods are implementations of GL20 and mostly delegate to Android's GLES20 static methods.

3. New/Independent Functionality:  
- The class declares a few small fields (ints, ints2, ints3, buffer) used as temporary arrays/buffers for JNI-style calls. It also provides convenience one-shot methods (e.g., glGenBuffer(), glDeleteBuffer(), glGetActiveAttrib/Uniform that fill buffers and return Strings). These are helper/adaptor logic for GL operations, not unrelated domain responsibilities.

4. Breadth of Subclass:  
- The class is fairly large (implements all GL20 methods) but most methods are thin delegations. It is non-trivial in size, but not in the sense of adding unrelated business logic.

5. Local Symptom Summary:  
- No symptoms of Refused Bequest: the class does not extend a concrete parent class, it implements the GL20 contract and primarily delegates to GLES20. The added fields/methods are small adaptor helpers related to GL duties.

Final decision: NO, I did not find Refused Bequest — evidence: class implements GL20 and simply delegates to GLES20 with small buffer helper fields (no superclass to refuse)."
SaJwtUtil.java,"1. Inheritance Pattern:  
   - This file defines class SaJwtUtil and it does NOT extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:  
   - Not applicable: there is no superclass, so there are no inherited methods/fields to override, call, or use.

3. New/Independent Functionality:  
   - SaJwtUtil defines many static constants and a collection of JWT-related utility methods (createToken, parseToken, getPayloads, getLoginId, getTimeout, etc.). These represent a cohesive, independent responsibility for JWT handling.

4. Breadth of Subclass:  
   - Not applicable as a subclass, but the class is non-trivial: it contains multiple methods and constants (a full utility API).

5. Local Symptom Summary:  
   - Because the class does not extend any parent, it cannot exhibit Refused Bequest in this file. The clearest sign is that SaJwtUtil is a standalone utility class, not a subclass.

NO, I did not find Refused Bequest."
Code.java,"1. Inheritance Pattern:  
   This file defines class Code but it does not explicitly extend any other class. It therefore implicitly extends java.lang.Object.

2. Use of Inherited Functionality:  
   There are no overridden methods and no uses of super.*. The class does not call or specialize any inherited (non-Object) behavior. (Note: the constructor is protected which allows subclassing, but no subclass is present in this file.)

3. New/Independent Functionality:  
   Yes — Code defines its own instance field (faker), several static arrays/constants, and many methods that implement ISBN/GTIN/IMEI/ASIN generation and checksum logic. This is substantial, self-contained functionality unrelated to any parent behavior in this file.

4. Breadth of Subclass:  
   The class is non-trivial: many methods and constants, multiple code-generation routines, and helper private methods. It is more than a light extension or marker.

5. Local Symptom Summary:  
   Because this class does not actually extend a non-trivial parent here (only Object), there is no evidence of a subclass refusing a parent's bequest in this file. Although the protected constructor suggests it was designed for subclassing, within this file there are no overrides or uses of inherited behavior to indicate Refused Bequest.

Final verdict: NO, I did not find Refused Bequest. Main reason: the class does not extend a concrete parent (only Object) and contains many self-contained methods with no overrides or super usage."
HomeController.java,"1. Inheritance Pattern:  
   - The file defines public class HomeController. It does not extend any other class (no ""extends"" clause), so there is no parent class in this file.

2. Use of Inherited Functionality:  
   - Not applicable: there are no overridden methods, no calls to super., and no interaction with inherited state because HomeController does not inherit from a custom parent class in this file.

3. New/Independent Functionality:  
   - Yes. HomeController introduces its own constants, three final fields (RestTemplate, OrderService, StorageService), a constructor, and two substantial endpoint methods (rest() and feign()) that perform HTTP calls and transactional orchestration.

4. Breadth of Subclass:  
   - Not applicable as a subclass, but the class is non-trivial: multiple fields, constructor, and two reasonably large methods with logic, error handling, and use of annotations (@GlobalTransactional, @GetMapping).

5. Local Symptom Summary:  
   - Because HomeController does not extend any parent class in this file, there is no evidence of a subclass refusing a bequest. The class uses composition and provides its own functionality rather than inheriting and then ignoring a parent's responsibilities.

Final verdict per instructions:
NO, I did not find Refused Bequest."
NacosWatch.java,"1. Inheritance Pattern:  
- The file defines class NacosWatch which implements ApplicationEventPublisherAware and SmartLifecycle. It does not extend any concrete parent class (only implicitly extends Object).

2. Use of Inherited Functionality:  
- NacosWatch implements interface methods (setApplicationEventPublisher, isAutoStartup, start, stop(Runnable), stop, isRunning, getPhase). Several of these (start, stop, stop(Runnable), setApplicationEventPublisher, isRunning) contain substantial logic (subscription, unsubscription, event publishing). A couple are trivial defaults (isAutoStartup returns true, getPhase returns 0). There is no use of super. There are no inherited/protected fields accessed.

3. New/Independent Functionality:  
- The class introduces multiple fields (listenerMap, running, nacosWatchIndex, publisher, nacosServiceManager, properties) and helper methods (buildKey, resetIfNeeded, selectCurrentInstance) and an internal EventListener with domain-specific behavior. This is substantial, domain-specific functionality (Nacos subscription and heartbeat publishing).

4. Breadth of Subclass:  
- The class is non-trivial: several fields, helper methods, and non-trivial implementations of lifecycle methods. It is more than a light wrapper.

5. Local Symptom Summary:  
- The Refused Bequest smell is not applicable here: the class does not extend a concrete parent class and it meaningfully implements interface methods and provides substantial, coherent domain-specific behavior.

NO, I did not find Refused Bequest."
DictSegment.java,"1. Inheritance Pattern:
- This file defines class DictSegment which does not extend any user-defined parent class. It implements Comparable<DictSegment>. (Implicit parent is java.lang.Object, but there is no explicit ""extends"" other than implementing the Comparable interface.)

2. Use of Inherited Functionality:
- The only inherited/interface method implemented is compareTo(…), from Comparable. That implementation is a simple one-line comparison of nodeChar.
- There are no calls to super.*, no overrides of meaningful Object methods (equals/hashCode/toString are not overridden), and no interaction with inherited state beyond the required compareTo. The compareTo is minimal/trivial in the sense that it just delegates to nodeChar.compareTo(...).

3. New/Independent Functionality:
- The class introduces many fields and methods implementing a trie/dictionary-segment: charMap, childrenArray, childrenMap, nodeChar, storeSize, nodeState, match(...), fillSegment(...), lookforSegment(...), migrate(...), getChildrenArray(), getChildrenMap(), etc.
- These members represent substantial, self-contained trie/dictionary responsibilities unrelated to Comparable (which only provides a comparison capability).

4. Breadth of Subclass:
- The class is non-trivial: multiple fields, many methods, synchronization, recursion, data-structure migration logic — clearly a substantial implementation, not a marker or tiny extension.

5. Local Symptom Summary:
- Since DictSegment does not extend a parent class (other than Object) and only implements a single interface method compareTo with a trivial body, there is no sign of a subclass inheriting but refusing a parent's responsibilities. The class primarily defines its own domain logic (trie node) and does not inherit unrelated behavior that it ignores.

Final verdict per instructions:
NO, I did not find Refused Bequest. Evidence: no explicit superclass is extended (only Comparable implemented), and the class mainly defines its own substantial trie functionality while only providing a trivial compareTo implementation."
RocketMQMessageHandler.java,"1. Inheritance Pattern:
- Yes. The class extends AbstractMessageHandler.

2. Use of Inherited Functionality:
- The class overrides AbstractMessageHandler.handleMessageInternal(...) with a large, substantive implementation (full RocketMQ send logic), not a trivial one-liner. It also uses the inherited logging facility (the inherited protected logger field). It does not simply call super.* to avoid inherited behavior; it provides meaningful override behavior as expected by the parent.

3. New/Independent Functionality:
- Yes. The class introduces many RocketMQ-specific fields and responsibilities (RocketMQTemplate, RocketMQHeaderMapper, transactional flag, destination, groupName, InstrumentationManager, producerProperties, partitioningInterceptor, sendFailureChannel, sync/running state) and implements substantial sending, async callback and error-handling logic tied to RocketMQ.

4. Breadth of Subclass:
- Non-trivial: multiple fields, a complex handleMessageInternal implementation, lifecycle start/stop logic, and various setters/getters — clearly more than a marker or light extension.

5. Local Symptom Summary:
- This subclass does not show symptoms of Refused Bequest. The clearest sign is that it provides a substantial, intended override of the abstract parent method (handleMessageInternal) to implement the specialized RocketMQ behavior and uses inherited infrastructure (logger). This is specialization rather than refusal.

NO, I did not find Refused Bequest."
NacosDiscoveryProperties.java,"1. Inheritance Pattern:  
   - This file defines ""public class NacosDiscoveryProperties"" and it does not declare ""extends"". It does not extend any custom parent class. (It only implicitly extends java.lang.Object.)

2. Use of Inherited Functionality:  
   - The class overrides Object methods equals, hashCode, and toString. Those overrides are substantial (custom implementations) but are overrides of java.lang.Object, not of a domain parent type.  
   - There are no uses of super.* and no interaction with an inherited parent class's state or behavior (because there is no explicit parent class being extended here).

3. New/Independent Functionality:  
   - The class introduces many fields (serverAddr, username, password, endpoint, namespace, metadata, ip, port, etc.) and many methods (init with @PostConstruct, getters/setters, overrideFromEnv, getNacosProperties, enrichNacosDiscoveryProperties, resolveKey, etc.). These represent configuration, environment resolution, network IP discovery, property enrichment, and Nacos-specific behavior — clearly its own responsibilities.

4. Breadth of Subclass:  
   - The class is non-trivial: numerous fields, lifecycle init logic, environment/property handling, network interface probing, and property conversion utilities. It is more than a light extension or marker.

5. Local Symptom Summary:  
   - Because this class does not extend any custom parent type (only implicitly extends Object), there is no opportunity for a Refused Bequest in the sense described. The class contains many self-contained responsibilities and only overrides basic Object methods.

NO, I did not find Refused Bequest."
HtmlTreeBuilderStateTest.java,"1. Inheritance Pattern:  
- The file defines class HtmlTreeBuilderStateTest. It does not explicitly extend any class (only the implicit parent java.lang.Object).

2. Use of Inherited Functionality:  
- There are no method overrides, no uses of super., and no direct interaction with any inherited (protected) state. The class only declares its own static helpers and @Test methods.

3. New/Independent Functionality:  
- The class introduces its own static helper methods (findConstantArrays, ensureSorted) and multiple test methods that parse HTML and assert results. These are independent test utility and verification responsibilities, unrelated to any parent class contract.

4. Breadth of Subclass:  
- The class is non-trivial (several methods, test cases, and helpers), but this is because it is a test class rather than an extension of a richer base class.

5. Local Symptom Summary:  
- Since this class does not extend a non-trivial parent (only Object) and there are no inherited members being ignored or overridden, there are no signs of Refused Bequest here.

NO, I did not find Refused Bequest."
QuotedStringTokenizer.java,"1. Inheritance Pattern:
- Yes. The class QuotedStringTokenizer extends java.util.StringTokenizer.

2. Use of Inherited Functionality:
- It overrides core methods: hasMoreTokens(), nextToken(), nextToken(String), hasMoreElements(), nextElement(), and countTokens().
- It does not meaningfully call super.* (only calls super("""") in the constructor). The tokenization logic is reimplemented using its own fields and state rather than using inherited state. A couple of overrides are small wrappers (nextElement delegates to nextToken), but the important methods replace the parent's behavior.

3. New/Independent Functionality:
- The class introduces many new fields (_string, _delim, _token, _i, _lastStart, flags like _double/_single, etc.).
- It provides many new methods and utilities unrelated to the parent API: static tokenize(...), quote(...), unquote(...), convertHexDigit(...), setters/getters for quoting behavior, and detailed quoting/unescaping logic.

4. Breadth of Subclass:
- The subclass is non-trivial: multiple fields, complex parsing state machine, and numerous helper/static methods — clearly more than a thin extension.

5. Local Symptom Summary:
- The subclass shows symptoms of Refused Bequest: it largely replaces the parent's core behavior (full overrides and its own state) and provides substantial new functionality (quoting/unquoting, helpers) instead of leveraging the parent.

YES, I found Refused Bequest — many new fields/methods and a full reimplementation of tokenization (overriding core methods without using super or inherited state), plus unrelated quoting utilities."
CodeCacheStage.java,"1. Inheritance Pattern:
- Yes. The class CodeCacheStage extends AbstractGraphStage.

2. Use of Inherited Functionality:
- It overrides redraw() and calls super.baseRedraw().  
- It accesses many likely-inherited fields and methods (canvas, gc, width, height, minX/maxX/minY/maxY, graphGapLeft/Top, normaliseX/normaliseY, drawAxes(), continueLineToEndOfXAxis(), drawLabel(), getApproximateStringWidth(), getStringHeight(), mainUI, setTitle/setScene/show(), etc.).  
- The override is substantial (implements full graph-drawing logic) rather than a trivial one-liner that only calls super.

3. New/Independent Functionality:
- Introduces its own field labelLeft and helper methods addToGraph(...) and showLabel(...).  
- Contains considerable CodeCacheEvent-specific logic: sorting events, computing ranges, branching on event types to draw lines/labels, color/linewidth choices — domain-specific responsibilities distinct from generic stage setup.

4. Breadth of Subclass:
- Non-trivial: constructor plus a sizeable redraw implementation and two helper methods; substantial logic and state management. This is more than a marker or a tiny extension.

5. Local Symptom Summary:
- No strong symptoms of Refused Bequest. The class meaningfully uses inherited state and helper methods (calls super.baseRedraw(), uses canvas/gc/normalise/drawAxes/etc.) and its override implements the expected specialization for a graphing stage. The subclass adds domain-specific behavior but operates within the parent’s drawing/graphing framework.

Final verdict:
NO, I did not find Refused Bequest — it makes substantial and appropriate use of inherited functionality while adding graph-specific behavior."
HTTPSession.java,"NO, I did not find Refused Bequest

Step-by-step:

1) Inheritance Pattern:
- This class does not extend another class. It implements the IHTTPSession interface. (No parent class via extends.)

2) Use of Inherited Functionality:
- There are no superclass methods/fields being inherited or overridden (no use of super.). The class implements interface methods (execute, parseBody, getters, etc.), but that is not subclassing behavior. It mainly interacts with a NanoHTTPD instance via composition (httpd.handle(this)) rather than using inherited state.

3) New/Independent Functionality:
- Yes. The class defines many fields (input/output streams, tempFileManager, uri, method, parms, headers, cookies, remoteIp, protocolVersion, buffers/counters) and many detailed methods for parsing HTTP headers, multipart/form-data, body reading, temp file management, and sending responses. These are substantial, independent responsibilities (HTTP session parsing/handling).

4) Breadth of Subclass:
- The class is non-trivial: numerous fields and many substantial private methods and public implementations. It is much more than a light extension or marker.

5) Local Symptom Summary:
- Because this is not a subclass (it implements an interface) and it does not inherit or ignore a parent class’s protected members, there are no signs of Refused Bequest. The clearest sign against the smell: no inheritance to refuse — the class defines and uses its own large set of responsibilities and composes with NanoHTTPD rather than extending it."
ParserConfig.java,"1. Inheritance Pattern:
- This file defines ""public class ParserConfig"" and it does not extend any other class (no ""extends"" clause). Parent class: none (implicitly extends java.lang.Object).

2. Use of Inherited Functionality:
- Not applicable: there is no superclass beyond Object. There are no overrides, no calls to super., and nothing that would indicate use/misuse of inherited protected members.

3. New/Independent Functionality:
- The class declares many fields and methods (deserializer registries, typeMapping, symbolTable, accept/deny hashcode arrays, autoType checking logic, ASM factory handling, etc.). These represent substantial responsibilities for parsing/deserialization, unrelated to any inherited contract.

4. Breadth of Subclass:
- Not a subclass, but the class itself is large and non-trivial: many fields, many helper and public API methods, complex initialization and logic.

5. Local Symptom Summary:
- Since ParserConfig is not a subclass, it cannot exhibit Refused Bequest in the strict sense. It is a large, self-contained class with many responsibilities, but there is no inheritance relationship to refuse.

Final verdict:
NO, I did not find Refused Bequest. (Reason: the class does not extend another class, so there is no inherited contract to be refused.)"
btActivatingCollisionAlgorithm.java,"NO, I did not find Refused Bequest

1. Inheritance Pattern:  
   - Yes. The file defines class btActivatingCollisionAlgorithm which extends btCollisionAlgorithm.

2. Use of Inherited Functionality:  
   - The subclass overrides reset, finalize, and delete, calls super constructors, and invokes super.reset/super.finalize/super.delete. These overrides are not pure one-liners that just call super; they add pointer and native-resource handling around the superclass behavior (e.g., managing swigCPtr, swigCMemOwn, and calling JNI delete). So inherited functionality is actively used.

3. New/Independent Functionality:  
   - The subclass introduces a single native-pointer field (swigCPtr) and a static getCPtr method and performs native memory management. This is narrowly focused on SWIG/native resource lifecycle, not a large, unrelated domain of responsibility.

4. Breadth of Subclass:  
   - The class is small and focused (constructors, pointer accessor, overrides for lifecycle). It is not a broad class with many unrelated fields/methods.

5. Local Symptom Summary:  
   - No symptoms of Refused Bequest: the class chiefly exists to extend the parent while adding native pointer/cleanup logic and makes meaningful use of the superclass lifecycle methods. The clearest sign is focused native-resource management around inherited methods rather than many unrelated fields/methods.

Conclusion: NO, I did not find Refused Bequest."
RedissonTransactionalBucket.java,"1. Inheritance Pattern:
- Yes. This file defines class RedissonTransactionalBucket<V> that extends RedissonBucket<V>.

2. Use of Inherited Functionality:
- It calls/uses some inherited features: super(...) in constructors, calls super.sizeAsync(), super.isExistsAsync(), super.getAsync() as fallbacks, and uses inherited helpers like getName(), getCodec(), encode(), and the inherited commandExecutor field.
- Many overridden methods replace parent behavior with transactional behavior (non-trivial overrides). Several overrides are trivial/explicitly block parent behavior by throwing UnsupportedOperationException (expire/move/migrate/etc).

3. New/Independent Functionality:
- Yes. The subclass introduces substantial new state and responsibilities: fields timeout, executed, operations, state, transactionId, and many methods to record transactional operations (getAndSet, compareAndSet, getAndDelete, set/trySet variants, executeLocked, getLockName, etc.). It builds and manages TransactionalOperation objects and transactional locking — a distinct domain from a plain bucket.

4. Breadth of Subclass:
- The subclass is non-trivial: many additional fields and many methods implementing full transactional semantics. It is far more than a light extension or marker.

5. Local Symptom Summary:
- The class shows symptoms consistent with Refused Bequest: it implements an almost orthogonal responsibility (transaction management) with many new fields/methods while only using a small set of parent capabilities (naming/encoding/getter fallbacks). Clear sign: many new fields/methods implementing transaction semantics and several overrides that replace or disable parent behavior.

YES, I found Refused Bequest — main evidence: many new transactional fields/methods and operations dominate the class while only a few inherited members (name/codec/encode/getAsync fallback) are used; several inherited behaviors are overridden or disabled."
HttpClientRequestContext.java,"1. Inheritance Pattern:
- The file defines public class HttpClientRequestContext.
- It does not declare an extends clause; it only implicitly extends java.lang.Object. (No parent class other than Object.)

2. Use of Inherited Functionality:
- There are no method overrides, no calls to super.*, and no use of inherited protected members. The class only declares its own getters and setters.

3. New/Independent Functionality:
- The class introduces two private fields (HttpUriRequest httpUriRequest and HttpClientContext httpClientContext) and simple getters/setters. These are small, self-contained responsibilities (a simple data holder for request + context).

4. Breadth of Subclass:
- The class is trivial: only two fields and four accessor methods. It is not a large or complex subclass.

5. Local Symptom Summary:
- There is no inheritance from a concrete parent and no evidence of ignoring or misusing inherited behavior. The class is a simple DTO-like holder and does not show the patterns of Refused Bequest.

NO, I did not find Refused Bequest. Evidence: the class does not extend any non-Object parent and only contains trivial getters/setters for two fields."
DefaultMQAdminExtImpl.java,"1. Inheritance Pattern:  
- This file defines class DefaultMQAdminExtImpl which implements two interfaces: MQAdminExt and MQAdminExtInner. It does not extend any other (concrete) class — there is no ""extends"" clause.

2. Use of Inherited Functionality:  
- There is no superclass, so there are no inherited concrete/protected members to override or call via super. The many @Override annotations are implementations of interface methods, not overrides of a parent class. The class mainly delegates to its mqClientInstance and defaultMQAdminExt fields; some methods contain non-trivial local logic, others are thin delegations.

3. New/Independent Functionality:  
- Yes. The class declares its own fields (defaultMQAdminExt, mqClientInstance, rpcHook, timeoutMillis, random, serviceState, etc.) and implements a large number of administrative methods (topic/broker/config/offset management, message tracking, reset logic, etc.). That is significant, self-contained functionality.

4. Breadth of Subclass:  
- The class is non-trivial: many fields and many methods with substantial logic. It's a full implementation of admin behaviors rather than a tiny extension.

5. Local Symptom Summary:  
- Refused Bequest is not applicable here because the class does not inherit from a concrete parent class. There is no use of super., no protected inherited state being ignored, and the class is an implementation of interfaces that either delegates to MQClientInstance or contains its own logic.

Final verdict per instructions:  
NO, I did not find Refused Bequest — the class implements interfaces (no superclass), so there is no parent class contract being inherited and refused."
Settings.java,"1. Inheritance Pattern:  
No — this file defines ""public class Settings"" and it does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:  
Not applicable — since Settings does not extend a parent class, there are no inherited methods/fields to override, call via super., or otherwise use.

3. New/Independent Functionality:  
Yes — the class declares many private properties (ObservableList, BooleanProperty, IntegerProperty, ObjectProperty, StringProperty, etc.), default constants, a Consumer<Settings> saveCmd, a constructor that wires listeners, a save mechanism, and many accessor methods. These represent its own settings-management responsibilities.

4. Breadth of Subclass:  
Not applicable as a subclass — but the class itself is non-trivial: many fields, listeners, and accessor methods.

5. Local Symptom Summary:  
There are no signs of Refused Bequest in this file because there is no inheritance to refuse. The clearest fact: Settings does not extend any parent, so the Refused Bequest smell cannot apply here.

NO, I did not find Refused Bequest."
ConnectionPageShellCommands.java,"1. Inheritance Pattern:  
Yes. The class ConnectionPageShellCommands extends ConnectionWizardPage.

2. Use of Inherited Functionality:  
The subclass overrides lifecycle methods (createControl and saveSettings) and calls parent-provided API such as setTitle, setDescription, setImageDescriptor and setControl to integrate into the wizard framework. It does not call super.createControl or super.saveSettings, but the overrides are substantial (building the UI and persisting settings) rather than trivial one-liners.

3. New/Independent Functionality:  
Yes. The class introduces many fields (dataSource, commandText, various Buttons/Spinners/TextWithOpenFolder, eventTypeTable, eventsCache) and many helper methods for managing event selection, updating DBRShellCommand instances, and UI wiring. This is significant, domain-specific functionality related to connection shell command editing.

4. Breadth of Subclass:  
Non-trivial — there are numerous fields and methods, event handling logic, UI layout code, and state management. This is a full-featured wizard page implementation.

5. Local Symptom Summary:  
Although the subclass adds a lot of its own functionality, it does use the parent’s contract (titles, image, setControl, and expected lifecycle methods) and provides meaningful overrides (createControl and saveSettings) that implement the page behavior. The overrides are substantial and appropriate for a wizard page.

NO, I did not find Refused Bequest."
MailUtil.java,"1. Inheritance Pattern:
- The file defines ""public class MailUtil"" and it does not extend any other class (no ""extends"" clause). So there is no parent class in this file.

2. Use of Inherited Functionality:
- Not applicable: since MailUtil does not extend a parent, there are no inherited methods/fields to override, call via super., or interact with.

3. New/Independent Functionality:
- MailUtil introduces many static methods (multiple overloads of send/sendHtml/sendText, getSession, private helpers like splitAddress) and coordinates other types (Mail, MailAccount, GlobalMailAccount). Its responsibilities are focused on providing email-sending utilities rather than reusing a parent’s behavior.

4. Breadth of Subclass:
- Not applicable as a subclass (no inheritance). The class is non-trivial: many public static overloads and private helpers, but they are all self-contained utility methods.

5. Local Symptom Summary:
- There are no symptoms of Refused Bequest because MailUtil does not extend any class. It is a standalone utility class with many independent methods.

Final verdict:
NO, I did not find Refused Bequest — the class does not inherit from any parent (so the Refused Bequest smell cannot apply)."
HttpRequestMethodsMatcherTest.java,"1. Inheritance Pattern:
- Yes. The class extends AbstractHttpRequestMatcherTest<HttpRequestMethodsMatcher>.

2. Use of Inherited Functionality:
- The subclass overrides three methods from the parent: testEqualsAndHashCode(), testGetContent(), and testGetToStringInfix().
- There is no use of super.method() visible, nor direct access to inherited fields in this file. However, the overrides provide concrete test implementations (assertions) that fulfill the parent's contract rather than ignoring it.

3. New/Independent Functionality:
- The subclass declares one new field: HttpRequestMethodsMatcher matcher = new HttpRequestMethodsMatcher(""GET"");
- The methods operate on that matcher to assert behavior specific to HttpRequestMethodsMatcher. This new functionality is a focused specialization for testing that matcher, not unrelated behavior.

4. Breadth of Subclass:
- The class is small: one field and three overridden methods. It is not a broad class with many unrelated fields or responsibilities.

5. Local Symptom Summary:
- The subclass does not show symptoms of Refused Bequest. It provides required overrides implementing the parent's testing contract and introduces a small, related field for those tests.

NO, I did not find Refused Bequest. Evidence: the class implements multiple meaningful overrides to fulfill the parent's abstract test contract and only adds a small, related matcher field rather than unrelated functionality."
SymbolInfo.java,"1. Inheritance Pattern:
- This file defines class SymbolInfo which does not extend any other class (no ""extends"" clause). Parent class: none.

2. Use of Inherited Functionality:
- Not applicable: SymbolInfo is not a subclass, so there are no overrides, no super. calls, and no use of inherited protected members.

3. New/Independent Functionality:
- SymbolInfo declares many fields (rectangular, dataCapacity, errorCodewords, matrixWidth, matrixHeight, dataRegions, rsBlockData, rsBlockError) and many methods for lookup, dimension calculations, and getters — substantial self-contained responsibilities related to DataMatrix symbol metadata.

4. Breadth of Subclass:
- Not applicable as a subclass. The class itself is non-trivial: several fields, static symbol table, factory/lookup logic, and several computation methods.

5. Local Symptom Summary:
- Because this class does not inherit from a parent, there are no symptoms of Refused Bequest in this file.

Final verdict:
NO, I did not find Refused Bequest."
TextureAtlas.java,"1. Inheritance Pattern:  
- Yes. This file defines subclasses: AtlasRegion extends TextureRegion, AtlasSprite extends Sprite. TextureAtlas implements Disposable (interface).

2. Use of Inherited Functionality:  
- AtlasRegion: calls super(texture, ...), uses inherited setters/getters (setRegion, getRegionWidth/Height), and overrides flip(...) while calling super.flip(...) and then adjusting offsets — a non-trivial override that augments base behavior.  
- AtlasSprite: heavily overrides many Sprite methods (setPosition, setX/Y, setBounds, setSize, setOrigin, flip, rotate90, getX/Y, getOriginX/Y, getWidth/Height, etc.), calling super methods and adjusting behaviour with region-specific offsets and ratios. These overrides are substantial, not just one-liners or trivial calls to super.  
- TextureAtlas.dispose implements the Disposable contract and operates on local texture collection.

3. New/Independent Functionality:  
- AtlasRegion adds many fields (index, name, offsetX/Y, packedWidth/Height, originalWidth/Height, rotate/degrees, names/values) representing atlas/packing metadata.  
- AtlasSprite stores an AtlasRegion and original offset fields and implements positioning/size/origin logic to account for whitespace/rotation/packing.  
- While these are new fields and methods, they are directly related to texture/sprite responsibilities (specialized handling for packed atlases), not unrelated domains.

4. Breadth of Subclass:  
- Yes. Both AtlasRegion and AtlasSprite are non-trivial: multiple new fields and many overridden/added methods. They are substantial extensions rather than tiny markers.

5. Local Symptom Summary:  
- No strong symptoms of Refused Bequest. The subclasses meaningfully use and override inherited behavior (many substantial overrides, calls to super, interaction with inherited state) and their added fields/methods clearly specialize and complement the parent responsibilities (handling atlas packing, offsets, rotation).

Final verdict: NO, I did not find Refused Bequest."
ImmutableEnumMap.java,"1. Inheritance Pattern:  
Yes. The file defines final class ImmutableEnumMap<K extends Enum<K>, V> that extends IteratorBasedImmutableMap<K, V>.

2. Use of Inherited Functionality:  
Yes. The subclass overrides many core map-related methods from the parent (keyIterator, keySpliterator, entryIterator, entrySpliterator, size, containsKey, get, equals, forEach, isPartialView, writeReplace). The overrides are not trivial one-liners delegating to super; they implement the immutable-map contract by delegating to the internal EnumMap (i.e., meaningful overrides/adaptations rather than ignoring the parent).

3. New/Independent Functionality:  
It introduces an internal transient EnumMap<K,V> delegate field, a static factory asImmutable(EnumMap), and a private EnumSerializedForm class for serialization. These are specializations for enum-backed maps but are directly related to the ImmutableMap role rather than being unrelated responsibilities.

4. Breadth of Subclass:  
Non-trivial: several fields/methods and a serialization helper. However, the added members all support the enum-backed immutable map behavior.

5. Local Symptom Summary:  
This subclass does not show signs of refusing the parent’s responsibilities — it implements and overrides the parent’s core behaviors and aligns with the ImmutableMap contract. The clearest sign against Refused Bequest is the multiple meaningful overrides that directly fulfill the parent’s API by delegating to the EnumMap.

NO, I did not find Refused Bequest."
CharacterReader.java,"1. Inheritance Pattern:
- The file defines ""public final class CharacterReader"". It does not declare ""extends"" and therefore does not extend any other (user-defined) class.

2. Use of Inherited Functionality:
- Not applicable: there is no parent class declared, so there are no inherited methods/fields to override, call with super., or otherwise use.

3. New/Independent Functionality:
- The class is self-contained and introduces many fields (charBuf, reader, bufPos, bufLength, bufMark, stringCache, etc.) and many parsing/buffering methods (bufferUp, consume*, matches*, nextIndexOf, cacheString, rangeEquals, etc.). These represent substantial, independent responsibilities for reading and tokenizing characters.

4. Breadth of Subclass:
- Not applicable as a subclass. The class itself is non-trivial: many fields and methods, complex logic for buffering and string caching.

5. Local Symptom Summary:
- Since CharacterReader does not extend a parent, there are no signs of a subclass refusing a bequest. The clearest evidence is simply that the class does not inherit from any other class.

Final verdict:
NO, I did not find Refused Bequest."
ArgumentTokenizer.java,"1. Inheritance Pattern:  
   The file defines an abstract class ArgumentTokenizer. It does not explicitly extend any other class (implicitly extends java.lang.Object).

2. Use of Inherited Functionality:  
   There are no instance method overrides, no calls to super., and no use of inherited state. All functionality here is static (utility-style). The only non-public API is a protected static helper, but there is no subclass in this file to show any inheritance usage.

3. New/Independent Functionality:  
   Yes — the class introduces its own constants, static state-machine logic, and two main static methods (tokenize overloads) plus a protected static helper for escaping. These represent an independent responsibility (string/token parsing/escaping).

4. Breadth of Subclass:  
   Not applicable as a subclass — the class is non-trivial (multiple fields and methods), but it is a standalone utility class rather than a light extension of a parent.

5. Local Symptom Summary:  
   The Refused Bequest smell concerns a subclass that inherits but does not use or honor parent behavior. This file contains no subclassing beyond Object and no overrides or use of inherited members, so there is no local evidence of Refused Bequest.

NO, I did not find Refused Bequest."
JobLogController.java,"1. Inheritance Pattern:
- This file defines class JobLogController but it does not extend any other class (no ""extends"" clause). So there is no parent class in this file.

2. Use of Inherited Functionality:
- Not applicable: there is no superclass, so there are no overrides, no super.method() calls, and no direct use of inherited members.

3. New/Independent Functionality:
- The class declares several injected DAO fields (xxlJobGroupDao, xxlJobInfoDao, xxlJobLogDao) and many controller methods (index, getJobsByGroup, pageList, logDetailPage, logDetailCat, logKill, clearLog). These represent substantial, self-contained web/controller logic unrelated to any inherited behavior.

4. Breadth of Subclass:
- Not applicable as a subclass. The class is non-trivial: it contains multiple fields and many methods implementing significant behavior (DB access, pagination, log fetching/killing/clearing).

5. Local Symptom Summary:
- Because JobLogController does not extend a parent class, the Refused Bequest smell does not apply here. There are many own fields/methods, but no inherited contract is being refused.

Final answer per instruction:
NO, I did not find Refused Bequest. Main reason: the class does not extend any superclass (no inheritance to refuse)."
Monitor.java,"1. Inheritance Pattern:
- This file defines class Monitor which implements the Runnable interface. It does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:
- There is no superclass, so there are no inherited concrete methods or protected fields to use or override. The class implements the Runnable.run() method (interface implementation), but it does not call super.* anywhere. The run() implementation is non-trivial (it performs a privileged action that calls runUnprivileged()), not a trivial one-liner delegation to a parent.

3. New/Independent Functionality:
- Yes. Monitor defines its own fields (last_modified, eTags, location, httpclient, logger) and methods (constructor, run, runUnprivileged) that implement HTTP HEAD polling, response handling, and dictionary reload logic (Dictionary.getSingleton().reLoadMainDict()). These responsibilities are specific and unrelated to any parent class behavior (there is no parent).

4. Breadth of Subclass:
- The class is non-trivial: multiple fields, error handling, HTTP client interactions, timeout config, and reload logic. It is more than a marker or light extension.

5. Local Symptom Summary:
- Because Monitor does not extend a parent class, Refused Bequest (a subclass inheriting but not using parent functionality) cannot apply here. The clearest sign is simply: no superclass is extended—only Runnable is implemented—so there is no bequest to refuse.

NO, I did not find Refused Bequest."
HistoryPageFilter.java,"1. Inheritance Pattern:
- This file defines ""public class HistoryPageFilter<T>"" and it does not declare ""extends"".  
- Parent class: none (does not extend any other class).

2. Use of Inherited Functionality:
- Not applicable: there is no superclass, so there are no inherited methods/fields to override, call via super., or use.

3. New/Independent Functionality:
- The class introduces many fields (maxEntries, newerThan, olderThan, searchString, queueItems, runs, paging flags, nextBuildNumber, widget, newestOnPage, oldestOnPage) and many methods for adding/sorting items, paging logic, search/filtering, and working with Queue.Item and Run types. This is substantial, self-contained functionality.

4. Breadth of Subclass:
- Not applicable as a subclass, but the class is non-trivial: it contains many methods and state, so it is clearly more than a light extension or marker.

5. Local Symptom Summary:
- Because the class does not extend any other class, it cannot exhibit Refused Bequest in this file. The clearest sign: no superclass is declared.

Final answer:
NO, I did not find Refused Bequest — the class does not extend a parent class (so there is no inherited contract to refuse)."
HandshakeData.java,"1. Inheritance Pattern:
- This file defines ""public class HandshakeData implements Serializable"". It does not extend any explicit parent class (implicitly extends java.lang.Object).

2. Use of Inherited Functionality:
- There are no overrides of Object methods (no toString, equals, hashCode, etc.) and no use of super.*. So there is no evidence of overriding or calling inherited behavior beyond the implicit Object inheritance.

3. New/Independent Functionality:
- The class declares its own fields (headers, address, time, local, url, urlParams, xdomain) and several accessor methods and a convenience method getSingleUrlParam. These are self-contained and represent the class's primary responsibilities.

4. Breadth of Subclass:
- N/A as this is not a subclass. The class is non-trivial (multiple fields and methods), but not a subclass extending another concrete class.

5. Local Symptom Summary:
- Because HandshakeData does not extend another class (only implements Serializable) there is no inheritance relationship to “refuse.” The class introduces its own fields and accessors and does not interact with a superclass.

NO, I did not find Refused Bequest — the class does not extend a parent class (only implements Serializable), so there is no inherited contract that could be refused."
Vault.java,"1. Inheritance Pattern:
- This file defines ""public class Vault"" with no ""extends"" clause. There is no parent class in this file.

2. Use of Inherited Functionality:
- Not applicable: Vault does not extend another class, so there are no overridden methods, no use of super.*, and no inherited fields to call or specialize.

3. New/Independent Functionality:
- Yes. Vault declares many fields (vaultSettings, volumeProvider, cryptoFileSystem, state, lastKnownException, configCache, stats, various bindings and properties, volume, etc.) and many methods (create/destroy CryptoFileSystem, unlock, lock, reveal, numerous property getters, access helpers, equals/hashCode, etc.). These represent substantial, self-contained responsibilities around vault lifecycle, mounting, and state.

4. Breadth of Subclass:
- Not applicable as a subclass. The class itself is non-trivial with many fields and methods.

5. Local Symptom Summary:
- Because Vault does not extend any class, it cannot exhibit Refused Bequest in this file. The class is substantial and self-contained, but there is no superclass relationship to refuse.

Final verdict:
NO, I did not find Refused Bequest."
CommandDecoder.java,"1. Inheritance Pattern:
- Yes. The class CommandDecoder extends ReplayingDecoder<State> (Netty's ReplayingDecoder with a State type).

2. Use of Inherited Functionality:
- The subclass meaningfully uses inherited functionality: it overrides the decode(ChannelHandlerContext, ByteBuf, List<Object>) method (the core ReplayingDecoder hook) and contains non-trivial logic in that override.
- It calls inherited state-management methods repeatedly: state(), state(new State()), state(null), checkpoint() and checkpoint(...) — i.e., it relies on the ReplayingDecoder state/checkpoint mechanism rather than ignoring it.
- No trivial override: the decode override is substantial (not just a one-liner or a simple call to super).

3. New/Independent Functionality:
- Yes. The class introduces many fields and methods for Redis protocol handling: sendNext, skipCommand, skipDecode, decodeCommand, decodeCommandBatch, decodeList, selectDecoder, messageDecoder, readBytes, readLong, handleResult, completeResponse, etc. Those implement detailed Redis decoding logic and error handling.

4. Breadth of Subclass:
- The subclass is non-trivial: many helper methods and logic blocks, a logger and scheme field, and substantial decoding and batching logic — far beyond a light extension.

5. Local Symptom Summary:
- The subclass does not show the typical Refused Bequest symptom. It both overrides the parent’s core decoding hook and actively uses ReplayingDecoder’s state/checkpoint API; the added methods specialize and implement the expected decoding responsibilities rather than ignoring the parent contract.

Final verdict:
NO, I did not find Refused Bequest. Evidence: substantial override of decode and repeated use of ReplayingDecoder state()/checkpoint() APIs (not merely inheriting without using parent features)."
FxApplication.java,"1. Inheritance Pattern:  
Yes. The class is FxApplication and it extends javafx.application.Application.

2. Use of Inherited Functionality:  
Very limited. The class overrides start(Stage) but the override only throws UnsupportedOperationException (""Use start() instead.""), i.e., a trivial refusal to implement the parent contract. It does not call super.start(...) or otherwise interact with Application instance lifecycle methods (no init() or stop() overrides). It only uses a static method Application.setUserAgentStylesheet (not an instance override) — so there is no substantial use of inherited instance behaviour.

3. New/Independent Functionality:  
Yes. The class defines many fields (settings, mainWindow, preferencesWindow, quitWindow, unlock/lock workflow providers, vaultService, licenseHolder, visibleWindows, hasVisibleWindows, appearanceProvider, trayIntegration, etc.) and many methods implementing window management, vault lock/unlock workflows, theme handling, tray integration, and other app-specific logic. These represent substantial, domain-specific responsibilities unrelated to Application's lifecycle contract.

4. Breadth of Subclass:  
Non-trivial. The class is large with many fields and methods. It manages UI components, workflows, theme logic, listeners, and vault-related services — clearly more than a light extension.

5. Local Symptom Summary:  
Yes — the subclass exhibits strong symptoms of Refused Bequest: it refuses to implement the parent’s required start(Stage) (throwing an exception), provides its own start() instead, and implements a large set of unrelated responsibilities (many new fields/methods) while making almost no meaningful use of the parent’s inherited instance behavior.

Final verdict: YES, I found Refused Bequest — clear evidence: overrides start(Stage) only to throw (refusing the parent contract) while providing many unrelated fields/methods implementing independent functionality."
HttpHeadRequestTest.java,"1. Inheritance Pattern  
- Yes. The class HttpHeadRequestTest extends HttpServerTest.

2. Use of Inherited Functionality  
- The subclass makes substantial use of inherited functionality: it calls super.setUp() in its override, uses many inherited fields (this.testServer.*: response, decodedParamters, parms, parameters, header, files, uri, method), and calls inherited helper methods (invokeServer, assertResponse). The only overridden method is setUp(), which calls super and then adjusts the test server response (a small customization, but not a trivial super-only one-liner).

3. New/Independent Functionality  
- The subclass does not introduce new fields; it only provides many @Test methods that exercise behavior. Those test methods largely rely on the inherited test infrastructure and state rather than establishing an independent domain or unrelated responsibilities.

4. Breadth of Subclass  
- The class is non-trivial in the sense it contains many test methods, but these are conventional unit tests that rely heavily on the parent test harness rather than implementing a separate responsibility.

5. Local Symptom Summary  
- The subclass heavily uses inherited state and helpers, provides one small override of setUp(), and doesn't add new fields or unrelated logic. There is no clear sign that it refuses the parent's contract.

NO, I did not find Refused Bequest."
BatchExecutor.java,"1. Inheritance Pattern:  
- Yes. The class BatchExecutor extends BaseExecutor.

2. Use of Inherited Functionality:  
- It overrides several core executor methods: doUpdate, doQuery, doQueryCursor, doFlushStatements (non-trivial overrides implementing batch behavior).  
- It calls and relies on inherited/protected functionality: getConnection(...), applyTransactionTimeout(stmt), closeStatement(stmt), the inherited field/variable transaction (transaction.getTimeout()), and the wrapper field used when creating StatementHandler.  
- None of the overrides are trivial one-liners or merely super.method() — they implement substantial batch-specific logic.

3. New/Independent Functionality:  
- Yes. BatchExecutor introduces its own fields (statementList, batchResultList, currentSql, currentStatement) and implements batch-oriented logic (queuing statements, tracking BatchResult, executing stmt.executeBatch(), handling BatchUpdateException, key generation after batch, etc.), which are specific responsibilities distinct from a generic executor.

4. Breadth of Subclass:  
- The subclass is non-trivial: multiple fields and several sizable methods with control flow, error handling, and batch-specific state management.

5. Local Symptom Summary:  
- The class appears to be a purposeful specialization to provide batching behavior: many new fields/methods and substantial overrides that use inherited helpers. It does not merely ignore inherited functionality — it uses protected utilities and overrides core contract methods to implement a different execution strategy.

Final verdict:
NO, I did not find Refused Bequest."
TokenQueue.java,"1. Inheritance Pattern:
- This file defines class TokenQueue but it does not extend any explicit parent class (it implicitly extends java.lang.Object). No superclass name other than Object is declared.

2. Use of Inherited Functionality:
- The class only overrides toString() (from Object). There are no calls to super., no use of protected/inherited fields or methods from a custom parent, and no meaningful inherited API being specialized.

3. New/Independent Functionality:
- TokenQueue defines its own fields (queue, pos, ESC) and many parsing/consuming helper methods (matches, consume, chompBalanced, consumeToIgnoreCase, consumeWord, etc.). These represent a self-contained parsing responsibility.

4. Breadth of Subclass:
- The class is non-trivial with many methods and logic; it is a full-featured utility type rather than a light extension of a parent.

5. Local Symptom Summary:
- Because TokenQueue does not extend a non-Object parent, there is no evidence of a subclass that refuses a parent's bequest. The class is self-contained and does not show the hallmarks of Refused Bequest.

Final verdict:
NO, I did not find Refused Bequest. Evidence: no explicit superclass (only Object), only a toString() override, and the class implements extensive, self-contained functionality."
DubboServiceMetadataRepository.java,"1. Inheritance Pattern:
- This file defines class DubboServiceMetadataRepository, but it does not extend any other class. It implements two interfaces: SmartInitializingSingleton and ApplicationEventPublisherAware. There is no ""extends"" parent class.

2. Use of Inherited Functionality:
- There is no superclass to inherit concrete fields/methods from, so there are no superclass overrides or uses of super.*. The class does implement interface methods: afterSingletonsInstantiated() (calls initializeMetadata()) and setApplicationEventPublisher(...) (stores the publisher). Those implementations are purposeful, not trivial one-line passthroughs to a parent.

3. New/Independent Functionality:
- The class introduces many fields (objectMapper, monitor, allExportedURLs, serviceRestMetadata, dubboCloudProperties, discoveryClient, etc.) and many methods for managing/exporting/unexporting URLs, loading and matching REST metadata, publishing events, initializing metadata, etc. These represent substantial Dubbo-related responsibilities.

4. Breadth of Subclass:
- The class is non-trivial: many fields, many methods, significant logic. It is a large, self-contained repository/service class.

5. Local Symptom Summary:
- Because the class does not extend a concrete parent class, there is no evidence of a subclass inheriting but refusing the parent's behavior. The class implements interface methods meaningfully and otherwise contains its own domain logic.

Final verdict:
NO, I did not find Refused Bequest. (No superclass is extended; the class implements interfaces and provides its own substantial functionality.)"
FakeValuesService.java,"1. Inheritance Pattern:
- This file defines class FakeValuesService which does not explicitly extend any class. It therefore only inherits from java.lang.Object.

2. Use of Inherited Functionality:
- There are no overrides of parent methods and no use of super.*. The class only uses ordinary Object features implicitly (getClass(), toString() in string(Object)), but no inherited API is specialized.

3. New/Independent Functionality:
- The class declares many of its own fields (fakeValuesList, randomService, log) and a large set of methods for fetching values, templating/resolution, string generation, reflection-based invocation and argument coercion. This is substantial, domain-specific functionality unrelated to any parent behavior.

4. Breadth of Subclass:
- The class is non-trivial: many methods and an inner static helper class. It is a full service implementation, not a light extension or marker.

5. Local Symptom Summary:
- Because FakeValuesService is not a subclass of a custom parent (only extends Object), the Refused Bequest smell does not apply here. There are no superclass members to refuse.

NO, I did not find Refused Bequest. Evidence: the class does not extend a meaningful parent (only Object), so it cannot exhibit a refused bequest."
PassphraseEntryController.java,"1. Inheritance Pattern:
- The class is declared as ""public class PassphraseEntryController implements FxController"". It implements the FxController interface and does not extend any other class (implicitly extends java.lang.Object).

2. Use of Inherited Functionality:
- There is no superclass to inherit from, so there are no inherited concrete methods or fields used or overridden. The class does not call super.* anywhere. It only implements an interface (FxController), for which no override of a superclass implementation is present in this file.

3. New/Independent Functionality:
- The class defines many fields and methods for UI behavior, password handling, animations, and interaction locking (passwordField, savePasswordCheckbox, unlockAnimation, unlock(), startUnlockAnimation(), stopUnlockAnimation(), didClickSavePasswordCheckbox(), windowClosed(), etc.). These are substantial, self-contained responsibilities unrelated to any parent class behavior (since there is none).

4. Breadth of Subclass:
- The class is non-trivial: many fields, bindings, animation setup, listeners, and user-interaction logic. It is a full-featured UI controller rather than a thin extension.

5. Local Symptom Summary:
- Refused Bequest does not apply: the class does not extend a parent class, so there is no superclass contract to refuse. The clearest sign is simply that no class extension is present — the type relationship is implementation of an interface only.

Final verdict:
NO, I did not find Refused Bequest — the class does not extend another class (only implements an interface), so the Refused Bequest smell cannot apply here."
LexemePath.java,"1. Inheritance Pattern:
- Yes. The class LexemePath extends QuickSortSet and implements Comparable<LexemePath>. The parent class name is QuickSortSet.

2. Use of Inherited Functionality:
- The subclass makes substantial use of inherited collection-like functionality: calls to addLexeme(...), isEmpty(), peekFirst(), peekLast(), pollLast(), getHead(), size() are scattered through the class.
- There are no obvious overrides of parent methods in this file (no methods annotated or clearly replacing parent behavior), and there are no super.method() calls. The subclass relies on parent-provided storage/traversal methods rather than ignoring them.

3. New/Independent Functionality:
- LexemePath introduces its own fields (pathBegin, pathEnd, payloadLength) and numerous methods (addCrossLexeme, addNotCrossLexeme, removeTail, checkCross, getXWeight, getPWeight, copy, compareTo, etc.). These add semantics for managing a lexeme ""path"" and computing weights/metrics.

4. Breadth of Subclass:
- The class is non-trivial: several fields, many methods, iteration/aggregation logic, and a compareTo implementation — clearly more than a light extension.

5. Local Symptom Summary:
- NO, I did not find Refused Bequest. Main evidence: the subclass heavily uses inherited collection operations (addLexeme, getHead, peekFirst/Last, pollLast, size) and builds path-specific logic on top of them, rather than ignoring or refusing the parent’s responsibilities. Although it adds substantial new behavior, that behavior appears to be a meaningful specialization of the parent’s collection/storage role rather than an unrelated responsibility."
PullAPIWrapper.java,"1. Inheritance Pattern:
- The file defines class PullAPIWrapper but it does not extend any other class (no ""extends"" clause). There is no parent class.

2. Use of Inherited Functionality:
- Not applicable: PullAPIWrapper does not subclass anything, so there are no overridden methods, no calls to super., and no direct use of inherited fields or methods.

3. New/Independent Functionality:
- The class introduces many fields and methods: MQClientInstance reference, consumerGroup/unitMode flags, pullFromWhichNodeTable, hooks list, random generator, methods for processing PullResult, pulling messages, computing filter server, hook execution, state setters/getters, etc. These represent substantial, self-contained responsibilities around pull request handling and message filtering.

4. Breadth of Subclass:
- Not a subclass. Nevertheless, the class itself is non-trivial: multiple fields and many methods, so it is a substantial class.

5. Local Symptom Summary:
- Because the class does not extend any parent, there is no evidence of a subclass refusing a bequest. The code shows a standalone, substantial implementation rather than a subclass that ignores inherited behavior.

Final decision:
NO, I did not find Refused Bequest."
ParamFlowChecker.java,"1. Inheritance Pattern:
- This file defines ""public final class ParamFlowChecker"" and it does not extend any other class (no ""extends"" clause). There is no parent class.

2. Use of Inherited Functionality:
- Not applicable: since ParamFlowChecker does not subclass anything, there are no overrides, no use of super., and no inherited fields or methods to use.

3. New/Independent Functionality:
- The class introduces substantial functionality of its own: many static methods implementing parameter flow checks (passCheck, passLocalCheck, passSingleValueCheck, passDefaultLocalCheck, passThrottleLocalCheck, passClusterCheck, etc.), plus helpers (toCollection, pickClusterService) and logic for token/time counters and cluster fallback. This is self-contained behavior unrelated to any parent.

4. Breadth of Subclass:
- Not a subclass, but the class is non-trivial: it contains many methods and complex logic (token-bucket-like replenishment, throttling, cluster integration). There are no instance fields, but the method set is large and substantive.

5. Local Symptom Summary:
- Because the class does not extend any other class, it cannot exhibit Refused Bequest in this file. There is no inheritance to refuse. The code is large and self-contained, but that is not evidence of Refused Bequest here.

Final conclusion:
NO, I did not find Refused Bequest."
SaTokenContextForThreadLocalStorage.java,"1. Inheritance Pattern:  
- This file defines class SaTokenContextForThreadLocalStorage. It does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:  
- Not applicable: there are no superclass methods/fields being overridden or referenced (no overrides, no use of super.).

3. New/Independent Functionality:  
- The class introduces its own static ThreadLocal<Box> boxThreadLocal and a set of static methods (setBox, clearBox, getBox, getBoxNotNull, getRequest, getResponse, getStorage).  
- It also defines an inner static Box class with its own fields (request, response, storage), getters/setters and toString — all self-contained behavior.

4. Breadth of Subclass:  
- Not a subclass at all. The top-level class is non-trivial (several fields and methods) but all functionality is independent and specific to ThreadLocal storage.

5. Local Symptom Summary:  
- There are no signs of Refused Bequest because no inheritance relationship exists to refuse. The clearest sign: the class does not extend a parent class and contains only self-contained storage-related logic.

NO, I did not find Refused Bequest — evidence: class does not extend any parent and contains no overrides or use of inherited members; all logic is self-contained ThreadLocal storage."
AbortedTransactionException.java,"1. Inheritance Pattern:  
Yes — the file defines class AbortedTransactionException which extends JedisDataException.

2. Use of Inherited Functionality:  
The subclass does not override any behavior; it only provides three constructors that delegate to super(...) (super(message), super(cause), super(message, cause)). These are trivial delegations and there are no uses of super beyond constructor chaining.

3. New/Independent Functionality:  
None — the class introduces no new fields or methods beyond the constructors.

4. Breadth of Subclass:  
The subclass is minimal/trivial (only constructors). It is not a large class with many new responsibilities.

5. Local Symptom Summary:  
No symptoms of Refused Bequest here: this is a lightweight specialization of an exception type (typical pattern) — no unrelated logic, no new fields, and no meaningful overrides.

NO, I did not find Refused Bequest."
HttpRequest.java,"1. Inheritance Pattern:
- Yes. The class is declared as ""public class HttpRequest extends HttpBase<HttpRequest>"". The parent class name is HttpBase.

2. Use of Inherited Functionality:
- The subclass makes substantive use of inherited methods/fields. Examples in this file:
  - Calls header(...) many times (e.g., contentType(), keepAlive(), auth(), proxyAuth(), initConnection() uses this.headers with .header()) — these header-related APIs likely come from HttpBase.
  - References inherited fields/properties such as charset, bodyBytes, headers, and httpVersion (e.g., isKeepAlive(), body(byte[]), urlWithParamIfGet()).
  - Overrides toString() but delegates to super.toString() (adds URL info then calls super.toString()) — a small override, but not the only interaction.
- The override is minor (toString only) and largely delegates to the parent, but overall the class repeatedly uses inherited functionality rather than completely ignoring it.

3. New/Independent Functionality:
- Yes. The class introduces many fields (url, urlHandler, method, interceptors, connectionTimeout, readTimeout, form, isMultiPart, cookie, httpConnection, isDisableCache, isRest, redirectCount, maxRedirectCount, blockSize, proxy, hostnameVerifier, ssf) and many request-specific methods (form handling, body handling, timeouts, proxy/SSL settings, execute/send logic, multipart handling, redirect handling, etc.). These are significant features focused on request construction/execution.

4. Breadth of Subclass:
- The subclass is non-trivial: it contains numerous fields and many private helper methods and public fluent API methods. This is a substantial class, not a light extension.

5. Local Symptom Summary:
- Despite the large amount of new functionality, the subclass actively uses inherited state and methods (headers, charset, bodyBytes, httpVersion, header(...) calls) and only provides one small override (toString) that delegates to super. Locally, there is no strong sign that inherited responsibilities are being refused.

Conclusion:
NO, I did not find Refused Bequest — the class extensively uses inherited fields/methods (headers, charset, bodyBytes, httpVersion, header(...) calls) and only has a minor toString override, so it does not exhibit the typical symptoms (many new unrelated features with little or no use of the parent)."
ProxyDatabaseMetaData.java,"1. Inheritance Pattern:  
- This file defines an abstract class ProxyDatabaseMetaData that implements the DatabaseMetaData interface. It does not extend another concrete/abstract class (no ""extends"" clause).

2. Use of Inherited Functionality:  
- Because it implements DatabaseMetaData, it provides many method implementations. It consistently delegates to the wrapped DatabaseMetaData instance (delegate) and then post-processes the results (wrapping ResultSet / Statement via ProxyFactory). It also overrides toString() and unwrap(...) and provides getConnection() that returns its ProxyConnection. These overrides and delegations are substantive (not just one-line calls to super, and there is no super usage since it doesn't extend a parent class).

3. New/Independent Functionality:  
- The class introduces its own fields (protected ProxyConnection connection; protected DatabaseMetaData delegate) and helper methods (checkException) and many implementations that wrap results into proxy objects. Those are clearly new responsibilities (proxying/wrapping behavior) but they are directly related to forwarding DatabaseMetaData calls and adapting returned objects.

4. Breadth of Subclass:  
- The class is non-trivial: it implements many DatabaseMetaData methods (large number of methods repeating the pattern of delegating + wrapping), plus utility methods. This is a substantial implementation, but it is cohesive around proxying behavior.

5. Local Symptom Summary:  
- No local symptoms of Refused Bequest. The class does not extend a concrete parent class, and the functionality it adds is tightly coupled to the DatabaseMetaData interface: it delegates to the delegate instance and consistently wraps returned statements/result sets. The clearest sign against Refused Bequest is: many meaningful method implementations that use the delegate and perform consistent proxying, rather than ignoring inherited/required behavior.

Final conclusion per instructions:
NO, I did not find Refused Bequest."
MethodCallInliner.java,"1. Inheritance Pattern:  
Yes. The file defines an abstract class MethodCallInliner that extends com.alibaba.arthas.deps.org.objectweb.asm.commons.GeneratorAdapter.

2. Use of Inherited Functionality:  
Yes. The subclass overrides several GeneratorAdapter/MethodVisitor methods: visitMethodInsn, visitTryCatchBlock, visitMaxs, and visitFrame. The overrides are substantive (visitMethodInsn implements an inlining sequence rather than just delegating), and it also calls super.visitLabel, super.visitTryCatchBlock and super.visitMaxs in appropriate places. Some overrides change core behavior (e.g., swallowing frames in visitFrame, full inlining logic in visitMethodInsn) rather than being trivial one-liners.

3. New/Independent Functionality:  
The class introduces several new members and responsibilities: a nested CatchBlock class, fields toBeInlined, blocks, inlining, afterInlining, and logic to inline a MethodNode via an InliningAdapter and collect/restore catch blocks. These are new but directly implement specialized bytecode inlining behavior (i.e., an extension of method-visiting responsibilities).

4. Breadth of Subclass:  
Non-trivial. It contains multiple fields, an inner class, a constructor, an abstract shouldBeInlined method, and several non-trivial overridden methods — clearly more than a light extension.

5. Local Symptom Summary:  
This subclass does not show the typical signs of Refused Bequest. Although it introduces significant new functionality and fields, those additions are directly related to and implemented by overriding and customizing the parent’s method-visiting behavior (substantive overrides, calls to super where appropriate). The clearest sign against Refused Bequest is the presence of multiple meaningful overrides that alter or extend GeneratorAdapter’s behavior rather than ignoring it.

NO, I did not find Refused Bequest. Evidence: substantive overrides of GeneratorAdapter methods (not mere pass-throughs) and use of super.* alongside new inlining logic that directly extends the parent's responsibilities."
IKArbitrator.java,"1. Inheritance Pattern:
- This file defines class IKArbitrator with no ""extends"" clause. It does not extend any parent class.

2. Use of Inherited Functionality:
- Not applicable: there is no superclass, so there are no inherited methods/fields to override, call, or use (no use of super.*).

3. New/Independent Functionality:
- The class introduces its own behavior: methods process(AnalyzeContext, boolean), judge(...), forwardPath(...), backPath(...). It has no fields, and the methods implement lexeme-disambiguation logic (stacks, TreeSet, path construction). This is self-contained functionality.

4. Breadth of Subclass:
- Not applicable as a subclass, but the class is non-trivial: several helper methods and algorithmic logic, so it is more than a trivial wrapper or marker.

5. Local Symptom Summary:
- Because the class does not extend any other class, there are no symptoms of Refused Bequest in this file — there is no inheritance relationship to refuse. The clearest sign is simply the absence of ""extends"" and any overrides.

NO, I did not find Refused Bequest"
SingleRoomBroadcastOperations.java,"1. Inheritance Pattern:
- This class (SingleRoomBroadcastOperations) does not extend another class; it implements the BroadcastOperations interface (implicitly extends Object).

2. Use of Inherited Functionality:
- There is no parent class with protected/inherited members to use. The class implements interface methods (annotated @Override) and provides concrete behavior. The only use of super() is the trivial Object constructor call in the constructor. No calls to super.method(...) or reliance on inherited state are present.

3. New/Independent Functionality:
- The class defines its own fields (namespace, room, clients, storeFactory) and many methods (send, sendEvent variants, disconnect, dispatch, getClients). These are focused on broadcasting logic for a single room and operate on its own state.

4. Breadth of Subclass:
- The class is non-trivial: multiple fields and several methods implement the broadcasting responsibilities. It’s a full implementation of BroadcastOperations for a single room.

5. Local Symptom Summary:
- There are no symptoms of Refused Bequest here: the class implements an interface rather than inheriting from a superclass, and the implemented methods meaningfully use the class’s own fields and perform cohesive broadcast-related behavior.

NO, I did not find Refused Bequest. Evidence: the class implements an interface (not extending a parent), provides substantive implementations that use its own fields, and has no trivial super-calls or unused inherited members."
Lorem.java,"1. Inheritance Pattern:
- This file defines class Lorem, and it does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:
- Not applicable: since Lorem does not extend a parent, there are no overrides, super. calls, or direct use of inherited protected members in this file.

3. New/Independent Functionality:
- Lorem introduces its own instance field (private final Faker faker), many public methods for generating characters, words, sentences, paragraphs, and static fields (letters, characters). These are substantial, self-contained responsibilities for text generation.

4. Breadth of Subclass:
- N/A as a subclass. The class itself is non-trivial: many methods and logic; not a light extension or marker.

5. Local Symptom Summary:
- Because Lorem does not inherit from a parent, it cannot exhibit Refused Bequest here. The clear sign is simply the absence of inheritance.

NO, I did not find Refused Bequest."
HostAndPort.java,"1. Inheritance Pattern:
- The file defines ""public final class HostAndPort implements Serializable"".
- It does not extend any explicit parent class; it implicitly extends java.lang.Object and implements the marker interface Serializable.

2. Use of Inherited Functionality:
- It overrides Object methods: equals(Object), hashCode(), and toString(), and those overrides are meaningful (compare host/port, produce hash, build host:port string).
- There are no calls to super.* and no interaction with inherited state beyond the normal Object contracts. It does not rely on or override any non-Object parent behavior (no protected parent members used).

3. New/Independent Functionality:
- The class declares its own fields (host, port, hasBracketlessColons) and many parsing and factory methods (fromString, fromParts, fromHost, getHostAndPortFromBracketedHost, withDefaultPort, requireBracketsForIPv6, etc.).
- The bulk of the logic is parsing/validation and formatting — clearly new/self-contained functionality.

4. Breadth of Subclass:
- The class is non-trivial: several private fields, multiple static factories, parsing helpers, validation methods, and public API methods. It is not a tiny extension.

5. Local Symptom Summary:
- This class does not extend a meaningful parent (only Object) and therefore there is no superclass contract being refused. The overrides present are appropriate overrides of Object methods and the class is self-contained with its own responsibilities (parsing/representing host:port).

Final determination:
NO, I did not find Refused Bequest. Evidence: the class does not extend any non-Object parent (only implements Serializable), and its methods are self-contained — the only overrides are proper Object-method implementations (equals/hashCode/toString), not signs of refusing an inherited contract."
DefaultJSONParser.java,"1. Inheritance Pattern:  
- This file defines ""public class DefaultJSONParser implements Closeable"".  
- It does not extend any other class (no ""extends"" clause). The only parent-like contract is the Closeable interface.

2. Use of Inherited Functionality:  
- Because DefaultJSONParser does not extend a concrete superclass, there are no inherited methods/fields from a parent class to override or call via super.  
- It implements Closeable and provides a close() method. That is the single interface method implemented; the close() implementation is specific and non-trivial (it checks lexer state and closes the lexer), not a trivial call to super.

3. New/Independent Functionality:  
- The class introduces many fields (lexer, config, symbolTable, context, resolveTaskList, dateFormatPattern, etc.) and a large number of parsing methods (parseObject, parseArray, parse, parseExtra, parseObject(Type...), handleResovleTask, many helpers).  
- These represent a complete JSON-parsing responsibility and are independent functionality.

4. Breadth of Subclass:  
- The class is large and non-trivial: many fields, many complex methods, internal static classes, and substantial logic. It is far more than a light extension or marker.

5. Local Symptom Summary:  
- Since DefaultJSONParser does not extend a parent class, the Refused Bequest smell (a subclass refusing inherited responsibilities) cannot apply here. The class implements an interface (Closeable) and otherwise defines extensive, cohesive parsing behavior.

Conclusion per instructions:  
NO, I did not find Refused Bequest. Evidence: the class does not extend any superclass (only implements Closeable), so there are no inherited members that it could be refusing to use; it defines large, self-contained parsing functionality."
AutoLocker.java,"1. Inheritance Pattern:
- No. This file defines ""public class AutoLocker"" and it does not extend any other class (no ""extends"" clause).

2. Use of Inherited Functionality:
- Not applicable: there is no parent class, so there are no inherited methods/fields to override, call via super., or use.

3. New/Independent Functionality:
- Yes. AutoLocker introduces its own fields (scheduler, vaultList) and methods (init, tick, autolock, exceedsIdleTime) that implement an auto-locking responsibility working with Vault objects.

4. Breadth of Subclass:
- The class is non-trivial for a standalone service (multiple methods and fields), but it is not a subclass at all.

5. Local Symptom Summary:
- There are no symptoms of Refused Bequest in this file because no inheritance is present. The class uses composition (Vault, scheduler) to perform its own behavior.

NO, I did not find Refused Bequest. (Main reason: AutoLocker does not extend any parent class, so it cannot refuse a bequest.)"
ReedSolomonDecoder.java,"NO, I did not find Refused Bequest

Step-by-step:

1. Inheritance Pattern:
- This file defines public final class ReedSolomonDecoder.
- It does not explicitly extend any class; it implicitly extends java.lang.Object.

2. Use of Inherited Functionality:
- There are no overrides of Object methods (no toString, equals, hashCode, finalize, etc.).
- There is no use of super. and no direct interaction with inherited state beyond the implicit Object behavior.
- All methods are original implementation logic (no trivial overrides calling only super).

3. New/Independent Functionality:
- The class introduces its own field: private final GenericGF field.
- It provides substantial domain-specific methods: decode(...), runEuclideanAlgorithm(...), findErrorLocations(...), findErrorMagnitudes(...), and related polynomial arithmetic — all clearly specific to Reed–Solomon decoding and unrelated to any Object responsibilities.

4. Breadth of Subclass:
- The class is non-trivial: several complex methods, algorithmic logic, and internal helper routines. This is not a light extension or marker type.

5. Local Symptom Summary:
- Because the class does not extend a meaningful parent (only Object) and does not inherit and ignore parent behavior, there is no evidence of Refused Bequest in this file. The clearest sign that the smell does not apply is that the class defines substantial, self-contained functionality and does not rely on or override any inherited contract."
ExecutionSequencer.java,"1. Inheritance Pattern:
- Yes. The nested class TaskNonReentrantExecutor extends AtomicReference<RunningState> (i.e., parent class: java.util.concurrent.atomic.AtomicReference).

2. Use of Inherited Functionality:
- The subclass does not override AtomicReference methods, but it does meaningfully use inherited functionality:
  - Calls super(NOT_RUN) in its constructor.
  - Calls get() (via get()) and compareAndSet(...) (via trySetStarted/trySetCancelled).
- No trivial overrides like only calling super.method() are present.

3. New/Independent Functionality:
- Yes. TaskNonReentrantExecutor adds several fields (sequencer, delegate, task, submitting) and implements substantial logic (execute, run, trySetStarted, trySetCancelled) to behave as an Executor/Runnable and to manage reentrancy and queuing. This is new functionality layered on top of the atomic state.

4. Breadth of Subclass:
- The subclass is non-trivial: multiple fields, multiple methods, complex control flow and comments — clearly more than a marker/light extension.

5. Local Symptom Summary:
- Although the class introduces considerable new responsibilities, it makes direct, essential use of AtomicReference's atomic operations to manage RunningState (get and compareAndSet) and calls the superclass constructor. This indicates the inheritance is used as a utility (state machine backed by an AtomicReference), not refused inheritance.

Final verdict:
NO, I did not find Refused Bequest — the subclass purposefully uses AtomicReference's atomic operations (compareAndSet/get) to manage its RunningState, so it is not merely ignoring the parent's features."
DirectedGraphConnections.java,"1. Inheritance Pattern:  
   This file defines ""DirectedGraphConnections<N, V>"" which implements the interface GraphConnections<N, V>. It does not extend any concrete parent class (implicitly extends Object).

2. Use of Inherited Functionality:  
   The class provides full implementations of the GraphConnections interface methods (adjacentNodes, predecessors, successors, incidentEdgeIterator, value, removePredecessor, removeSuccessor, addPredecessor, addSuccessor). There are no calls to super.* and no trivial overrides — the implementations are substantive and contain custom logic.

3. New/Independent Functionality:  
   The class introduces multiple fields (adjacentNodeValues, orderedNodeConnections, predecessorCount, successorCount), private helper types (PredAndSucc, NodeConnection and its subclasses), and many internal algorithms for managing adjacency, ordering, and iteration. Those additions are integral to implementing the interface, not unrelated responsibilities.

4. Breadth of Subclass:  
   The class is non-trivial: many fields, inner classes, and complex methods — not a light extension or marker.

5. Local Symptom Summary:  
   The code does not show symptoms of Refused Bequest: it is not a subclass of a concrete parent class, and the methods it implements are substantial and directly related to the GraphConnections contract.

Final verdict: NO, I did not find Refused Bequest. Evidence: the class implements an interface (no superclass) and provides substantial, non-trivial implementations rather than trivial/unused inherited members."
HttpServerTest.java,"1. Inheritance Pattern:
- Yes. This file defines two inner classes that extend other classes:
  - TestServer extends NanoHTTPD.
  - TestTempFileManager extends DefaultTempFileManager.

2. Use of Inherited Functionality:
- TestServer:
  - Overrides serve(IHTTPSession) and implements substantial behavior: reads session URI, method, headers, parses body (session.parseBody), reads parameters and query string, calls decodeParameters(...) (an inherited helper), and returns a Response. It also calls super(...) in its constructors. This is a meaningful use/specialization of the parent.
  - Provides createSession(...) methods that construct HTTPSession objects; these use parent-related types but are not trivial passthroughs.
- TestTempFileManager:
  - Overrides clear() but replaces it with an empty implementation (no-op). It also exposes a _clear() method that calls super.clear(). The override is trivial in code size but semantically removes the parent behavior (suppresses clearing).

3. New/Independent Functionality:
- TestServer introduces many fields (response, uri, method, header, parms, parameters, files, decodedParamters*, queryParameterString) and logic to populate them in serve(...) — these are test-specific responsibilities for capturing request state and returning responses.
- TestTempFileManager introduces a single helper method _clear(), and otherwise suppresses inherited behavior.

4. Breadth of Subclass:
- TestServer is non-trivial: several fields and methods (constructors, createSession overloads, serve override) — clearly more than a light extension.
- TestTempFileManager is small (one override and one helper method).

5. Local Symptom Summary:
- TestServer does not show Refused Bequest symptoms: it meaningfully overrides and uses parent API (serve, decodeParameters, session parsing).
- TestTempFileManager does show a symptom: it deliberately suppresses the parent’s clear() behavior by overriding it to a no-op while providing a separate _clear() that can call super.clear(). That is a form of refusing the parent's responsibility (not performing inherited cleanup) and thus a local sign of Refused Bequest.

Final verdict per instructions:
YES, I found Refused Bequest — TestTempFileManager overrides clear() to a no-op (refusing the parent’s cleanup responsibility) while only adding a helper _clear() that calls super.clear()."
ServiceLoader.java,"1. Inheritance Pattern:  
- This file defines ""public class ServiceLoader"" with no extends clause. It does not explicitly extend any class (implicitly extends java.lang.Object).

2. Use of Inherited Functionality:  
- There are no method overrides, no calls to super., and no interaction with inherited state beyond the default Object behavior. No inherited methods are overridden or specially used.

3. New/Independent Functionality:  
- The class introduces its own static fields (PREFIX, loadedUrls) and several static methods (load(Class, ClassLoader) and load(URL, Set<String>)) implementing service-loading logic — clearly its own responsibility.

4. Breadth of Subclass:  
- The class is non-trivial: multiple fields and complete methods for resource discovery and parsing. It is a full utility class rather than a light extension.

5. Local Symptom Summary:  
- Because this class does not extend a non-trivial parent (only Object), there is no evidence of a subclass refusing a parent's bequest. The clearest sign is that there are no overrides or super usage and the class defines all its functionality itself.

NO, I did not find Refused Bequest — the class does not extend another concrete parent (only Object) and has no overridden or inherited behavior to refuse."
JedisSentinelPool.java,"1. Inheritance Pattern:  
Yes. The class JedisSentinelPool extends Pool<Jedis> (parent class name: Pool).

2. Use of Inherited Functionality:  
Yes. The subclass overrides several Pool methods (destroy(), getResource(), returnResource()). It calls super(...) in the constructor, and calls super.getResource(), super.returnResource(), super.clear(), and super.destroy() in its logic. The overrides are substantive (e.g., getResource adds a loop and validation against currentHostMaster; returnResource resets state and handles exceptions; destroy shuts down listeners before delegating), not trivial one-liners.

3. New/Independent Functionality:  
Yes. The class introduces many new fields (factory, sentinelClientConfig, masterListeners, currentHostMaster, initPoolLock) and numerous methods for sentinel behavior (initSentinels, initMaster, toHostAndPort, many constructors) plus an inner MasterListener thread class that manages subscription and failover detection. These represent substantial sentinel-specific responsibilities beyond a generic pool.

4. Breadth of Subclass:  
Yes. The subclass is non-trivial: many constructors, several helper methods, state fields, and a complex inner class. This is not a light extension or marker.

5. Local Symptom Summary:  
Although the class adds a lot of new, sentinel-specific functionality, it also meaningfully uses and overrides Pool behavior (calls to super.getResource(), super.clear(), super.returnResource(), super.destroy(), and a non-trivial getResource override that preserves pooling semantics). The new logic complements the pool responsibilities (ensuring resources belong to current master and managing pool state on master changes).

Final verdict: NO, I did not find Refused Bequest. Evidence: the subclass both substantially extends the parent with sentinel-specific behavior and meaningfully uses/overrides Pool methods (non-trivial overrides and calls to super methods), so it is specializing the pool rather than refusing the parent's contract."
SimpleEchoSocket.java,"1. Inheritance Pattern:  
   - This file defines class SimpleEchoSocket with no ""extends"" clause. It does not extend any parent class.

2. Use of Inherited Functionality:  
   - Not applicable: there are no inherited methods/fields to override or call (no use of super., no @Override methods).

3. New/Independent Functionality:  
   - The class introduces its own fields (receivedMessages, toSendMessages, closeLatch) and methods (onConnect, onClose, onMessage, awaitClose, getters). These implement websocket client behavior via Jetty annotations, but they are local behavior, not specialization of a parent.

4. Breadth of Subclass:  
   - Not applicable: the class is standalone and non-trivial (multiple fields and methods), but it is not a subclass.

5. Local Symptom Summary:  
   - There are no signs of Refused Bequest because there is no inheritance here to refuse. The class is an independent websocket handler with its own responsibilities.

NO, I did not find Refused Bequest."
RestAdapter.java,"1. Inheritance Pattern:
- This file does not define any class that extends another class (no ""extends"" usage). The nested RestHandler implements InvocationHandler; Builder is a static nested class; other types are enums or interfaces. There is no explicit superclass other than java.lang.Object.

2. Use of Inherited Functionality:
- Not applicable: because there is no subclass extending a concrete parent class here, there are no overridden methods or uses of super.* to inspect. RestHandler implements an interface (InvocationHandler) and provides its required invoke method.

3. New/Independent Functionality:
- The RestAdapter class (and its nested classes) introduce many fields and methods for building and executing HTTP requests, logging, profiling, and async handling. These are the class’s primary responsibilities, but they are not evidence of a subclass refusing a parent because there is no parent-subclass relationship present in this file.

4. Breadth of Subclass:
- Not applicable as there is no subclass. RestAdapter is a non-trivial top-level class with many members, but it is not extending another class.

5. Local Symptom Summary:
- There is no sign of Refused Bequest in this file because no class extends another class whose inherited members are being ignored or unused.

NO, I did not find Refused Bequest. (Main evidence: no ""extends"" subclassing present in this file.)"
